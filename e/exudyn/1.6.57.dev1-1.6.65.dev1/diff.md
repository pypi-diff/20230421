# Comparing `tmp/exudyn-1.6.57.dev1-cp39-cp39-win_amd64.whl.zip` & `tmp/exudyn-1.6.65.dev1-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,38 @@
-Zip file size: 2203848 bytes, number of entries: 36
--rw-rw-rw-  2.0 fat   203014 b- defN 23-Feb-16 08:35 exudyn/FEM.py
+Zip file size: 2206186 bytes, number of entries: 36
+-rw-rw-rw-  2.0 fat   212931 b- defN 23-Apr-21 06:54 exudyn/FEM.py
 -rw-rw-rw-  2.0 fat    42942 b- defN 23-Jan-12 07:22 exudyn/GUI.py
 -rw-rw-rw-  2.0 fat     6474 b- defN 23-Jan-12 22:51 exudyn/__init__.py
 -rw-rw-rw-  2.0 fat    16183 b- defN 23-Feb-13 16:15 exudyn/advancedUtilities.py
 -rw-rw-rw-  2.0 fat    15264 b- defN 23-Mar-20 11:48 exudyn/artificialIntelligence.py
 -rw-rw-rw-  2.0 fat    11393 b- defN 23-Feb-16 08:35 exudyn/basicUtilities.py
 -rw-rw-rw-  2.0 fat    35948 b- defN 23-Feb-13 08:08 exudyn/beams.py
 -rw-rw-rw-  2.0 fat     7288 b- defN 23-Mar-06 07:23 exudyn/demos.py
--rw-rw-rw-  2.0 fat  5756416 b- defN 23-Apr-15 13:53 exudyn/exudynCPP.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat  5756416 b- defN 23-Apr-21 07:12 exudyn/exudynCPP.cp39-win_amd64.pyd
 -rw-rw-rw-  2.0 fat    85436 b- defN 23-Mar-27 06:21 exudyn/graphicsDataUtilities.py
 -rw-rw-rw-  2.0 fat    53048 b- defN 23-Feb-16 08:35 exudyn/interactive.py
--rw-rw-rw-  2.0 fat   158659 b- defN 23-Apr-15 13:45 exudyn/itemInterface.py
+-rw-rw-rw-  2.0 fat   158659 b- defN 23-Apr-21 07:00 exudyn/itemInterface.py
 -rw-rw-rw-  2.0 fat    32746 b- defN 23-Mar-14 16:29 exudyn/kinematicTree.py
 -rw-rw-rw-  2.0 fat    21846 b- defN 23-Mar-27 18:51 exudyn/lieGroupBasics.py
 -rw-rw-rw-  2.0 fat    13557 b- defN 22-Jul-11 07:16 exudyn/lieGroupIntegration.py
 -rw-rw-rw-  2.0 fat     3165 b- defN 23-Jan-09 06:59 exudyn/machines.py
 -rw-rw-rw-  2.0 fat     6169 b- defN 23-Feb-20 07:14 exudyn/physics.py
 -rw-rw-rw-  2.0 fat    50407 b- defN 23-Feb-16 08:35 exudyn/plot.py
 -rw-rw-rw-  2.0 fat    71531 b- defN 23-Apr-06 12:54 exudyn/processing.py
 -rw-rw-rw-  2.0 fat    14646 b- defN 23-Jan-09 06:59 exudyn/resultsMonitor.py
--rw-rw-rw-  2.0 fat    65543 b- defN 23-Mar-28 12:54 exudyn/rigidBodyUtilities.py
+-rw-rw-rw-  2.0 fat    66182 b- defN 23-Apr-21 06:54 exudyn/rigidBodyUtilities.py
 -rw-rw-rw-  2.0 fat    15158 b- defN 23-Apr-15 13:44 exudyn/signalProcessing.py
 -rw-rw-rw-  2.0 fat    27593 b- defN 23-Feb-16 08:35 exudyn/solver.py
 -rw-rw-rw-  2.0 fat    66527 b- defN 23-Apr-15 13:44 exudyn/utilities.py
 -rw-rw-rw-  2.0 fat      898 b- defN 21-Dec-03 09:28 exudyn/robotics/__init__.py
 -rw-rw-rw-  2.0 fat    24507 b- defN 23-Apr-06 06:16 exudyn/robotics/future.py
 -rw-rw-rw-  2.0 fat      527 b- defN 21-Dec-03 09:28 exudyn/robotics/mobile.py
 -rw-rw-rw-  2.0 fat    32539 b- defN 23-Mar-29 09:16 exudyn/robotics/models.py
 -rw-rw-rw-  2.0 fat    26097 b- defN 22-Mar-01 19:40 exudyn/robotics/motion.py
 -rw-rw-rw-  2.0 fat    97871 b- defN 23-Mar-29 16:14 exudyn/robotics/roboticsCore.py
 -rw-rw-rw-  2.0 fat    15166 b- defN 23-Apr-06 06:16 exudyn/robotics/special.py
 -rw-rw-rw-  2.0 fat     5171 b- defN 23-Apr-15 13:43 exudyn/robotics/utilities.py
--rw-rw-rw-  2.0 fat     1653 b- defN 23-Apr-15 13:53 exudyn-1.6.57.dev1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-15 13:53 exudyn-1.6.57.dev1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Apr-15 13:53 exudyn-1.6.57.dev1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2906 b- defN 23-Apr-15 13:53 exudyn-1.6.57.dev1.dist-info/RECORD
-36 files, 6988395 bytes uncompressed, 2199320 bytes compressed:  68.5%
+-rw-rw-rw-  2.0 fat     1653 b- defN 23-Apr-21 07:12 exudyn-1.6.65.dev1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-21 07:12 exudyn-1.6.65.dev1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Apr-21 07:12 exudyn-1.6.65.dev1.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2906 b- defN 23-Apr-21 07:12 exudyn-1.6.65.dev1.dist-info/RECORD
+36 files, 6998951 bytes uncompressed, 2201658 bytes compressed:  68.6%
```

## zipnote {}

```diff
@@ -90,20 +90,20 @@
 
 Filename: exudyn/robotics/special.py
 Comment: 
 
 Filename: exudyn/robotics/utilities.py
 Comment: 
 
-Filename: exudyn-1.6.57.dev1.dist-info/METADATA
+Filename: exudyn-1.6.65.dev1.dist-info/METADATA
 Comment: 
 
-Filename: exudyn-1.6.57.dev1.dist-info/WHEEL
+Filename: exudyn-1.6.65.dev1.dist-info/WHEEL
 Comment: 
 
-Filename: exudyn-1.6.57.dev1.dist-info/top_level.txt
+Filename: exudyn-1.6.65.dev1.dist-info/top_level.txt
 Comment: 
 
-Filename: exudyn-1.6.57.dev1.dist-info/RECORD
+Filename: exudyn-1.6.65.dev1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## exudyn/FEM.py

```diff
@@ -11,15 +11,18 @@
 # Notes: 	internal CSR matrix storage format contains 3 float numbers per row: [row, column, value], can be converted to scipy csr sparse matrices with function CSRtoScipySparseCSR(...)
 #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 #constants and fixed structures:
 import exudyn.itemInterface as eii
 #from exudyn.utilities import 
 from exudyn.advancedUtilities import IsListOrArray, RoundMatrix, PlotLineCode
-from exudyn.rigidBodyUtilities import GetRigidBodyNode, AngularVelocity2EulerParameters_t, EulerParameters2GLocal, RotationVector2GLocal, RotXYZ2GLocal, RotXYZ2GLocal_t, ComputeSkewMatrix, Skew, eulerParameters0
+from exudyn.rigidBodyUtilities import GetRigidBodyNode, AngularVelocity2EulerParameters_t, EulerParameters2GLocal, \
+             RotationVector2GLocal, RotXYZ2GLocal, RotXYZ2GLocal_t, ComputeSkewMatrix, Skew, eulerParameters0, \
+             StrNodeType2NodeType
+
 from exudyn.graphicsDataUtilities import ComputeTriangleArea
 import numpy as np #LoadSolutionFile
 from enum import Enum #for class HCBstaticModeSelection
 
 #convert zero-based sparse matrix data to dense numpy matrix
 #DEPRECTAED!!!!!!!!!!!!!!!!
 def CompressedRowToDenseMatrix(sparseData):
@@ -277,24 +280,35 @@
         surfaceElementsDict = {'elements':np.array(surfaceElements), 'elementTypes':surfaceElementTypes}
         return [np.array(nodes), elementsDict, surfaceElementsDict]
 
 
 
 
 #**function: convert list of Hex8/C3D8  element with 8 nodes in nodeNumbers into triangle-List
-#also works for Hex20 elements, but does only take the corner nodes!
+#**notes: works for Hex20 elements, but does only take the corner nodes for drawing!
 def ConvertHexToTrigs(nodeNumbers):
     localList = [[0,1,2], [0,2,3], [6,5,4], [6,4,7], [0,4,1], [1,4,5], [1,5,2], [2,5,6], [2,6,3], [3,6,7], [3,7,0], [0,7,4]]
 
     trigList = []
     for trig in localList:
         ind = [nodeNumbers[trig[0]], nodeNumbers[trig[1]], nodeNumbers[trig[2]]]
         trigList += [ind]
     return trigList
 
+#**function: convert list of Tet4/Tet10 element with 4 or 10 nodes in nodeNumbers into triangle-List
+#**notes: works for Tet10 elements, but does only take the corner nodes for drawing!
+def ConvertTetToTrigs(nodeNumbers):
+    localList = [[0,1,2], [0,3,1], [1,3,2], [0,2,3]]
+
+    trigList = []
+    for trig in localList:
+        ind = [nodeNumbers[trig[0]], nodeNumbers[trig[1]], nodeNumbers[trig[2]]]
+        trigList += [ind]
+    return trigList
+
 
 
 #**function: convert numpy.array dense matrix to (internal) compressed row format
 def ConvertDenseToCompressedRowMatrix(denseMatrix):
     sparseMatrix = []
     (nRows,nColumns) = denseMatrix.shape
     for i in range(nRows):
@@ -1006,87 +1020,180 @@
 #  class used internally in FEMinterface to compute ObjectFFRFreducedOrder dictionary
 #  this class holds all data for ObjectFFRFreducedOrder user functions
 class ObjectFFRFreducedOrderInterface:
     #**classFunction: initialize ObjectFFRFreducedOrderInterface with FEMinterface class
     #  initializes the ObjectFFRFreducedOrderInterface with nodes, modes, surface description and reduced system matrices from FEMinterface
     #  data is then transfered to mbs object with classFunction AddObjectFFRFreducedOrderWithUserFunctions(...)
     #**input: 
-    #  femInterface: must provide nodes, surfaceTriangles, modeBasis, massMatrix, stiffness
+    #  femInterface: must provide nodes, surfaceTriangles, modeBasis, massMatrix, stiffness; if femInterface=None, an empty ObjectFFRFreducedOrderInterface instance is created which may be used to load data with LoadFromFile()
     #  roundMassMatrix: use this value to set entries of reduced mass matrix to zero which are below the treshold
     #  roundStiffnessMatrix: use this value to set entries of reduced stiffness matrix to zero which are below the treshold
-    def __init__(self, femInterface, rigidBodyNodeType = 'NodeType.RotationEulerParameters',
+    def __init__(self, femInterface=None, rigidBodyNodeType = 'NodeType.RotationEulerParameters',
                  roundMassMatrix = 1e-13, roundStiffnessMatrix = 1e-13):
  
-        self.femInterface = femInterface
-        self.modeBasis = femInterface.modeBasis['matrix']
-        nodeArray = femInterface.GetNodePositionsAsArray()
-        self.trigList = femInterface.GetSurfaceTriangles()
+        if femInterface!=None:
+            #self.femInterface = femInterface #2023-04-20: removed in order to consistenly store class
+            self.modeBasis = femInterface.modeBasis['matrix']
+            nodeArray = femInterface.GetNodePositionsAsArray()
+            self.trigList = femInterface.GetSurfaceTriangles()
+            self.postProcessingModes = femInterface.postProcessingModes
+    
+            stiffnessMatrixCSR = CSRtoScipySparseCSR(femInterface.GetStiffnessMatrix(sparse=True))
+            massMatrixCSR = CSRtoScipySparseCSR(femInterface.GetMassMatrix(sparse=True))
+    
+            #compute reduced mass and stiffness matrices, only flexible coordinates:
+            self.massMatrixReduced = self.modeBasis.T @ massMatrixCSR @ self.modeBasis #LARGE MATRIX COMPUTATION
+            self.stiffnessMatrixReduced = self.modeBasis.T @ stiffnessMatrixCSR @ self.modeBasis #LARGE MATRIX COMPUTATION
+            RoundMatrix(self.massMatrixReduced, roundMassMatrix*abs(self.massMatrixReduced).max()) #erase off-diagonal terms for higher efficiency ...
+            RoundMatrix(self.stiffnessMatrixReduced, roundStiffnessMatrix*abs(self.stiffnessMatrixReduced).max())
+    
+            #new coordinates:
+            #nODE2 = nNodes*3        #non reduced, full coordinates
+            #nODE2reduced = nModes
+            self.nModes = self.modeBasis.shape[1]                 #number of columns in self.modeBasis is the number of modes to consider
+            self.nNodes = len(nodeArray)                #stored in nNodes x 3 np-array
+            self.dim3D = len(nodeArray[0])              #dimension of position, assuming that one node exists ....
+            
+            self.rigidBodyNodeType = rigidBodyNodeType
+            if str(self.rigidBodyNodeType) == 'NodeType.RotationEulerParameters':
+                self.nODE2rot = 4                       #Euler parameters
+            else:
+                self.nODE2rot = 3
+            
+            self.nODE2rigid = self.dim3D + self.nODE2rot
+            self.nODE2FFRFreduced = self.nODE2rigid + self.nModes
+    
+            self.massMatrixFFRFreduced = np.zeros((self.nODE2FFRFreduced,self.nODE2FFRFreduced)) #create larger FFRF mass matrix
+    
+            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+            #FFRFreduced constant matrices:
+            Phit = np.kron(np.ones(self.nNodes),np.eye(3)).T
+            PhitTM = Phit.T @ massMatrixCSR #LARGE MATRIX COMPUTATION
+            self.xRef = nodeArray.flatten()          #node reference values in single vector (can be added then to q[7:])
+            xRefTilde = ComputeSkewMatrix(self.xRef) #rfTilde without q    
+            self.inertiaLocal = xRefTilde.T @ massMatrixCSR @ xRefTilde #LARGE MATRIX COMPUTATION
+    
+            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
+            #prepare CMS matrices (some already given):
+            #according to: A. Zw\"olfer, J. Gerstmayr. The nodal-based floating frame of reference formulation with modal reduction, Acta Mechanica, 2020, submitted.
+            #\bar x = xRef
+            #\tilde \bar x = xRefTilde
+            #\bar Theta = inertiaLocal
+            #\bar mPsiPsi = massMatrixReduced
+            #Psi = self.modeBasis
+            self.Mtt = PhitTM @ Phit
+            self.totalMass = self.Mtt[0,0]                #Mtt must be diagonal matrix with mass in diagonal
+            self.PsiTilde = ComputeSkewMatrix(self.modeBasis)
+            self.chiU = 1./self.totalMass*(PhitTM @ self.xRef)                 #center of mass
+            self.chiUtilde = ComputeSkewMatrix(self.chiU)
+            self.mPsiTildePsi = self.PsiTilde.T @ massMatrixCSR @ self.modeBasis         #LARGE MATRIX COMPUTATION
+            self.mPsiTildePsiTilde = self.PsiTilde.T @ massMatrixCSR @ self.PsiTilde#LARGE MATRIX COMPUTATION
+            self.mPhitTPsi = Phit.T @ massMatrixCSR @ self.modeBasis                #LARGE MATRIX COMPUTATION
+            self.mPhitTPsiTilde = Phit.T @ massMatrixCSR @ self.PsiTilde       #LARGE MATRIX COMPUTATION
+            self.mXRefTildePsi = xRefTilde.T @ massMatrixCSR @ self.modeBasis       #LARGE MATRIX COMPUTATION
+            self.mXRefTildePsiTilde = xRefTilde.T @ massMatrixCSR @ self.PsiTilde    #LARGE MATRIX COMPUTATION
+    
+            #fill already parts of the mass matrix in order to avoid copying this constant data during user function calls:
+            self.massMatrixFFRFreduced[0:3,0:3] = self.Mtt
+            #FillInSubMatrix(self.massMatrixReduced, self.massMatrixFFRFreduced, self.nODE2rigid, self.nODE2rigid)
+            self.massMatrixFFRFreduced[self.nODE2rigid:,self.nODE2rigid:] = self.massMatrixReduced
 
-        stiffnessMatrixCSR = CSRtoScipySparseCSR(femInterface.GetStiffnessMatrix(sparse=True))
-        massMatrixCSR = CSRtoScipySparseCSR(femInterface.GetMassMatrix(sparse=True))
+    #**classFunction: save all data to a data filename; can be used to avoid loading femInterface and FE data
+    #**input: 
+    #  fileName: string for path and file name without ending ==> ".npy" will be added
+    #  fileVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; version must by > 0; the default value will change in future!
+    #**output: stores file
+    def SaveToFile(self, fileName, fileVersion = 1 ):
+        fileExtension = ''
+        if len(fileName) < 4 or fileName[-4:]!='.npy':
+            fileExtension = '.npy'
+        with open(fileName+fileExtension, 'wb') as f:
+            np.save(f, np.array([int(fileVersion)])) #array allows to add more data in future
 
-        #compute reduced mass and stiffness matrices, only flexible coordinates:
-        self.massMatrixReduced = self.modeBasis.T @ massMatrixCSR @ self.modeBasis #LARGE MATRIX COMPUTATION
-        self.stiffnessMatrixReduced = self.modeBasis.T @ stiffnessMatrixCSR @ self.modeBasis #LARGE MATRIX COMPUTATION
-        RoundMatrix(self.massMatrixReduced, 1e-13*abs(self.massMatrixReduced).max()) #erase off-diagonal terms for higher efficiency ...
-        RoundMatrix(self.stiffnessMatrixReduced, 1e-13*abs(self.stiffnessMatrixReduced).max())
+            np.save(f, self.modeBasis)
+            np.save(f, self.trigList, allow_pickle=True)
+            np.save(f, self.postProcessingModes, allow_pickle=True)
+            np.save(f, self.massMatrixReduced)
+            np.save(f, self.stiffnessMatrixReduced)
+            
+            infoList = np.array([self.nModes, self.nNodes, self.dim3D, self.nODE2rot, self.nODE2rigid, self.nODE2FFRFreduced])
+            np.save(f, infoList)
+            np.save(f, str(self.rigidBodyNodeType), allow_pickle=True)
+
+            np.save(f, self.xRef)
+
+            np.save(f, self.inertiaLocal)
+            np.save(f, self.Mtt)
+            np.save(f, self.totalMass)
+            np.save(f, self.chiU)
+            np.save(f, self.chiUtilde)
+            np.save(f, self.mPsiTildePsi)
+            np.save(f, self.mPsiTildePsiTilde)
+            np.save(f, self.mPhitTPsi)
+            np.save(f, self.mPhitTPsiTilde)
+            np.save(f, self.mXRefTildePsi)
+            np.save(f, self.mXRefTildePsiTilde)
+    
+            #np.save(f, self.PsiTilde) #large (3 x modeBasis)!, not needed
+            #np.save(f, self.Phit)
+            #np.save(f, self.PhitTM)
+            #np.save(f, self.xRefTilde)
+            #np.save(f, self.massMatrixFFRFreduced) #created when loaded; only needed for user functions
 
-        #new coordinates:
-        #nODE2 = nNodes*3        #non reduced, full coordinates
-        #nODE2reduced = nModes
-        self.nModes = self.modeBasis.shape[1]                 #number of columns in self.modeBasis is the number of modes to consider
-        self.nNodes = len(nodeArray)                #stored in nNodes x 3 np-array
-        self.dim3D = len(nodeArray[0])              #dimension of position, assuming that one node exists ....
-        
-        self.rigidBodyNodeType = rigidBodyNodeType
-        if str(self.rigidBodyNodeType) == 'NodeType.RotationEulerParameters':
-            self.nODE2rot = 4                       #Euler parameters
-        else:
-            self.nODE2rot = 3
-        
-        self.nODE2rigid = self.dim3D + self.nODE2rot
-        self.nODE2FFRFreduced = self.nODE2rigid + self.nModes
+    #**classFunction: load all data (nodes, elements, ...) from a data filename previously stored with SaveToFile(...). 
+    #this function is much faster than the text-based import functions
+    #**input: 
+    #  fileName: string for path and file name without ending ==> ".npy" will be added
+    #**output: loads data into fem (note that existing values are not overwritten!)
+    def LoadFromFile(self, fileName):
+        fileExtension = ''
+        fileVersion = None
+        if len(fileName) < 4 or fileName[-4:]!='.npy':
+            fileExtension = '.npy'
+        with open(fileName+fileExtension, 'rb') as f:
+            fileVersion = int(np.load(f)[0])
+            self.modeBasis = np.load(f)
+            self.trigList = np.load(f, allow_pickle=True).tolist()
+            self.postProcessingModes = np.load(f, allow_pickle=True)
+            self.massMatrixReduced = np.load(f)
+            self.stiffnessMatrixReduced = np.load(f)
+
+            infoList = list(np.load(f))
+            #print('list=',infoList)
+            [self.nModes, self.nNodes, self.dim3D, self.nODE2rot, self.nODE2rigid, self.nODE2FFRFreduced] = infoList
+
+            self.rigidBodyNodeType = StrNodeType2NodeType(np.load(f, allow_pickle=True))
+
+            #this term is large, but currently needed for markers / constraints!
+            self.xRef = np.load(f)
+
+            #reduced inertia terms
+            self.inertiaLocal = np.load(f)
+            self.Mtt = np.load(f)
+            self.totalMass = np.load(f)
+            self.chiU = np.load(f)
+            self.chiUtilde = np.load(f)
+            self.mPsiTildePsi = np.load(f)
+            self.mPsiTildePsiTilde = np.load(f)
+            self.mPhitTPsi = np.load(f)
+            self.mPhitTPsiTilde = np.load(f)
+            self.mXRefTildePsi = np.load(f)
+            self.mXRefTildePsiTilde = np.load(f)
+            
+            # if fileVersion>1:
+            #     #do things here for higher versions in future
 
         self.massMatrixFFRFreduced = np.zeros((self.nODE2FFRFreduced,self.nODE2FFRFreduced)) #create larger FFRF mass matrix
-
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #FFRFreduced constant matrices:
-        self.Phit = np.kron(np.ones(self.nNodes),np.eye(3)).T
-        self.PhitTM = self.Phit.T @ massMatrixCSR #LARGE MATRIX COMPUTATION
-        self.xRef = nodeArray.flatten()          #node reference values in single vector (can be added then to q[7:])
-        self.xRefTilde = ComputeSkewMatrix(self.xRef) #rfTilde without q    
-        self.inertiaLocal = self.xRefTilde.T @ massMatrixCSR @ self.xRefTilde #LARGE MATRIX COMPUTATION
-
-        #+++++++++++++++++++++++++++++++++++++++++++++++++++++++
-        #prepare CMS matrices (some already given):
-        #according to: A. Zw\"olfer, J. Gerstmayr. The nodal-based floating frame of reference formulation with modal reduction, Acta Mechanica, 2020, submitted.
-        #\bar x = xRef
-        #\tilde \bar x = xRefTilde
-        #\bar Theta = inertiaLocal
-        #\bar mPsiPsi = massMatrixReduced
-        #Psi = self.modeBasis
-        self.Mtt = self.PhitTM @ self.Phit
-        self.totalMass = self.Mtt[0,0]                #Mtt must be diagonal matrix with mass in diagonal
-        self.PsiTilde = ComputeSkewMatrix(self.modeBasis)
-        self.chiU = 1./self.totalMass*(self.PhitTM @ self.xRef)                 #center of mass
-        self.chiUtilde = ComputeSkewMatrix(self.chiU)
-        self.mPsiTildePsi = self.PsiTilde.T @ massMatrixCSR @ self.modeBasis         #LARGE MATRIX COMPUTATION
-        self.mPsiTildePsiTilde = self.PsiTilde.T @ massMatrixCSR @ self.PsiTilde#LARGE MATRIX COMPUTATION
-        self.mPhitTPsi = self.Phit.T @ massMatrixCSR @ self.modeBasis                #LARGE MATRIX COMPUTATION
-        self.mPhitTPsiTilde = self.Phit.T @ massMatrixCSR @ self.PsiTilde       #LARGE MATRIX COMPUTATION
-        self.mXRefTildePsi = self.xRefTilde.T @ massMatrixCSR @ self.modeBasis       #LARGE MATRIX COMPUTATION
-        self.mXRefTildePsiTilde = self.xRefTilde.T @ massMatrixCSR @ self.PsiTilde    #LARGE MATRIX COMPUTATION
-
         #fill already parts of the mass matrix in order to avoid copying this constant data during user function calls:
         self.massMatrixFFRFreduced[0:3,0:3] = self.Mtt
         #FillInSubMatrix(self.massMatrixReduced, self.massMatrixFFRFreduced, self.nODE2rigid, self.nODE2rigid)
         self.massMatrixFFRFreduced[self.nODE2rigid:,self.nODE2rigid:] = self.massMatrixReduced
-
-    #unused, because done separately in FEMinterface:  computeOutputVariableModeBasis: provide exudyn.OutputVariableType for postprocessing (set to 0 if unused); currently this is only available for linear tetrahedral elements and for exudyn.OutputVariableType = StrainLocal or StressLocal
-
+                
+        return fileVersion
+        
     ##  UFforce: (OPTIONAL, computation is slower) provide a user function, which computes the quadratic velocity vector and applied forces; usually this function reads like:\\ \texttt{def UFforceFFRFreducedOrder(mbs, t, itemIndex, qReduced, qReduced\_t):\\ \phantom{XXXX}return cms.UFforceFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)}
 
     #**classFunction: add according nodes, objects and constraints for ObjectFFRFreducedOrder object to MainSystem mbs; use this function with userfunctions=0 in order to use internal C++ functionality, which is approx. 10x faster; implementation of userfunctions also available for rotation vector (Lie group formulation), which needs further testing
     #**input:
     #  exu: the exudyn module
     #  mbs: a MainSystem object
     #  positionRef: reference position of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
@@ -1152,24 +1259,24 @@
         self.loadGravity = None #only defined if LoadMassProportional is added
         #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         #check if postProcessingModes exist
         outputVariableModeBasis = []
         outputVariableTypeModeBasis = 0
         #FEM: self.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
 
-        if 'matrix' in self.femInterface.postProcessingModes:
+        if 'matrix' in self.postProcessingModes:
             #check FEMinterface if modes exist:
-            if str(self.femInterface.postProcessingModes['outputVariableType']) == 'OutputVariableType.StressLocal':
+            if str(self.postProcessingModes['outputVariableType']) == 'OutputVariableType.StressLocal':
                 outputVariableTypeModeBasis = exu.OutputVariableType.StressLocal
-            elif str(self.femInterface.postProcessingModes['outputVariableType']) == 'OutputVariableType.StrainLocal':
+            elif str(self.postProcessingModes['outputVariableType']) == 'OutputVariableType.StrainLocal':
                 outputVariableTypeModeBasis = exu.OutputVariableType.StrainLocal
             else:
                 raise ValueError('AddObjectFFRFreducedOrderWithUserFunctions(...): invalid outputVariableType in postProcessingModes')
 
-            outputVariableModeBasis  = self.femInterface.postProcessingModes['matrix']
+            outputVariableModeBasis  = self.postProcessingModes['matrix']
             
         #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         #generic node for modal coordinates in ObjectFFRFreducedOrder
         self.nGenericODE2 = mbs.AddNode(eii.NodeGenericODE2(numberOfODE2Coordinates=self.nModes,
                                           referenceCoordinates=[0]*self.nModes,
                                           initialCoordinates=[0]*self.nModes,
                                           initialCoordinates_t=[0]*self.nModes))
@@ -1446,73 +1553,118 @@
     # fem.eigenValues = []           # [ev0, ev1, ...]                                                                             #eigenvalues according to eigenvectors in mode basis
     # fem.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
     def __init__(self):
         self.nodes = {}                 # {'Position':[[x0,y0,z0],...], 'RigidBodyRxyz':[[x0,y0,z0],...],  },...]                     #dictionary of different node lists
         self.elements = []              # [{'Name':'identifier', 'Tet4':[[n0,n1,n2,n3],...], 'Hex8':[[n0,...,n7],...],  },...]        #there may be several element sets
         self.massMatrix = np.zeros((0,0))    # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
         self.stiffnessMatrix=np.zeros((0,0)) # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
+        # self.massMatrixReduced = np.zeros((0,0))    # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
+        # self.stiffnessMatrixReduced=np.zeros((0,0)) # np.array([[r0,c0,value0],[r1,c1,value1], ... ])                                #currently only in SparseCSR format allowed!
         self.surface = []               # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
         self.nodeSets = []              # [{'Name':'identifier', 'NodeNumbers':[n_0,...,n_ns], 'NodeWeights':[w_0,...,w_ns]},...]     #for boundary conditions, etc.
         self.elementSets = []           # [{'Name':'identifier', 'ElementNumbers':[n_0,...,n_ns]},...]                                #for different volumes, etc.
 
         self.modeBasis = {}             # {'matrix':[[Psi_00,Psi_01, ..., Psi_0m],...,[Psi_n0,Psi_n1, ..., Psi_nm]],'type':'NormalModes'}
         self.eigenValues = []           # [ev0, ev1, ...]                                                                             #eigenvalues according to eigenvectors in mode basis
         self.postProcessingModes = {}   # {'matrix':<matrix containing stress components (xx,yy,zz,yz,xz,xy) in each column, rows are for every mesh node>,'outputVariableType':exudyn.OutputVariableType.StressLocal}
         #self.massMatrix = {}           # {'Shape':[rows,columns], 'SparseCSR':[[r0,c0,value0],[r1,c1,value1], ... ],  }             #currently only in SparseCSR format allowed!
 
         #some additional information, needed for checks and easier operation
         self.coordinatesPerNodeType = {'Position':3, 'Position2D':2, 'RigidBodyRxyz':6, 'RigidBodyEP':7} #number of coordinates for a certain node type
 
 
     #**classFunction: save all data (nodes, elements, ...) to a data filename; this function is much faster than the text-based import functions
-    #**input: use filename without ending ==> ".npy" will be added
-    def SaveToFile(self, fileName):
+    #**input: 
+    #  fileName: string for path and file name without ending ==> ".npy" will be added
+    #  fileVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; version must by > 0
+    #**output: stores file
+    def SaveToFile(self, fileName, fileVersion = 13 ):
         fileExtension = ''
         if len(fileName) < 4 or fileName[-4:]!='.npy':
             fileExtension = '.npy'
         with open(fileName+fileExtension, 'wb') as f:
-            np.save(f, self.nodes, allow_pickle=True)
+            if fileVersion>0:
+                dataVersion = np.array([int(fileVersion)])
+                np.save(f, dataVersion)
+
+            np.save(f, self.nodes, allow_pickle=True) #allow_pickle=True for lists or dictionaries
             np.save(f, self.elements, allow_pickle=True)
             np.save(f, self.massMatrix)
             np.save(f, self.stiffnessMatrix)
             np.save(f, self.surface, allow_pickle=True)
             np.save(f, self.nodeSets, allow_pickle=True)
             np.save(f, self.elementSets, allow_pickle=True)
             np.save(f, self.modeBasis, allow_pickle=True)
             np.save(f, self.eigenValues, allow_pickle=True)
             np.save(f, self.postProcessingModes, allow_pickle=True)
+            #not needed
+            # if fileVersion>0:
+            #     np.save(f, self.massMatrixReduced)
+            #     np.save(f, self.stiffnessMatrixReduced)
 
     #**classFunction: load all data (nodes, elements, ...) from a data filename previously stored with SaveToFile(...). 
     #this function is much faster than the text-based import functions
-    #**input: use filename without ending ==> ".npy" will be added
-    def LoadFromFile(self, fileName):
+    #**input: 
+    #  fileName: string for path and file name without ending ==> ".npy" will be added
+    #  forceVersion: FOR EXPERTS: this allows to store in older format, will be recovered when loading; must be integer; for old files, use forceVersion=0
+    #**output: loads data into fem (note that existing values are not overwritten!); returns file version or None if version is not available
+    def LoadFromFile(self, fileName, forceVersion=None):
         fileExtension = ''
+        fileVersion = None
         if len(fileName) < 4 or fileName[-4:]!='.npy':
             fileExtension = '.npy'
-        with open(fileName+fileExtension, 'rb') as f:
-            self.nodes = np.load(f, allow_pickle=True).all()
-            self.elements = list(np.load(f, allow_pickle=True))
-            self.massMatrix = np.load(f)
-            self.stiffnessMatrix = np.load(f)
-            self.surface = list(np.load(f, allow_pickle=True))
-            self.nodeSets =  list(np.load(f, allow_pickle=True))
-            self.elementSets = list(np.load(f, allow_pickle=True))
-            self.modeBasis = np.load(f, allow_pickle=True).all()
-            self.eigenValues = list(np.load(f, allow_pickle=True))
-            self.postProcessingModes = np.load(f, allow_pickle=True).all()
+            
+        try:
+            with open(fileName+fileExtension, 'rb') as f:
+                if forceVersion==None or forceVersion>0:
+                    versionData = np.load(f)
+                    #print('LoadFromFile:file version:', versionData)
+                    if forceVersion != None:
+                        fileVersion = int(versionData[0])
+                else:
+                    fileVersion=forceVersion
+                    
+                self.nodes = np.load(f, allow_pickle=True).all()   #allow_pickle=True for lists or dictionaries; .all() for dictionaries
+                self.elements = list(np.load(f, allow_pickle=True))#list(...) to convert into list again!
+                self.massMatrix = np.load(f)
+                self.stiffnessMatrix = np.load(f)
+                self.surface = list(np.load(f, allow_pickle=True))
+                self.nodeSets =  list(np.load(f, allow_pickle=True))
+                self.elementSets = list(np.load(f, allow_pickle=True))
+                self.modeBasis = np.load(f, allow_pickle=True).all()
+                self.eigenValues = list(np.load(f, allow_pickle=True))
+                self.postProcessingModes = np.load(f, allow_pickle=True).all()
+                # if fileVersion>0:
+                #     self.massMatrixReduced = np.load(f)
+                #     self.stiffnessMatrixReduced = np.load(f)
+        except Exception as e:
+            print('\n\nFEMinterface.LoadFromFile(...) failed; check filename; if your data file is using old format, try with: LoadFromFile(self, fileName=..., forceVersion=0)\n')
+            raise
+        return fileVersion
+
 
     #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     #ABAQUS import functions
 
-    #**classFunction: import nodes and elements from Abaqus input file and create surface elements
-    #node numbers in elements are converted from 1-based indices to python's 0-based indices
-    #only works for Hex8, Hex20, Tet4 and Tet10 (C3D4, C3D8, C3D10, C3D20) elements
-    #return node numbers as numpy array
-    def ImportFromAbaqusInputFile(self, fileName, typeName='Part', name='Part-1', verbose=False):
+    #**classFunction: import nodes and elements from Abaqus input file and create surface elements; 
+    #                 node numbers in elements are converted from 1-based indices to python's 0-based indices;
+    #                 This function can only import one part or instance; this means that you have to merge all 
+    #                 instances or parts in order to use this function for import of flexible bodies for order reduction methods
+    #**input:
+    #  fileName: file name incl. path
+    #  typeName: this is what is searched for regarding nodes and elements, see your .inp file
+    #  name: if there are several parts, this name should address the according part name
+    #  verbose: use True for some debug information
+    #  createSurfaceTrigs: if True, triangles are created for visualization (triangles both for Tet and Hex elements)
+    #  surfaceTrigsAll: if False, visualization triangles are created at the surface; if True, surface triangles are created also for interior elements
+    #**notes: only works for Hex8, Hex20, Tet4 and Tet10 (C3D4, C3D8, C3D8R, C3D10, C3D20, C3D20R) elements; some functionality is untested and works in limited cases; only works for one single part or instance
+    #**output: return node numbers as numpy array
+    def ImportFromAbaqusInputFile(self, fileName, typeName='Part', name='Part-1', verbose=False,
+                                  createSurfaceTrigs=True, surfaceTrigsAll=False):
         #def ImportABAQUS(fileName, typeName, name, verbose = False):
         fileLines = []
         if verbose: print("ImportFromAbaqusInputFile: read file name=", fileName)
         file=open(fileName,'r') 
         fileLines = file.readlines()
         file.close()
         
@@ -1565,16 +1717,23 @@
                 nodeReadFinished = True
 
         if verbose: print("imported ", len(nodes), "nodes")
     
         #+++++++++++++++++++++++++++++++++++++++++++++
         #read *Element keyword
         #expect something like: *Element, type= C3D20 
-        availableElementTypesNodes={'C3D20':20, 'C3D8':8}
-        elementTypeConversion={'C3D20':'Hex20', 'C3D8':'Hex8', 'C3D4':'Tet4', 'C3D10':'Tet10'}
+        availableElementTypesNodes={'C3D20':20, 'C3D20R':20, 'C3D8':8, 'C3D8R':8, #Hex
+                                    'C3D4':4, 'C3D10':10, #Tet standard
+                                    'C3D10H':10, 'C3D10MH':10, 'C3D10HS':10, #Tet advanced
+                                    }
+        elementTypeConversion={'C3D8':'Hex8', 'C3D20':'Hex20', 
+                               'C3D8R':'Hex8', 'C3D20R':'Hex20', #same nodes as C3D8 / C3D20, only reduced integration
+                               'C3D4':'Tet4', 'C3D10':'Tet10',
+                               'C3D10H':'Tet10', 'C3D10MH':'Tet10', 'C3D10HS':'Tet10',
+                               }
         elementSectionFound = False
         elementTypeName = ''
         while lineCnt < nLines and not elementSectionFound:
             line = fileLines[lineCnt]
             #print("now=", line)
             if line[0:len('*Element')] == '*Element':
                 elementSectionFound = True
@@ -1630,25 +1789,36 @@
 
         #FEMinterface:
         self.elements += [elementsDict]
         self.nodes['Position'] = np.array(nodes)
 
 
         #convert elements to triangles for drawing:
-        trigList = []
-        if 'Hex8' in elementsDict:
-            for element in elementsDict['Hex8']:
-                trigList += ConvertHexToTrigs(element) #node numbers are already 0-based
-        if 'Hex20' in elementsDict:
-            for element in elementsDict['Hex20']:
-                trigList += ConvertHexToTrigs(element) #node numbers are already 0-based
-
-        self.surface += [{'Name':'meshSurface', 'Trigs':trigList}]    # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
+        if createSurfaceTrigs:
+            if not surfaceTrigsAll:
+                self.VolumeToSurfaceElements(verbose) #create surface from imported elements
+            else:
+                if verbose:
+                    print('create surface triangles for all elements; may be large number of triangles for visualization ...')
+                trigList = []
+                if 'Hex8' in elementsDict:
+                    for element in elementsDict['Hex8']:
+                        trigList += ConvertHexToTrigs(element) #node numbers are already 0-based
+                if 'Hex20' in elementsDict:
+                    for element in elementsDict['Hex20']:
+                        trigList += ConvertHexToTrigs(element) #node numbers are already 0-based
+                if 'Tet4' in elementsDict:
+                    for element in elementsDict['Tet4']:
+                        trigList += ConvertTetToTrigs(element) #node numbers are already 0-based
+                if 'Tet10' in elementsDict:
+                    for element in elementsDict['Tet10']:
+                        trigList += ConvertTetToTrigs(element) #node numbers are already 0-based
+        
+                self.surface += [{'Name':'meshSurface', 'Trigs':trigList}]    # [{'Name':'identifier', 'Trigs':[[n0,n1,n2],...], 'Quads':[[n0,...,n3],...],  },...]           #surface with faces
 
-        #VolumeToSurfaceElements(verbose) #create surface from imported elements
 
         return np.array(nodes)
         
         #return [np.array(nodes), elementsDict]
```

## exudyn/rigidBodyUtilities.py

```diff
@@ -1012,15 +1012,28 @@
         elif axis==2:
             RigidBodyInertia.__init__(self, mass=m,
                                       inertiaTensor=np.diag([Jtt,Jtt,Jaxis]),
                                       com=np.zeros(3))
         else:
             raise ValueError("InertiaCylinder: axis must be 0, 1 or 2!")
         
-        
+
+#**function: convert string into exudyn.NodeType; call e.g. with 'NodeType.RotationEulerParameters' or 'RotationEulerParameters'
+#**notes: function is not very fast, so should be avoided in time-critical situations
+def StrNodeType2NodeType(sNodeType):
+    s = str(sNodeType) #if called with type
+    s = s.replace('NodeType.','')
+    nodeTypes = exu.NodeType.__members__
+    if s in nodeTypes:
+        return nodeTypes[s]
+    else:
+        raise ValueError('StrNodeType2NodeType: no valid NodeType: "'+s+'"')
+    # for key in nodeTypes:
+    #     if s == str(key) or s == str(nodeTypes[key]):
+    #         return int(nodeTypes[key])
     
 #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 #**function: get node item interface according to nodeType, using initialization with position, velocity, angularVelocity and rotationMatrix
 #**input:
 #   nodeType: a node type according to exudyn.NodeType, or a string of it, e.g., 'NodeType.RotationEulerParameters' (fastest, but additional algebraic constraint equation), 'NodeType.RotationRxyz' (Tait-Bryan angles, singularity for second angle at +/- 90 degrees), 'NodeType.RotationRotationVector' (used for Lie group integration)
 #   position: reference position as list or numpy array with 3 components (in global/world frame)
 #   velocity: initial translational velocity as list or numpy array with 3 components (in global/world frame)
```

## Comparing `exudyn-1.6.57.dev1.dist-info/METADATA` & `exudyn-1.6.65.dev1.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: exudyn
-Version: 1.6.57.dev1
+Version: 1.6.65.dev1
 Summary: EXUDYN flexible multibody dynamics simulation in C++ and Python
 Home-page: https://github.com/jgerstmayr/EXUDYN
 Author: Johannes Gerstmayr
 Author-email: reply.exudyn@gmail.com
 License: BSD
 Platform: any
 Classifier: Development Status :: 4 - Beta
```

## Comparing `exudyn-1.6.57.dev1.dist-info/RECORD` & `exudyn-1.6.65.dev1.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-exudyn/FEM.py,sha256=ehbhGU9lvu9BeY0zMiyI7oc-_oyj1vp07jhYt0K8CEw,203014
+exudyn/FEM.py,sha256=Rpxz0qtl6Dq03__5AWgjyiL6VFu5Lf3xImCoHVVtxks,212931
 exudyn/GUI.py,sha256=oBceXvJB9TTjyNMPieZnf9ICe6xunAVhcg2A06S72rI,42942
 exudyn/__init__.py,sha256=Vjdo4IwlQvcFeApZVT1eCyl81vH97RZxvjRjfQfZZds,6474
 exudyn/advancedUtilities.py,sha256=L6rPWNGiXodPKGftQLkBOtn8ZwD1dVb1WZQDqGCyLfY,16183
 exudyn/artificialIntelligence.py,sha256=s1TbljwSBtSNWk45m5__Nb3SZ2qC5yNH3_PgcftlSSs,15264
 exudyn/basicUtilities.py,sha256=zG5iN5W3IEc3fH1koAJ84nnKZyHcKWK1UbHTrL1_zcU,11393
 exudyn/beams.py,sha256=6onNzmq1ZP2Bn8-tCHzaetuOV9NtIW7WoVcXNRJuTLw,35948
 exudyn/demos.py,sha256=3sAMnfaAAHPk1i3TSmNLWkMCQ0J7v9h7olQsw5qP_uw,7288
-exudyn/exudynCPP.cp39-win_amd64.pyd,sha256=VMG2esMQIM_EkJCq3Jd-PQIwZHidVty8SuRZ3gnrc5o,5756416
+exudyn/exudynCPP.cp39-win_amd64.pyd,sha256=bOPLx0umkiJfWeFVXtDfV9kU0VBHK5DIQJXaFn7mDII,5756416
 exudyn/graphicsDataUtilities.py,sha256=pgxtbOP_Gt7_JMibYpBZquGfvv9i6xScsIt8Fq_5lio,85436
 exudyn/interactive.py,sha256=A-bFzHVV4ScLfoZvfwUuf_7GDXZ7OI6DB8JtO3LQMME,53048
 exudyn/itemInterface.py,sha256=6JU3CwKuvdhbw6kyEF0WpJ2xooFU5palJBD-0z9sUBI,158659
 exudyn/kinematicTree.py,sha256=ltAKaZeW_7KZTdhq2Zh4SxpZw2mMf-OQIniNdi5iVqw,32746
 exudyn/lieGroupBasics.py,sha256=XpkhHFRrHgkwtNoEvtPXN-52Mpu4AbJzH8u-sQpGk2s,21846
 exudyn/lieGroupIntegration.py,sha256=svUYTow5b2JRWQ7EOZsSk8pkItqzGDyyKz0RZFU9Byg,13557
 exudyn/machines.py,sha256=YJ-Wepm3bXgPZuyVSc5_TB414IaUF9bZcSrp41sy5gc,3165
 exudyn/physics.py,sha256=uQp30quLIxQiraHpaqLX-RJi4xc964FqDk8df8czNhU,6169
 exudyn/plot.py,sha256=TkNGmmx75_QHql4eSb7XXnUVG1tVoYhKIMRkWM-H84w,50407
 exudyn/processing.py,sha256=Oq_9fNK4l5dqtp6Nar5X4lfDgQhJlKCTWvTA_EV5LnE,71531
 exudyn/resultsMonitor.py,sha256=i1wZdH7M279jN9z1U0FFZAzVlr9gX1VO7d_vfcSmrTg,14646
-exudyn/rigidBodyUtilities.py,sha256=6JuoLiCQbcNE2jLeqCT9BMG0P4v-9HoiNtHtLUBeG3o,65543
+exudyn/rigidBodyUtilities.py,sha256=QyeTVLvkAl_dLqte_AePujtfl0GtteSqbCK5fSwPoj8,66182
 exudyn/signalProcessing.py,sha256=3QZAnQT9BMLts5hVlJMKhkvbA4SDB9KJ1sK-IqAhYLI,15158
 exudyn/solver.py,sha256=ZoU8FPU9B1TKnyX1RnXHzOqkjECCKAzHQkCtCrH7Om0,27593
 exudyn/utilities.py,sha256=1fRIDk8x8h9J6kQ-xjw5lOqyTxHyexx2bsu25NWzDuI,66527
 exudyn/robotics/__init__.py,sha256=Pzu7pcW4qLUaw3nY2sPTkav4N2PrDgNFmB_1gzeNwLs,898
 exudyn/robotics/future.py,sha256=T9Tc_5zzo_LrFI2QZZBK2fBmxjVOKtR3IdUyH2El0mo,24507
 exudyn/robotics/mobile.py,sha256=npw-Qr4cXeNLKjvmkVf0JJFActlimPa1mlC-6s7SSGQ,527
 exudyn/robotics/models.py,sha256=23uffRQWvGSAnH5Vx9BUcRTMj9fkMRSkxDI1Wrkb97E,32539
 exudyn/robotics/motion.py,sha256=ccBje_jiBoulEPp7cxekOmR9BnaIxH_-LoTkMTUNQls,26097
 exudyn/robotics/roboticsCore.py,sha256=zbk3VJ5SMUs015UpvGY7X_XM7N-8z29XLAJQBN6eQE0,97871
 exudyn/robotics/special.py,sha256=FSGl9VeXLDfgFNHhGh0Wm8pCbRgTVffWq2b2O4042hc,15166
 exudyn/robotics/utilities.py,sha256=7Kp_Ce-b2O3RvQGHtDw50uN3iFew19p_9RLGzsOODa8,5171
-exudyn-1.6.57.dev1.dist-info/METADATA,sha256=u2lAOxuujXzIJGaBk7Lzy961oYAbAUW55sfmHfroC7U,1653
-exudyn-1.6.57.dev1.dist-info/WHEEL,sha256=fVcVlLzi8CGi_Ul8vjMdn8gER25dn5GBg9E6k9z41-Y,100
-exudyn-1.6.57.dev1.dist-info/top_level.txt,sha256=w4EYVbsh-zIfLBaDyrwYdU7hMcmaIS3OhFvBmSgkFO4,7
-exudyn-1.6.57.dev1.dist-info/RECORD,,
+exudyn-1.6.65.dev1.dist-info/METADATA,sha256=jGWGG2SxzLTv3zE5QEhunl3YvO-GxzFQLdrpNVD4YTA,1653
+exudyn-1.6.65.dev1.dist-info/WHEEL,sha256=fVcVlLzi8CGi_Ul8vjMdn8gER25dn5GBg9E6k9z41-Y,100
+exudyn-1.6.65.dev1.dist-info/top_level.txt,sha256=w4EYVbsh-zIfLBaDyrwYdU7hMcmaIS3OhFvBmSgkFO4,7
+exudyn-1.6.65.dev1.dist-info/RECORD,,
```

