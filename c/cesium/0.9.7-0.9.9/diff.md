# Comparing `tmp/cesium-0.9.7.tar.gz` & `tmp/cesium-0.9.9.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/cesium-0.9.7.tar", last modified: Mon Oct 15 17:09:10 2018, max compression
+gzip compressed data, was "dist\cesium-0.9.9.tar", last modified: Tue Dec 11 21:58:58 2018, max compression
```

## Comparing `cesium-0.9.7.tar` & `cesium-0.9.9.tar`

### file list

```diff
@@ -1,90 +1,90 @@
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/
--rw-rw-r--   0 arien     (1000) arien     (1000)       38 2018-10-15 17:09:10.000000 cesium-0.9.7/setup.cfg
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium/
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium/features/
--rw-rw-r--   0 arien     (1000) arien     (1000)      512 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/scatter_res_raw.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     1362 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/stetson.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    10148 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/qso_model.py
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium/features/tests/
--rw-rw-r--   0 arien     (1000) arien     (1000)        0 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/tests/__init__.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     2488 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/tests/test_cadence_features.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     1685 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/tests/util.py
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium/features/tests/data/
--rwxrwxr-x   0 arien     (1000) arien     (1000)    11101 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/tests/data/247327.dat
--rwxrwxr-x   0 arien     (1000) arien     (1000)    11578 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/tests/data/245486.dat
--rw-rw-r--   0 arien     (1000) arien     (1000)     3876 2018-02-22 00:44:50.000000 cesium-0.9.7/cesium/features/tests/data/expected_features.csv
--rwxrwxr-x   0 arien     (1000) arien     (1000)    11243 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/tests/data/257141.dat
--rw-rw-r--   0 arien     (1000) arien     (1000)    10104 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/tests/test_lomb_scargle_features.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     1736 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/tests/test_graphs.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    10922 2018-02-22 00:44:50.000000 cesium-0.9.7/cesium/features/tests/test_general_features.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     1435 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/_lomb_scargle.pyx
--rw-rw-r--   0 arien     (1000) arien     (1000)     5323 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/period_folding.py
--rw-rw-r--   0 arien     (1000) arien     (1000)      188 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/__init__.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    21972 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/graphs.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     1974 2018-02-22 00:44:50.000000 cesium-0.9.7/cesium/features/common_functions.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     3420 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/cadence_features.py
--rw-rw-r--   0 arien     (1000) arien     (1000)      742 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/_lomb_scargle.pxd
--rw-rw-r--   0 arien     (1000) arien     (1000)     5405 2018-05-01 21:34:30.000000 cesium-0.9.7/cesium/features/_eigs.h
--rw-rw-r--   0 arien     (1000) arien     (1000)      616 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/setup.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     9435 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/_lomb_scargle.h
--rw-rw-r--   0 arien     (1000) arien     (1000)     2063 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/periodic_model.py
--rw-rw-r--   0 arien     (1000) arien     (1000)   919064 2018-01-30 21:48:12.000000 cesium-0.9.7/cesium/features/_lomb_scargle.c
--rw-rw-r--   0 arien     (1000) arien     (1000)     2176 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/amplitude.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     1317 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/num_alias.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    11512 2018-05-01 21:34:02.000000 cesium-0.9.7/cesium/features/lomb_scargle.py
--rw-rw-r--   0 arien     (1000) arien     (1000)      644 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/features/lomb_scargle_fast.py
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium/datasets/
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium/datasets/tests/
--rw-rw-r--   0 arien     (1000) arien     (1000)     3433 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/datasets/tests/test_datasets.py
--rw-rw-r--   0 arien     (1000) arien     (1000)      140 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/datasets/__init__.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     4299 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/datasets/util.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     4140 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/datasets/andrzejak.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     4335 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/datasets/asas_training.py
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium/tests/
--rw-rw-r--   0 arien     (1000) arien     (1000)      954 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/test_util.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     7216 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/test_time_series.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     1766 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/fixtures.py
--rw-rw-r--   0 arien     (1000) arien     (1000)        0 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/__init__.py
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium/tests/data/
--rwxrwxr-x   0 arien     (1000) arien     (1000)    11101 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/data/247327.dat
--rw-rw-r--   0 arien     (1000) arien     (1000)    35415 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/data/asas_training_subset.tar.gz
--rwxrwxr-x   0 arien     (1000) arien     (1000)     3954 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/data/dotastro_215153.dat
--rw-rw-r--   0 arien     (1000) arien     (1000)    16787 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/data/215153_215176_218272_218934.tar.gz
--rw-rw-r--   0 arien     (1000) arien     (1000)      213 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/data/215153_215176_218272_218934_metadata.dat
--rw-rw-r--   0 arien     (1000) arien     (1000)      469 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/data/asas_training_subset_classes_with_metadata.dat
--rw-rw-r--   0 arien     (1000) arien     (1000)      440 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/data/test_features_with_targets.csv
--rw-rw-r--   0 arien     (1000) arien     (1000)     3196 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/tests/test_data_management.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    12579 2018-02-22 00:44:50.000000 cesium-0.9.7/cesium/tests/test_featurize.py
--rw-rw-r--   0 arien     (1000) arien     (1000)      147 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/__init__.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     3165 2018-10-15 17:01:26.000000 cesium-0.9.7/cesium/util.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     6183 2018-10-15 17:01:26.000000 cesium-0.9.7/cesium/data_management.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    12133 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/time_series.py
--rw-rw-r--   0 arien     (1000) arien     (1000)      489 2018-01-26 19:09:18.000000 cesium-0.9.7/cesium/setup.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    20334 2018-05-01 21:34:30.000000 cesium-0.9.7/cesium/featurize.py
--rw-rw-r--   0 arien     (1000) arien     (1000)       18 2018-10-15 17:04:35.000000 cesium-0.9.7/cesium/version.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     1210 2018-10-15 17:09:10.000000 cesium-0.9.7/PKG-INFO
--rw-rw-r--   0 arien     (1000) arien     (1000)     1717 2018-10-15 17:01:26.000000 cesium-0.9.7/README.md
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/dockerfiles/
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/dockerfiles/base/
--rw-rw-r--   0 arien     (1000) arien     (1000)      675 2018-01-26 19:09:18.000000 cesium-0.9.7/dockerfiles/base/Dockerfile
--rwxrwxr-x   0 arien     (1000) arien     (1000)       93 2018-01-26 19:09:18.000000 cesium-0.9.7/dockerfiles/base/rabbitmq.sh
--rw-rw-r--   0 arien     (1000) arien     (1000)      550 2018-01-26 19:09:18.000000 cesium-0.9.7/MANIFEST.in
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/doc/
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/doc/tools/
--rw-rw-r--   0 arien     (1000) arien     (1000)     1425 2018-01-26 19:09:18.000000 cesium-0.9.7/doc/tools/feature_table.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    12623 2018-01-26 19:09:18.000000 cesium-0.9.7/doc/tools/apigen.py
--rw-rw-r--   0 arien     (1000) arien     (1000)    10754 2018-01-26 19:09:18.000000 cesium-0.9.7/doc/conf.py
--rw-rw-r--   0 arien     (1000) arien     (1000)     7503 2018-01-26 19:09:18.000000 cesium-0.9.7/doc/Makefile
--rw-rw-r--   0 arien     (1000) arien     (1000)     4254 2018-05-08 18:08:39.000000 cesium-0.9.7/setup.py
--rw-rw-r--   0 arien     (1000) arien     (1000)      171 2018-01-26 19:09:18.000000 cesium-0.9.7/requirements.docs.txt
--rw-rw-r--   0 arien     (1000) arien     (1000)     1533 2018-01-26 19:09:18.000000 cesium-0.9.7/LICENSE.txt
--rw-rw-r--   0 arien     (1000) arien     (1000)      648 2018-01-26 19:09:18.000000 cesium-0.9.7/RELEASE.txt
-drwxrwxr-x   0 arien     (1000) arien     (1000)        0 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium.egg-info/
--rw-rw-r--   0 arien     (1000) arien     (1000)        1 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium.egg-info/dependency_links.txt
--rw-rw-r--   0 arien     (1000) arien     (1000)     1210 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium.egg-info/PKG-INFO
--rw-rw-r--   0 arien     (1000) arien     (1000)        7 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium.egg-info/top_level.txt
--rw-rw-r--   0 arien     (1000) arien     (1000)     2217 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium.egg-info/SOURCES.txt
--rw-rw-r--   0 arien     (1000) arien     (1000)       95 2018-10-15 17:09:10.000000 cesium-0.9.7/cesium.egg-info/requires.txt
--rw-rw-r--   0 arien     (1000) arien     (1000)        1 2018-01-30 22:50:34.000000 cesium-0.9.7/cesium.egg-info/not-zip-safe
--rw-rw-r--   0 arien     (1000) arien     (1000)      423 2018-01-26 19:09:18.000000 cesium-0.9.7/Makefile
--rw-rw-r--   0 arien     (1000) arien     (1000)      109 2018-01-26 19:09:18.000000 cesium-0.9.7/requirements.txt
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/
+-rw-rw-rw-   0        0        0     1564 2018-12-04 06:35:41.000000 cesium-0.9.9/LICENSE.txt
+-rw-rw-rw-   0        0        0      566 2018-12-04 06:35:41.000000 cesium-0.9.9/MANIFEST.in
+-rw-rw-rw-   0        0        0      448 2018-12-04 06:35:41.000000 cesium-0.9.9/Makefile
+-rw-rw-rw-   0        0        0     1219 2018-12-11 21:58:58.000000 cesium-0.9.9/PKG-INFO
+-rw-rw-rw-   0        0        0     1745 2018-12-04 06:35:41.000000 cesium-0.9.9/README.md
+-rw-rw-rw-   0        0        0      674 2018-12-04 06:36:38.000000 cesium-0.9.9/RELEASE.txt
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium/
+-rw-rw-rw-   0        0        0      153 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/__init__.py
+-rw-rw-rw-   0        0        0     6345 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/data_management.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium/datasets/
+-rw-rw-rw-   0        0        0      144 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/datasets/__init__.py
+-rw-rw-rw-   0        0        0     4262 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/datasets/andrzejak.py
+-rw-rw-rw-   0        0        0     4455 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/datasets/asas_training.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium/datasets/tests/
+-rw-rw-rw-   0        0        0     3534 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/datasets/tests/test_datasets.py
+-rw-rw-rw-   0        0        0     4437 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/datasets/util.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/cesium/features/
+-rw-rw-rw-   0        0        0      191 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/__init__.py
+-rw-rw-rw-   0        0        0     5543 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/_eigs.h
+-rw-rw-rw-   0        0        0   937363 2018-12-11 21:06:40.000000 cesium-0.9.9/cesium/features/_lomb_scargle.c
+-rw-rw-rw-   0        0        0     9661 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/_lomb_scargle.h
+-rw-rw-rw-   0        0        0      754 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/_lomb_scargle.pxd
+-rw-rw-rw-   0        0        0     1464 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/_lomb_scargle.pyx
+-rw-rw-rw-   0        0        0     2227 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/amplitude.py
+-rw-rw-rw-   0        0        0     3507 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/cadence_features.py
+-rw-rw-rw-   0        0        0     2047 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/common_functions.py
+-rw-rw-rw-   0        0        0    22388 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/graphs.py
+-rw-rw-rw-   0        0        0    11872 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/lomb_scargle.py
+-rw-rw-rw-   0        0        0      663 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/lomb_scargle_fast.py
+-rw-rw-rw-   0        0        0     1355 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/num_alias.py
+-rw-rw-rw-   0        0        0     5460 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/period_folding.py
+-rw-rw-rw-   0        0        0     2120 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/periodic_model.py
+-rw-rw-rw-   0        0        0    10426 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/qso_model.py
+-rw-rw-rw-   0        0        0      526 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/scatter_res_raw.py
+-rw-rw-rw-   0        0        0      637 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/setup.py
+-rw-rw-rw-   0        0        0     1407 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/stetson.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/cesium/features/tests/
+-rw-rw-rw-   0        0        0        0 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/__init__.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/cesium/features/tests/data/
+-rw-rw-rw-   0        0        0    12078 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/data/245486.dat
+-rw-rw-rw-   0        0        0    11583 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/data/247327.dat
+-rw-rw-rw-   0        0        0    11718 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/data/257141.dat
+-rw-rw-rw-   0        0        0     3880 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/data/expected_features.csv
+-rw-rw-rw-   0        0        0     2554 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/test_cadence_features.py
+-rw-rw-rw-   0        0        0    11188 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/test_general_features.py
+-rw-rw-rw-   0        0        0     1782 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/test_graphs.py
+-rw-rw-rw-   0        0        0    10335 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/test_lomb_scargle_features.py
+-rw-rw-rw-   0        0        0     1733 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/features/tests/util.py
+-rw-rw-rw-   0        0        0    20798 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/featurize.py
+-rw-rw-rw-   0        0        0      505 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/setup.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/cesium/tests/
+-rw-rw-rw-   0        0        0        0 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/__init__.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/cesium/tests/data/
+-rw-rw-rw-   0        0        0    16787 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/data/215153_215176_218272_218934.tar.gz
+-rw-rw-rw-   0        0        0      218 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/data/215153_215176_218272_218934_metadata.dat
+-rw-rw-rw-   0        0        0    11583 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/data/247327.dat
+-rw-rw-rw-   0        0        0    35415 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/data/asas_training_subset.tar.gz
+-rw-rw-rw-   0        0        0      477 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/data/asas_training_subset_classes_with_metadata.dat
+-rw-rw-rw-   0        0        0     4124 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/data/dotastro_215153.dat
+-rw-rw-rw-   0        0        0      447 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/data/test_features_with_targets.csv
+-rw-rw-rw-   0        0        0     1822 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/fixtures.py
+-rw-rw-rw-   0        0        0     3284 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/test_data_management.py
+-rw-rw-rw-   0        0        0    12862 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/test_featurize.py
+-rw-rw-rw-   0        0        0     7411 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/test_time_series.py
+-rw-rw-rw-   0        0        0      985 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/tests/test_util.py
+-rw-rw-rw-   0        0        0    12432 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/time_series.py
+-rw-rw-rw-   0        0        0     3276 2018-12-04 06:35:41.000000 cesium-0.9.9/cesium/util.py
+-rw-rw-rw-   0        0        0       19 2018-12-04 06:36:38.000000 cesium-0.9.9/cesium/version.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium.egg-info/
+-rw-rw-rw-   0        0        0     1219 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     2217 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0        2 2018-12-03 23:52:34.000000 cesium-0.9.9/cesium.egg-info/not-zip-safe
+-rw-rw-rw-   0        0        0       94 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        7 2018-12-11 21:58:57.000000 cesium-0.9.9/cesium.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/doc/
+-rw-rw-rw-   0        0        0     7699 2018-12-04 06:35:41.000000 cesium-0.9.9/doc/Makefile
+-rw-rw-rw-   0        0        0    11090 2018-12-04 06:35:41.000000 cesium-0.9.9/doc/conf.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/doc/tools/
+-rw-rw-rw-   0        0        0    12990 2018-12-04 06:35:41.000000 cesium-0.9.9/doc/tools/apigen.py
+-rw-rw-rw-   0        0        0     1461 2018-12-04 06:35:41.000000 cesium-0.9.9/doc/tools/feature_table.py
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:57.000000 cesium-0.9.9/dockerfiles/
+drwxrwxrwx   0        0        0        0 2018-12-11 21:58:58.000000 cesium-0.9.9/dockerfiles/base/
+-rw-rw-rw-   0        0        0      698 2018-12-04 06:35:41.000000 cesium-0.9.9/dockerfiles/base/Dockerfile
+-rw-rw-rw-   0        0        0       95 2018-12-04 06:35:41.000000 cesium-0.9.9/dockerfiles/base/rabbitmq.sh
+-rw-rw-rw-   0        0        0      185 2018-12-04 06:35:41.000000 cesium-0.9.9/requirements.docs.txt
+-rw-rw-rw-   0        0        0      116 2018-12-04 06:35:41.000000 cesium-0.9.9/requirements.txt
+-rw-rw-rw-   0        0        0       42 2018-12-11 21:58:58.000000 cesium-0.9.9/setup.cfg
+-rw-rw-rw-   0        0        0     4440 2018-12-07 00:24:38.000000 cesium-0.9.9/setup.py
```

### Comparing `cesium-0.9.7/cesium/features/scatter_res_raw.py` & `cesium-0.9.9/cesium/features/scatter_res_raw.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,14 +1,14 @@
-from . import common_functions as cf
-
-
-def scatter_res_raw(t, m, e, lomb_model):
-    """ From arXiv 1101_2406v1 Dubath 20110112 paper.
-
-    Scatter: res/raw
-    Median absolute deviation (MAD) of the residuals (obtained by subtracting
-    model values from the raw light curve) divided by the MAD of the raw
-    light-curve values around the median.
-    """
-    lomb_resid = lomb_model['freq_fits'][-1]['resid']
-    return (cf.median_absolute_deviation(lomb_resid) /
-            cf.median_absolute_deviation(m))
+from . import common_functions as cf
+
+
+def scatter_res_raw(t, m, e, lomb_model):
+    """ From arXiv 1101_2406v1 Dubath 20110112 paper.
+
+    Scatter: res/raw
+    Median absolute deviation (MAD) of the residuals (obtained by subtracting
+    model values from the raw light curve) divided by the MAD of the raw
+    light-curve values around the median.
+    """
+    lomb_resid = lomb_model['freq_fits'][-1]['resid']
+    return (cf.median_absolute_deviation(lomb_resid) /
+            cf.median_absolute_deviation(m))
```

### Comparing `cesium-0.9.7/cesium/features/stetson.py` & `cesium-0.9.9/cesium/features/stetson.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-import numpy as np
-
-
-def stetson_mean(x, weight=100., alpha=2., beta=2., tol=1.e-6, nmax=20):
-    """An iteratively weighted mean used in the Stetson variability index"""
-    mu = np.median(x)
-    for i in range(nmax):
-        resid = x - mu
-        resid_err = np.abs(resid) * np.sqrt(weight)
-        weight1 = weight / (1. + (resid_err / alpha)**beta)
-        weight1 /= weight1.mean()
-        diff = np.mean(x * weight1) - mu
-        mu += diff
-        if (np.abs(diff) < tol*np.abs(mu) or np.abs(diff) < tol):
-            break
-
-    return mu
-
-
-def stetson_j(x, y=[], dx=0.1, dy=0.1):
-    """
-    Robust covariance statistic between pairs of observations x,y
-    whose uncertainties are dx,dy. If y is not given, calculates a robust
-    variance for x.
-    """
-    n = len(x)
-    x0 = stetson_mean(x, 1./dx**2)
-    delta_x = np.sqrt(n / (n - 1.)) * (x - x0) / dx
-
-    if (len(y) > 0):
-        y0 = stetson_mean(y, 1./dy**2)
-        delta_y = np.sqrt(n / (n - 1.)) * (y - y0) / dy
-        p_k = delta_x * delta_y
-    else:
-        p_k = delta_x**2 - 1.
-
-    return np.mean(np.sign(p_k) * np.sqrt(np.abs(p_k)))
-
-
-def stetson_k(x, dx=0.1):
-    """A robust kurtosis statistic."""
-    n = len(x)
-    x0 = stetson_mean(x, 1./dx**2)
-    delta_x = np.sqrt(n / (n - 1.)) * (x - x0) / dx
-    return 1. / 0.798 * np.mean(np.abs(delta_x)) / np.sqrt(np.mean(delta_x**2))
+import numpy as np
+
+
+def stetson_mean(x, weight=100., alpha=2., beta=2., tol=1.e-6, nmax=20):
+    """An iteratively weighted mean used in the Stetson variability index"""
+    mu = np.median(x)
+    for i in range(nmax):
+        resid = x - mu
+        resid_err = np.abs(resid) * np.sqrt(weight)
+        weight1 = weight / (1. + (resid_err / alpha)**beta)
+        weight1 /= weight1.mean()
+        diff = np.mean(x * weight1) - mu
+        mu += diff
+        if (np.abs(diff) < tol*np.abs(mu) or np.abs(diff) < tol):
+            break
+
+    return mu
+
+
+def stetson_j(x, y=[], dx=0.1, dy=0.1):
+    """
+    Robust covariance statistic between pairs of observations x,y
+    whose uncertainties are dx,dy. If y is not given, calculates a robust
+    variance for x.
+    """
+    n = len(x)
+    x0 = stetson_mean(x, 1./dx**2)
+    delta_x = np.sqrt(n / (n - 1.)) * (x - x0) / dx
+
+    if (len(y) > 0):
+        y0 = stetson_mean(y, 1./dy**2)
+        delta_y = np.sqrt(n / (n - 1.)) * (y - y0) / dy
+        p_k = delta_x * delta_y
+    else:
+        p_k = delta_x**2 - 1.
+
+    return np.mean(np.sign(p_k) * np.sqrt(np.abs(p_k)))
+
+
+def stetson_k(x, dx=0.1):
+    """A robust kurtosis statistic."""
+    n = len(x)
+    x0 = stetson_mean(x, 1./dx**2)
+    delta_x = np.sqrt(n / (n - 1.)) * (x - x0) / dx
+    return 1. / 0.798 * np.mean(np.abs(delta_x)) / np.sqrt(np.mean(delta_x**2))
```

### Comparing `cesium-0.9.7/cesium/features/qso_model.py` & `cesium-0.9.9/cesium/features/qso_model.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,278 +1,278 @@
-import numpy as np
-from scipy.stats import norm
-from scipy.linalg import solveh_banded, cholesky_banded
-from scipy.special import gammaln, betainc, gammaincc
-
-
-# TODO duplicate
-def lprob2sigma(lprob):
-    """Translates a log_e(probability) to units of Gaussian sigmas."""
-    if lprob>-36.:
-      sigma = norm.ppf(1.-0.5*np.exp(1.*lprob))
-    else:
-      sigma = np.sqrt( np.log(2./np.pi) - 2.*np.log(8.2) - 2.*lprob )
-    return float(sigma)
-
-
-def chol_inverse_diag(t):
-    """Computes inverse of matrix given its Cholesky upper Triangular decomposition t.
-    matrix form: ab[u + i - j, j] == a[i,j] (here u=1)
-    (quick version: only calculates diagonal and neighboring elements)
-    """
-    (uu,nrows) = t.shape
-    B = np.zeros((uu,nrows),dtype='float64')
-    B[1,nrows-1] = 1.0/t[1,nrows-1]**2
-    B[0,nrows-1] = -t[0,nrows-1]*B[1,nrows-1]/t[1,nrows-2]
-    for j in reversed(range(nrows-1)):
-      tjj = t[1,j]
-      B[1,j] = (1.0/tjj-t[0,j+1]*B[0,j+1])/tjj
-      B[0,j] = -t[0,j]*B[1,j]/t[1,j-1]
-    return B
-
-
-def qso_engine(time,data,error,ltau=3.,lvar=-1.7,sys_err=0.,return_model=False):
-    """Calculates the fit quality of a damped random walk to a qso lightcurve.
-    The formalism is from Rybicki & Press (1994; arXiv:comp-gas/9405004)
-
-    Data are modelled with a covariance function
-        Lij = 0.5*var*tau*exp(-|time_i-time_j|/tau) .
-
-    Input:
-        time - measurement times, typically days
-        data - measured magnitudes
-        error - uncertainty in measured magnitudes
-
-    Output (dictionary):
-
-        chi2/nu - classical variability measure
-        chi2_qso/nu - for goodness of fit given fixed parameters
-        chi2_qso/nu_extra - for parameter fitting, add to chi2/nu
-        chi^2/nu_NULL - expected chi2/nu for non-qso variable
-
-        signif_qso - significance chi^2/nu<chi^2/nu_NULL (rule out false alarm)
-        signif_not_qso - significance chi^2/nu>1 (rule out qso)
-        signif_vary - significance that source is variable
-        class - resulting source type (ambiguous, not_qso, qso)
-
-        model - time series prediction for each datum given all others (iff return_model==True)
-        dmodel - model uncertainty, including uncertainty in data
-
-    Notes:
-        T = L^(-1)
-        Data variance is D
-        Full covariance C^(-1) = (L+D)^(-1) = T [T+D^(-1)]^(-1) D^(-1)
-        Code takes advantage of the tridiagonality of T and T+D^(-1).
-    """
-
-    out_dict = {}
-    out_dict['chi2_qso/nu']=999; out_dict['chi2_qso/nu_extra']=0.;
-    out_dict['signif_qso']=0.; out_dict['signif_not_qso']=0.;  out_dict['signif_vary']=0.
-    out_dict['chi2_qso/nu_NULL']=0.; out_dict['chi2/nu']=0.; out_dict['nu']=0
-    out_dict['model']=[]; out_dict['dmodel']=[];
-    out_dict['class']='ambiguous'
-
-    lvar0 = np.log10(0.5) + lvar + ltau
-
-    ln = len(data)
-    dt = abs(time[1:]-time[:-1])
-
-    # first make sure all dt>0
-    g = np.where(dt>0.)[0]; lg = len(g)
-    # must have at least 2 data points
-    if lg <= 0:
-        return out_dict
-
-    if return_model:
-        model = 1.*data; dmodel = -1.*error
-
-    if lg < ln:
-      dt = dt[g]
-      gg = np.zeros(lg+1,dtype='int64'); gg[1:] = g+1
-      dat = data[gg]; wt = 1./(sys_err**2+error[gg]**2)
-      ln = lg+1
-    else:
-      dat = 1.*data
-      wt = 1./(sys_err**2+error**2)
-
-    out_dict['nu'] = ln-1.
-    varx = np.var(dat)
-    dat0 = (dat * wt).sum() / wt.sum()
-    out_dict['chi2/nu'] = ((dat - dat0)**2 * wt).sum() / out_dict['nu']
-
-    # define tridiagonal matrix T = L^(-1)
-    # sparse matrix form: ab[u + i - j, j] == a[i,j]   i<=j, (here u=1)
-    T = np.zeros((2,ln),dtype='float64')
-    arg = dt*np.exp(-np.log(10)*ltau); ri = np.exp(-arg); ei = 1./(1./ri-ri)
-    T[0,1:] = -ei; T[1,:-1] = 1.+ri*ei; T[1,1:] += ri*ei; T[1,ln-1] += 1.
-    T0 = np.median(T[1,:]); T /= T0
-
-    # equation for chi2_qso is [ (dat-x0) T Tp^(-1) D^(-1) (dat-x0) ]  , where Tp=T+D^(-1) and D^(-1)=wt
-    fac = np.exp(np.log(10)*lvar0)/T0
-    Tp = 1.*T
-    Tp[1,:] += wt*fac
-    # solve Tp*z=y for z (y=wt*dat)
-    # This works for scipy __version__>='0.9.0' on anathem (20120809)
-    b1 = (wt*dat).reshape((1,ln))
-    b2 = b1.T
-    #(Tpc,z) = solveh_banded(Tp,b2)
-    z = solveh_banded(Tp,b2)
-    Tpc = cholesky_banded(Tp) # the solveh_banded() function used to return the cholesky matrix, now we get seperately
-    z = z.T
-    z = z[0,:]
-    c1 = wt.reshape((1,ln))
-    c2 = c1.T
-    #(Tpc,z0) = solveh_banded(Tp,c2)
-    z0 = solveh_banded(Tp,c2)
-    #HAS NOT CHANGED#Tpc2 = cholesky_banded(Tp)
-    z0 = z0.T
-    z0 = z0[0,:]
-
-
-    #finally, get u=T*z
-    u = T[1,:]*z; u[1:] += T[0,1:]*z[:-1]; u[:-1] += T[0,1:]*z[1:]
-    u0 = T[1,:]*z0; u0[1:] += T[0,1:]*z0[:-1]; u0[:-1] += T[0,1:]*z0[1:]
-
-    # magnitude offset x0, error = 1./sqrt(u0sum)
-    u0sum = u0.sum(); x0 = u.sum()/u0sum;
-
-    # fit statistic
-    out_dict['chi2_qso/nu'] = np.dot(dat-x0,u-u0*x0)/out_dict['nu']
-
-    # -2*log(likelihood) = chi2_qso + ldet_C + log(u0sum)
-    #   first term: use chi2_qso/nu for goodness of fit with fixed parameters;
-    #   all terms: use chi2_qso/nu + chi2_qso/nu_extra for fitting with variable parameters
-    # get log of determinant for use later
-    Tc = cholesky_banded(T)
-    ldet_Tp = 2*np.log(Tpc[1,:]).sum()
-    ldet_T = 2*np.log(Tc[1,:]).sum()
-    ldet_C = ldet_Tp-ldet_T-np.log(wt).sum()
-    out_dict['chi2_qso/nu_extra'] = (ldet_C + np.log(u0sum))/out_dict['nu']
-
-    # get trace of C^(-1) for significance calculation
-    Tpm = chol_inverse_diag(Tpc)
-    diagC = T[1,:]*wt*Tpm[1,:]
-    diagC[:-1] += T[0,1:]*wt[0:-1]*Tpm[0,1:]
-    diagC[1:] += T[0,1:]*wt[1:]*Tpm[0,1:]
-    TrC = diagC.sum()
-
-    # significance in sigma units (large means false alarm unlikely)
-    # (expected value of chi2_qso under the NULL hypothesis is TrC*varx)
-    out_dict['chi2_qso/nu_NULL'] = TrC*varx/out_dict['nu']
-    a=ln/2.; x = (out_dict['chi2_qso/nu']+1.e-8)/(out_dict['chi2_qso/nu_NULL']+out_dict['chi2_qso/nu']+1.e-8)
-    prob = betainc(a,a,x)
-    if prob <= 0:
-      lprob = a*np.log(x) - np.log(a) + gammaln(2*a) - 2*gammaln(a)
-    else:
-      lprob = np.log(prob)
-    out_dict['signif_qso'] = lprob2sigma(lprob)
-
-    a=ln/2.; x = 1./(1.+out_dict['chi2_qso/nu'])
-    prob = betainc(a,a,x)
-    if prob <= 0:
-      lprob = a*np.log(x) - np.log(a) + gammaln(2*a) - 2*gammaln(a)
-    else:
-      lprob = np.log(prob)
-    out_dict['signif_not_qso'] = lprob2sigma(lprob)
-
-    x = out_dict['chi2/nu']*out_dict['nu']
-    prob = gammaincc(0.5*out_dict['nu'],0.5*x)
-    if prob <= 0:
-      lprob = (0.5*out_dict['nu']-1)*np.log(x) - 0.5*x - 0.5*out_dict['nu']*np.log(2) - gammaln(0.5*out_dict['nu'])
-    else:
-      lprob = np.log( prob )
-    out_dict['signif_vary'] = lprob2sigma(lprob)
-
-    if out_dict['signif_vary'] > 3:
-        if out_dict['signif_qso'] > 3:
-            out_dict['class']='qso'
-        elif out_dict['signif_not_qso'] > 3:
-            out_dict['class']='not_qso'
-
-    # best-fit model for the lightcurve
-    if return_model:
-      model[gg] = dat - (u-u0*x0)/diagC
-      dmodel[gg] = 1./np.sqrt(diagC)
-      out_dict['model'] = model
-      out_dict['dmodel'] = dmodel
-
-    return out_dict
-
-
-def qso_fit(time, data, error, filter='g', mag0=19., sys_err=0.0, return_model=False):
-    """Best-fit qso model determined for Sesar Strip82, ugriz-bands (default r).
-    See additional notes for underlying code qso_engine.
-
-    Input:
-        time - measurement times [days]
-        data - measured magnitudes in single filter (also specified)
-        error - uncertainty in measured magnitudes
-
-    Output:
-        chi^2/nu - classical variability measure
-        chi^2_qso/nu - fit statistic
-        chi^2_qso/nu_NULL - expected fit statistic for non-qso variable
-
-        signif_qso - significance chi^2/nu<chi^2/nu_NULL (rule out false alarm)
-        signif_not_qso - significance chi^2/nu>1 (rule out qso)
-        signif_vary - significance that source is variable at all
-        class - source type (ambiguous, not_qso, qso)
-
-        model - time series prediction for each datum given all others (iff return_model==True)
-        dmodel - model uncertainty, including uncertainty in data
-
-    Note on use (i.e., how class is defined):
-
-          (0) signif_vary < 3: ambiguous, else
-          (1) signif_qso > 3: qso, else
-          (2) signif_not_qso > 3: not_qso
-    """
-
-    data = data.copy() - np.median(data) + mag0
-    pars={}
-    pars['u'] = [-3.90, 0.12, 2.73, -0.02]
-    pars['g'] = [-4.10, 0.14, 2.92, -0.07]
-    pars['r'] = [-4.34, 0.20, 3.12, -0.15]
-    pars['i'] = [-4.23, 0.05, 2.83,  0.07]
-    pars['z'] = [-4.44, 0.13, 3.06, -0.07]
-
-    par = pars[filter.lower()]
-    lvar = par[0]+par[1]*(mag0-19.)
-    ltau = par[2]+par[3]*(mag0-19.)
-
-    adict = qso_engine(time, data, error, ltau=ltau, lvar=lvar, return_model=return_model, sys_err=sys_err)
-
-    out_dict={}
-    out_dict['lvar']=lvar
-    out_dict['ltau']=ltau
-    out_dict['chi2/nu']=adict['chi2/nu']
-    out_dict['nu'] = adict['nu']
-    out_dict['chi2_qso/nu']=adict['chi2_qso/nu']
-    out_dict['chi2_qso/nu_NULL']=adict['chi2_qso/nu_NULL']
-    out_dict['signif_qso']=adict['signif_qso']
-    out_dict['signif_not_qso']=adict['signif_not_qso']
-    out_dict['signif_vary']=adict['signif_vary']
-    out_dict['class']=adict['class'];
-    out_dict['chi2qso_nu_nuNULL_ratio'] = out_dict['chi2_qso/nu'] / out_dict['chi2_qso/nu_NULL']
-
-    ### Nat has converged upon the following being the most significant featues,
-    #    Joey believes it is best to jut use these features only (so now the others are disabled in
-    #       __init__.py and qso_extractor.py
-    out_dict['log_chi2_qsonu'] = np.log(out_dict['chi2_qso/nu'])
-    out_dict['log_chi2nuNULL_chi2nu'] = np.log(out_dict['chi2_qso/nu_NULL'] / out_dict['chi2_qso/nu'])
-    ###
-
-    if return_model:
-      out_dict['model'] = adict['model']
-      out_dict['dmodel'] = adict['dmodel']
-
-    return out_dict
-
-
-def get_qso_log_chi2_qsonu(qso_model):
-    """Natural log of goodness of fit of qso-model given fixed parameters."""
-    return qso_model['log_chi2_qsonu']
-
-
-def get_qso_log_chi2nuNULL_chi2nu(qso_model):
-    """Natural log of expected chi2/nu for non-qso variable."""
-    return qso_model['log_chi2nuNULL_chi2nu']
+import numpy as np
+from scipy.stats import norm
+from scipy.linalg import solveh_banded, cholesky_banded
+from scipy.special import gammaln, betainc, gammaincc
+
+
+# TODO duplicate
+def lprob2sigma(lprob):
+    """Translates a log_e(probability) to units of Gaussian sigmas."""
+    if lprob>-36.:
+      sigma = norm.ppf(1.-0.5*np.exp(1.*lprob))
+    else:
+      sigma = np.sqrt( np.log(2./np.pi) - 2.*np.log(8.2) - 2.*lprob )
+    return float(sigma)
+
+
+def chol_inverse_diag(t):
+    """Computes inverse of matrix given its Cholesky upper Triangular decomposition t.
+    matrix form: ab[u + i - j, j] == a[i,j] (here u=1)
+    (quick version: only calculates diagonal and neighboring elements)
+    """
+    (uu,nrows) = t.shape
+    B = np.zeros((uu,nrows),dtype='float64')
+    B[1,nrows-1] = 1.0/t[1,nrows-1]**2
+    B[0,nrows-1] = -t[0,nrows-1]*B[1,nrows-1]/t[1,nrows-2]
+    for j in reversed(range(nrows-1)):
+      tjj = t[1,j]
+      B[1,j] = (1.0/tjj-t[0,j+1]*B[0,j+1])/tjj
+      B[0,j] = -t[0,j]*B[1,j]/t[1,j-1]
+    return B
+
+
+def qso_engine(time,data,error,ltau=3.,lvar=-1.7,sys_err=0.,return_model=False):
+    """Calculates the fit quality of a damped random walk to a qso lightcurve.
+    The formalism is from Rybicki & Press (1994; arXiv:comp-gas/9405004)
+
+    Data are modelled with a covariance function
+        Lij = 0.5*var*tau*exp(-|time_i-time_j|/tau) .
+
+    Input:
+        time - measurement times, typically days
+        data - measured magnitudes
+        error - uncertainty in measured magnitudes
+
+    Output (dictionary):
+
+        chi2/nu - classical variability measure
+        chi2_qso/nu - for goodness of fit given fixed parameters
+        chi2_qso/nu_extra - for parameter fitting, add to chi2/nu
+        chi^2/nu_NULL - expected chi2/nu for non-qso variable
+
+        signif_qso - significance chi^2/nu<chi^2/nu_NULL (rule out false alarm)
+        signif_not_qso - significance chi^2/nu>1 (rule out qso)
+        signif_vary - significance that source is variable
+        class - resulting source type (ambiguous, not_qso, qso)
+
+        model - time series prediction for each datum given all others (iff return_model==True)
+        dmodel - model uncertainty, including uncertainty in data
+
+    Notes:
+        T = L^(-1)
+        Data variance is D
+        Full covariance C^(-1) = (L+D)^(-1) = T [T+D^(-1)]^(-1) D^(-1)
+        Code takes advantage of the tridiagonality of T and T+D^(-1).
+    """
+
+    out_dict = {}
+    out_dict['chi2_qso/nu']=999; out_dict['chi2_qso/nu_extra']=0.;
+    out_dict['signif_qso']=0.; out_dict['signif_not_qso']=0.;  out_dict['signif_vary']=0.
+    out_dict['chi2_qso/nu_NULL']=0.; out_dict['chi2/nu']=0.; out_dict['nu']=0
+    out_dict['model']=[]; out_dict['dmodel']=[];
+    out_dict['class']='ambiguous'
+
+    lvar0 = np.log10(0.5) + lvar + ltau
+
+    ln = len(data)
+    dt = abs(time[1:]-time[:-1])
+
+    # first make sure all dt>0
+    g = np.where(dt>0.)[0]; lg = len(g)
+    # must have at least 2 data points
+    if lg <= 0:
+        return out_dict
+
+    if return_model:
+        model = 1.*data; dmodel = -1.*error
+
+    if lg < ln:
+      dt = dt[g]
+      gg = np.zeros(lg+1,dtype='int64'); gg[1:] = g+1
+      dat = data[gg]; wt = 1./(sys_err**2+error[gg]**2)
+      ln = lg+1
+    else:
+      dat = 1.*data
+      wt = 1./(sys_err**2+error**2)
+
+    out_dict['nu'] = ln-1.
+    varx = np.var(dat)
+    dat0 = (dat * wt).sum() / wt.sum()
+    out_dict['chi2/nu'] = ((dat - dat0)**2 * wt).sum() / out_dict['nu']
+
+    # define tridiagonal matrix T = L^(-1)
+    # sparse matrix form: ab[u + i - j, j] == a[i,j]   i<=j, (here u=1)
+    T = np.zeros((2,ln),dtype='float64')
+    arg = dt*np.exp(-np.log(10)*ltau); ri = np.exp(-arg); ei = 1./(1./ri-ri)
+    T[0,1:] = -ei; T[1,:-1] = 1.+ri*ei; T[1,1:] += ri*ei; T[1,ln-1] += 1.
+    T0 = np.median(T[1,:]); T /= T0
+
+    # equation for chi2_qso is [ (dat-x0) T Tp^(-1) D^(-1) (dat-x0) ]  , where Tp=T+D^(-1) and D^(-1)=wt
+    fac = np.exp(np.log(10)*lvar0)/T0
+    Tp = 1.*T
+    Tp[1,:] += wt*fac
+    # solve Tp*z=y for z (y=wt*dat)
+    # This works for scipy __version__>='0.9.0' on anathem (20120809)
+    b1 = (wt*dat).reshape((1,ln))
+    b2 = b1.T
+    #(Tpc,z) = solveh_banded(Tp,b2)
+    z = solveh_banded(Tp,b2)
+    Tpc = cholesky_banded(Tp) # the solveh_banded() function used to return the cholesky matrix, now we get seperately
+    z = z.T
+    z = z[0,:]
+    c1 = wt.reshape((1,ln))
+    c2 = c1.T
+    #(Tpc,z0) = solveh_banded(Tp,c2)
+    z0 = solveh_banded(Tp,c2)
+    #HAS NOT CHANGED#Tpc2 = cholesky_banded(Tp)
+    z0 = z0.T
+    z0 = z0[0,:]
+
+
+    #finally, get u=T*z
+    u = T[1,:]*z; u[1:] += T[0,1:]*z[:-1]; u[:-1] += T[0,1:]*z[1:]
+    u0 = T[1,:]*z0; u0[1:] += T[0,1:]*z0[:-1]; u0[:-1] += T[0,1:]*z0[1:]
+
+    # magnitude offset x0, error = 1./sqrt(u0sum)
+    u0sum = u0.sum(); x0 = u.sum()/u0sum;
+
+    # fit statistic
+    out_dict['chi2_qso/nu'] = np.dot(dat-x0,u-u0*x0)/out_dict['nu']
+
+    # -2*log(likelihood) = chi2_qso + ldet_C + log(u0sum)
+    #   first term: use chi2_qso/nu for goodness of fit with fixed parameters;
+    #   all terms: use chi2_qso/nu + chi2_qso/nu_extra for fitting with variable parameters
+    # get log of determinant for use later
+    Tc = cholesky_banded(T)
+    ldet_Tp = 2*np.log(Tpc[1,:]).sum()
+    ldet_T = 2*np.log(Tc[1,:]).sum()
+    ldet_C = ldet_Tp-ldet_T-np.log(wt).sum()
+    out_dict['chi2_qso/nu_extra'] = (ldet_C + np.log(u0sum))/out_dict['nu']
+
+    # get trace of C^(-1) for significance calculation
+    Tpm = chol_inverse_diag(Tpc)
+    diagC = T[1,:]*wt*Tpm[1,:]
+    diagC[:-1] += T[0,1:]*wt[0:-1]*Tpm[0,1:]
+    diagC[1:] += T[0,1:]*wt[1:]*Tpm[0,1:]
+    TrC = diagC.sum()
+
+    # significance in sigma units (large means false alarm unlikely)
+    # (expected value of chi2_qso under the NULL hypothesis is TrC*varx)
+    out_dict['chi2_qso/nu_NULL'] = TrC*varx/out_dict['nu']
+    a=ln/2.; x = (out_dict['chi2_qso/nu']+1.e-8)/(out_dict['chi2_qso/nu_NULL']+out_dict['chi2_qso/nu']+1.e-8)
+    prob = betainc(a,a,x)
+    if prob <= 0:
+      lprob = a*np.log(x) - np.log(a) + gammaln(2*a) - 2*gammaln(a)
+    else:
+      lprob = np.log(prob)
+    out_dict['signif_qso'] = lprob2sigma(lprob)
+
+    a=ln/2.; x = 1./(1.+out_dict['chi2_qso/nu'])
+    prob = betainc(a,a,x)
+    if prob <= 0:
+      lprob = a*np.log(x) - np.log(a) + gammaln(2*a) - 2*gammaln(a)
+    else:
+      lprob = np.log(prob)
+    out_dict['signif_not_qso'] = lprob2sigma(lprob)
+
+    x = out_dict['chi2/nu']*out_dict['nu']
+    prob = gammaincc(0.5*out_dict['nu'],0.5*x)
+    if prob <= 0:
+      lprob = (0.5*out_dict['nu']-1)*np.log(x) - 0.5*x - 0.5*out_dict['nu']*np.log(2) - gammaln(0.5*out_dict['nu'])
+    else:
+      lprob = np.log( prob )
+    out_dict['signif_vary'] = lprob2sigma(lprob)
+
+    if out_dict['signif_vary'] > 3:
+        if out_dict['signif_qso'] > 3:
+            out_dict['class']='qso'
+        elif out_dict['signif_not_qso'] > 3:
+            out_dict['class']='not_qso'
+
+    # best-fit model for the lightcurve
+    if return_model:
+      model[gg] = dat - (u-u0*x0)/diagC
+      dmodel[gg] = 1./np.sqrt(diagC)
+      out_dict['model'] = model
+      out_dict['dmodel'] = dmodel
+
+    return out_dict
+
+
+def qso_fit(time, data, error, filter='g', mag0=19., sys_err=0.0, return_model=False):
+    """Best-fit qso model determined for Sesar Strip82, ugriz-bands (default r).
+    See additional notes for underlying code qso_engine.
+
+    Input:
+        time - measurement times [days]
+        data - measured magnitudes in single filter (also specified)
+        error - uncertainty in measured magnitudes
+
+    Output:
+        chi^2/nu - classical variability measure
+        chi^2_qso/nu - fit statistic
+        chi^2_qso/nu_NULL - expected fit statistic for non-qso variable
+
+        signif_qso - significance chi^2/nu<chi^2/nu_NULL (rule out false alarm)
+        signif_not_qso - significance chi^2/nu>1 (rule out qso)
+        signif_vary - significance that source is variable at all
+        class - source type (ambiguous, not_qso, qso)
+
+        model - time series prediction for each datum given all others (iff return_model==True)
+        dmodel - model uncertainty, including uncertainty in data
+
+    Note on use (i.e., how class is defined):
+
+          (0) signif_vary < 3: ambiguous, else
+          (1) signif_qso > 3: qso, else
+          (2) signif_not_qso > 3: not_qso
+    """
+
+    data = data.copy() - np.median(data) + mag0
+    pars={}
+    pars['u'] = [-3.90, 0.12, 2.73, -0.02]
+    pars['g'] = [-4.10, 0.14, 2.92, -0.07]
+    pars['r'] = [-4.34, 0.20, 3.12, -0.15]
+    pars['i'] = [-4.23, 0.05, 2.83,  0.07]
+    pars['z'] = [-4.44, 0.13, 3.06, -0.07]
+
+    par = pars[filter.lower()]
+    lvar = par[0]+par[1]*(mag0-19.)
+    ltau = par[2]+par[3]*(mag0-19.)
+
+    adict = qso_engine(time, data, error, ltau=ltau, lvar=lvar, return_model=return_model, sys_err=sys_err)
+
+    out_dict={}
+    out_dict['lvar']=lvar
+    out_dict['ltau']=ltau
+    out_dict['chi2/nu']=adict['chi2/nu']
+    out_dict['nu'] = adict['nu']
+    out_dict['chi2_qso/nu']=adict['chi2_qso/nu']
+    out_dict['chi2_qso/nu_NULL']=adict['chi2_qso/nu_NULL']
+    out_dict['signif_qso']=adict['signif_qso']
+    out_dict['signif_not_qso']=adict['signif_not_qso']
+    out_dict['signif_vary']=adict['signif_vary']
+    out_dict['class']=adict['class'];
+    out_dict['chi2qso_nu_nuNULL_ratio'] = out_dict['chi2_qso/nu'] / out_dict['chi2_qso/nu_NULL']
+
+    ### Nat has converged upon the following being the most significant featues,
+    #    Joey believes it is best to jut use these features only (so now the others are disabled in
+    #       __init__.py and qso_extractor.py
+    out_dict['log_chi2_qsonu'] = np.log(out_dict['chi2_qso/nu'])
+    out_dict['log_chi2nuNULL_chi2nu'] = np.log(out_dict['chi2_qso/nu_NULL'] / out_dict['chi2_qso/nu'])
+    ###
+
+    if return_model:
+      out_dict['model'] = adict['model']
+      out_dict['dmodel'] = adict['dmodel']
+
+    return out_dict
+
+
+def get_qso_log_chi2_qsonu(qso_model):
+    """Natural log of goodness of fit of qso-model given fixed parameters."""
+    return qso_model['log_chi2_qsonu']
+
+
+def get_qso_log_chi2nuNULL_chi2nu(qso_model):
+    """Natural log of expected chi2/nu for non-qso variable."""
+    return qso_model['log_chi2nuNULL_chi2nu']
```

### Comparing `cesium-0.9.7/cesium/features/tests/test_cadence_features.py` & `cesium-0.9.9/cesium/features/tests/test_cadence_features.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-import itertools
-import numpy as np
-import numpy.testing as npt
-from cesium.features import cadence_features as cf
-from cesium.features.tests.util import irregular_random
-
-
-def test_delta_t_hist():
-    """Test histogram of all time lags."""
-    times, values, errors = irregular_random(500)
-    delta_ts = [pair[1] - pair[0] for pair in itertools.combinations(times, 2)]
-    nbins = 50
-    bins = np.linspace(0, max(times) - min(times), nbins + 1)
-    npt.assert_allclose(cf.delta_t_hist(times, nbins),
-                        np.histogram(delta_ts, bins=bins)[0], atol=2)
-
-
-def test_normalize_hist():
-    """Test normalization of histogram."""
-    times, values, errors = irregular_random(500)
-    delta_ts = [pair[1] - pair[0] for pair in itertools.combinations(times, 2)]
-    nbins = 50
-    bins = np.linspace(0, max(times) - min(times), nbins + 1)
-    nhist = cf.normalize_hist(cf.delta_t_hist(times, nbins),
-                              max(times) - min(times))
-    npt.assert_allclose(nhist, np.histogram(delta_ts, bins=bins,
-                                            density=True)[0], atol=0.01)
-
-
-def test_find_sorted_peaks():
-    """Test peak-finding algorithm."""
-    x = np.array([0, 5, 3, 1])  # Single peak
-    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[1, 5]]))
-
-    x = np.array([0, 5, 3, 6, 1])  # Multiple peaks
-    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[3, 6], [1, 5]]))
-
-    x = np.array([3, 1, 3])  # End-points can be peaks
-    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[0, 3], [2, 3]]))
-
-    x = np.array([0, 3, 3, 3, 0])  # In case of ties, peak is left-most point
-    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[1, 3]]))
-
-    # Tie is a peak only if greater than next value
-    x = np.array([0, 3, 3, 5, 0])
-    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[3, 5]]))
-
-
-def test_peak_ratio():
-    """ Test peak ratio method."""
-    x = np.array([0, 5, 2, 3, 1])
-    peaks1 = cf.find_sorted_peaks(x)
-    npt.assert_almost_equal(cf.peak_ratio(peaks1, 0, 1), 5 / 3)
-    assert cf.peak_ratio(peaks1, 1, 6) is np.nan
-    peaks2 = []
-    assert cf.peak_ratio(peaks2, 1, 2) is np.nan
-
-
-def test_peak_bins():
-    """ Test peak bins method """
-    x = np.array([0, 5, 2, 3, 1])
-    peaks1 = cf.find_sorted_peaks(x)
-    npt.assert_almost_equal(cf.peak_bin(peaks1, 0), 1)
-    npt.assert_almost_equal(cf.peak_bin(peaks1, 1), 3)
-    result1 = cf.peak_bin(peaks1, 6)
-    assert cf.peak_bin(peaks1, 6) is np.nan
+import itertools
+import numpy as np
+import numpy.testing as npt
+from cesium.features import cadence_features as cf
+from cesium.features.tests.util import irregular_random
+
+
+def test_delta_t_hist():
+    """Test histogram of all time lags."""
+    times, values, errors = irregular_random(500)
+    delta_ts = [pair[1] - pair[0] for pair in itertools.combinations(times, 2)]
+    nbins = 50
+    bins = np.linspace(0, max(times) - min(times), nbins + 1)
+    npt.assert_allclose(cf.delta_t_hist(times, nbins),
+                        np.histogram(delta_ts, bins=bins)[0], atol=2)
+
+
+def test_normalize_hist():
+    """Test normalization of histogram."""
+    times, values, errors = irregular_random(500)
+    delta_ts = [pair[1] - pair[0] for pair in itertools.combinations(times, 2)]
+    nbins = 50
+    bins = np.linspace(0, max(times) - min(times), nbins + 1)
+    nhist = cf.normalize_hist(cf.delta_t_hist(times, nbins),
+                              max(times) - min(times))
+    npt.assert_allclose(nhist, np.histogram(delta_ts, bins=bins,
+                                            density=True)[0], atol=0.01)
+
+
+def test_find_sorted_peaks():
+    """Test peak-finding algorithm."""
+    x = np.array([0, 5, 3, 1])  # Single peak
+    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[1, 5]]))
+
+    x = np.array([0, 5, 3, 6, 1])  # Multiple peaks
+    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[3, 6], [1, 5]]))
+
+    x = np.array([3, 1, 3])  # End-points can be peaks
+    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[0, 3], [2, 3]]))
+
+    x = np.array([0, 3, 3, 3, 0])  # In case of ties, peak is left-most point
+    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[1, 3]]))
+
+    # Tie is a peak only if greater than next value
+    x = np.array([0, 3, 3, 5, 0])
+    npt.assert_allclose(cf.find_sorted_peaks(x), np.array([[3, 5]]))
+
+
+def test_peak_ratio():
+    """ Test peak ratio method."""
+    x = np.array([0, 5, 2, 3, 1])
+    peaks1 = cf.find_sorted_peaks(x)
+    npt.assert_almost_equal(cf.peak_ratio(peaks1, 0, 1), 5 / 3)
+    assert cf.peak_ratio(peaks1, 1, 6) is np.nan
+    peaks2 = []
+    assert cf.peak_ratio(peaks2, 1, 2) is np.nan
+
+
+def test_peak_bins():
+    """ Test peak bins method """
+    x = np.array([0, 5, 2, 3, 1])
+    peaks1 = cf.find_sorted_peaks(x)
+    npt.assert_almost_equal(cf.peak_bin(peaks1, 0), 1)
+    npt.assert_almost_equal(cf.peak_bin(peaks1, 1), 3)
+    result1 = cf.peak_bin(peaks1, 6)
+    assert cf.peak_bin(peaks1, 6) is np.nan
```

### Comparing `cesium-0.9.7/cesium/features/tests/util.py` & `cesium-0.9.9/cesium/features/tests/util.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-import dask
-import numpy as np
-
-from cesium.features import generate_dask_graph
-
-
-def generate_features(t, m, e, features_to_use):
-    """Utility function that generates features from a dask DAG."""
-    graph = generate_dask_graph(t, m, e)
-    values = dask.get(graph, features_to_use)
-    return dict(zip(features_to_use, values))
-
-
-def irregular_random(seed=0, size=50):
-    """Generate random test data at irregularly-sampled times."""
-    state = np.random.RandomState(seed)
-    times = np.sort(state.uniform(0, 10, size))
-    values = state.normal(1, 1, size)
-    errors = state.exponential(0.1, size)
-    return times, values, errors
-
-
-def regular_periodic(freqs, amplitudes, phase, size=501):
-    """Generate periodic test data sampled at regular intervals: superposition
-    of multiple sine waves, each with multiple harmonics.
-    """
-    times = np.linspace(0, 2, size)
-    values = np.zeros(size)
-    for (i,j), amplitude in np.ndenumerate(amplitudes):
-        values += amplitude * np.sin(2*np.pi*times*freqs[i]*(j+1) + phase)
-    errors = 1e-4*np.ones(size)
-    return times, values, errors
-
-
-def irregular_periodic(freqs, amplitudes, phase, seed=0, size=501):
-    """Generate periodic test data sampled at randomly-spaced intervals:
-    superposition of multiple sine waves, each with multiple harmonics.
-    """
-    state = np.random.RandomState(seed)
-    times = np.sort(state.uniform(0, 2, size))
-    values = np.zeros(size)
-    for i in range(freqs.shape[0]):
-        for j in range(amplitudes.shape[1]):
-            values += amplitudes[i,j] * np.sin(2*np.pi*times*freqs[i]*(j+1)+phase)
-    errors = state.exponential(1e-2, size)
-    return times, values, errors
-
-
+import dask
+import numpy as np
+
+from cesium.features import generate_dask_graph
+
+
+def generate_features(t, m, e, features_to_use):
+    """Utility function that generates features from a dask DAG."""
+    graph = generate_dask_graph(t, m, e)
+    values = dask.get(graph, features_to_use)
+    return dict(zip(features_to_use, values))
+
+
+def irregular_random(seed=0, size=50):
+    """Generate random test data at irregularly-sampled times."""
+    state = np.random.RandomState(seed)
+    times = np.sort(state.uniform(0, 10, size))
+    values = state.normal(1, 1, size)
+    errors = state.exponential(0.1, size)
+    return times, values, errors
+
+
+def regular_periodic(freqs, amplitudes, phase, size=501):
+    """Generate periodic test data sampled at regular intervals: superposition
+    of multiple sine waves, each with multiple harmonics.
+    """
+    times = np.linspace(0, 2, size)
+    values = np.zeros(size)
+    for (i,j), amplitude in np.ndenumerate(amplitudes):
+        values += amplitude * np.sin(2*np.pi*times*freqs[i]*(j+1) + phase)
+    errors = 1e-4*np.ones(size)
+    return times, values, errors
+
+
+def irregular_periodic(freqs, amplitudes, phase, seed=0, size=501):
+    """Generate periodic test data sampled at randomly-spaced intervals:
+    superposition of multiple sine waves, each with multiple harmonics.
+    """
+    state = np.random.RandomState(seed)
+    times = np.sort(state.uniform(0, 2, size))
+    values = np.zeros(size)
+    for i in range(freqs.shape[0]):
+        for j in range(amplitudes.shape[1]):
+            values += amplitudes[i,j] * np.sin(2*np.pi*times*freqs[i]*(j+1)+phase)
+    errors = state.exponential(1e-2, size)
+    return times, values, errors
+
+
```

### Comparing `cesium-0.9.7/cesium/features/tests/data/expected_features.csv` & `cesium-0.9.9/cesium/features/tests/data/expected_features.csv`

 * *Ordering differences only*

 * *Files 2% similar despite different names*

```diff
@@ -1,4 +1,4 @@
-amplitude,flux_percentile_ratio_mid20,flux_percentile_ratio_mid35,flux_percentile_ratio_mid50,flux_percentile_ratio_mid65,flux_percentile_ratio_mid80,fold2P_slope_10percentile,fold2P_slope_90percentile,freq1_amplitude1,freq1_amplitude2,freq1_amplitude3,freq1_amplitude4,freq1_freq,freq1_lambda,freq1_rel_phase2,freq1_rel_phase3,freq1_rel_phase4,freq1_signif,freq2_amplitude1,freq2_amplitude2,freq2_amplitude3,freq2_amplitude4,freq2_freq,freq2_rel_phase2,freq2_rel_phase3,freq2_rel_phase4,freq3_amplitude1,freq3_amplitude2,freq3_amplitude3,freq3_amplitude4,freq3_freq,freq3_rel_phase2,freq3_rel_phase3,freq3_rel_phase4,freq_amplitude_ratio_21,freq_amplitude_ratio_31,freq_frequency_ratio_21,freq_frequency_ratio_31,freq_model_max_delta_mags,freq_model_min_delta_mags,freq_model_phi1_phi2,freq_n_alias,freq_signif_ratio_21,freq_signif_ratio_31,freq_varrat,freq_y_offset,linear_trend,max_slope,maximum,median,median_absolute_deviation,medperc90_2p_p,minimum,p2p_scatter_2praw,p2p_scatter_over_mad,p2p_scatter_pfold_over_mad,p2p_ssqr_diff_over_var,percent_amplitude,percent_beyond_1_std,percent_close_to_median,percent_difference_flux_percentile,period_fast,qso_log_chi2_qsonu,qso_log_chi2nuNULL_chi2nu,scatter_res_raw,skew,std,stetson_j,stetson_k,weighted_average
-0.4695,0.1391191698,0.255495667,0.3933558399,0.5357113476,0.7345991397,-3.4444531503,3.3307906791,0.1013563889,0.0142452789,0.0005442693,0.0010724211,6.0688970237,5.4934900906,-1.8107758352,2.090252784,1.3995008795,11.2681277508,0.0315886229,0.0018222864,0.0006995279,0.0002360676,2.3250069312,0.1572123843,1.9347274633,1.8081434543,0.0290885372,0.0009549442,0.0004769511,0.0001788471,9.1142277619,-0.372819872,2.4993977233,-1.5869169231,0.3116589224,0.2869926359,0.3831020566,1.5017931144,8.52055231926E-11,3.05807826284E-09,0.3927107357,0,0.4208495586,0.4030330277,6.88293697906E-05,-0.0029369825,2.4986485735E-05,0.31574689,13.869,13.295,0.088,0.9631850179,12.93,0.7409749222,1.2556818182,1.0397727273,1.7838983953,0.4106137498,0.29263158,0.5305263158,0.4140128815,27.4480915,1.9335536941,0.1127558354,0.7102264604,0.5536755309,0.1392362364,0.1863107801,0.958934476,13.30343644
-0.365,0.1773462194,0.3114327492,0.436904049,0.5882967978,0.7672402192,-1.92492705,2.0255490809,0.0415961966,0.0009118138,0.0005114711,0.0002122479,8.3859538513,8.6831998581,-1.5722344384,-2.6650322107,-1.8396554581,12.0229612753,0.0093384569,0.0009404195,0.0001609345,3.64872550248E-05,2.1464473663,-1.9173684556,2.0252829445,1.2310896164,0.0108355446,0.0013703744,0.0002473447,0.0001088843,10.5167443839,-2.2392773646,-2.7672119788,0.9033347702,0.2245026632,0.260493639,0.2559574503,1.2540904196,2.122405654E-10,8.91044751872E-10,0.3559372874,0,0.327293423,0.3407100021,1.80627698458E-05,0.0012543862,1.97883821107E-06,15.90909091,10.46,9.997,0.028,0.9540692349,9.73,0.7226474127,1.3214285714,0.8214285714,1.8128582015,0.3471701558,0.186,0.94,0.1139420046,22.91634888,0.3587730502,0.2151954704,0.5705804968,2.96462376,0.0554298829,-0.8531922756,0.7876747619,10.00258434
-2.1945,0.2857724132,0.4855634926,0.6426319146,0.7897408686,0.923373012,-0.3117055105,0.2927787224,0.4290081032,1.6849492872,0.1463171964,0.1229216884,0.001432796,0.0242805022,-0.7604340529,-2.8975835688,2.3142690591,17.872747262,0.1252429352,0.0211855055,0.0184750321,0.00283892,0.999571743,2.5602804971,1.7676877105,-0.8397250706,0.0955682377,0.0722449483,0.0120842339,0.009488304,0.0011792038,-0.303170517,-1.9002231169,1.7726147378,0.2919360597,0.222765577,697.637168142,0.8230088496,0.1609657391,0.9035285273,0.1879728818,1,0.5854892756,0.5377487349,0.0003623603,0.1330412794,-5.56786497429E-05,76.71641791,12.278,9.3305,1.0895,2.1390951062,7.889,0.62737528,0.0541532813,0.0761817347,0.1064545744,2.7722459419,0.40248963,0.1742738589,3.2994822291,348.58243204,3.453919777,3.3395417584,0.05925052,0.4301775459,1.279772667,11.6164598093,0.9751156768,9.49116371
+amplitude,flux_percentile_ratio_mid20,flux_percentile_ratio_mid35,flux_percentile_ratio_mid50,flux_percentile_ratio_mid65,flux_percentile_ratio_mid80,fold2P_slope_10percentile,fold2P_slope_90percentile,freq1_amplitude1,freq1_amplitude2,freq1_amplitude3,freq1_amplitude4,freq1_freq,freq1_lambda,freq1_rel_phase2,freq1_rel_phase3,freq1_rel_phase4,freq1_signif,freq2_amplitude1,freq2_amplitude2,freq2_amplitude3,freq2_amplitude4,freq2_freq,freq2_rel_phase2,freq2_rel_phase3,freq2_rel_phase4,freq3_amplitude1,freq3_amplitude2,freq3_amplitude3,freq3_amplitude4,freq3_freq,freq3_rel_phase2,freq3_rel_phase3,freq3_rel_phase4,freq_amplitude_ratio_21,freq_amplitude_ratio_31,freq_frequency_ratio_21,freq_frequency_ratio_31,freq_model_max_delta_mags,freq_model_min_delta_mags,freq_model_phi1_phi2,freq_n_alias,freq_signif_ratio_21,freq_signif_ratio_31,freq_varrat,freq_y_offset,linear_trend,max_slope,maximum,median,median_absolute_deviation,medperc90_2p_p,minimum,p2p_scatter_2praw,p2p_scatter_over_mad,p2p_scatter_pfold_over_mad,p2p_ssqr_diff_over_var,percent_amplitude,percent_beyond_1_std,percent_close_to_median,percent_difference_flux_percentile,period_fast,qso_log_chi2_qsonu,qso_log_chi2nuNULL_chi2nu,scatter_res_raw,skew,std,stetson_j,stetson_k,weighted_average
+0.4695,0.1391191698,0.255495667,0.3933558399,0.5357113476,0.7345991397,-3.4444531503,3.3307906791,0.1013563889,0.0142452789,0.0005442693,0.0010724211,6.0688970237,5.4934900906,-1.8107758352,2.090252784,1.3995008795,11.2681277508,0.0315886229,0.0018222864,0.0006995279,0.0002360676,2.3250069312,0.1572123843,1.9347274633,1.8081434543,0.0290885372,0.0009549442,0.0004769511,0.0001788471,9.1142277619,-0.372819872,2.4993977233,-1.5869169231,0.3116589224,0.2869926359,0.3831020566,1.5017931144,8.52055231926E-11,3.05807826284E-09,0.3927107357,0,0.4208495586,0.4030330277,6.88293697906E-05,-0.0029369825,2.4986485735E-05,0.31574689,13.869,13.295,0.088,0.9631850179,12.93,0.7409749222,1.2556818182,1.0397727273,1.7838983953,0.4106137498,0.29263158,0.5305263158,0.4140128815,27.4480915,1.9335536941,0.1127558354,0.7102264604,0.5536755309,0.1392362364,0.1863107801,0.958934476,13.30343644
+0.365,0.1773462194,0.3114327492,0.436904049,0.5882967978,0.7672402192,-1.92492705,2.0255490809,0.0415961966,0.0009118138,0.0005114711,0.0002122479,8.3859538513,8.6831998581,-1.5722344384,-2.6650322107,-1.8396554581,12.0229612753,0.0093384569,0.0009404195,0.0001609345,3.64872550248E-05,2.1464473663,-1.9173684556,2.0252829445,1.2310896164,0.0108355446,0.0013703744,0.0002473447,0.0001088843,10.5167443839,-2.2392773646,-2.7672119788,0.9033347702,0.2245026632,0.260493639,0.2559574503,1.2540904196,2.122405654E-10,8.91044751872E-10,0.3559372874,0,0.327293423,0.3407100021,1.80627698458E-05,0.0012543862,1.97883821107E-06,15.90909091,10.46,9.997,0.028,0.9540692349,9.73,0.7226474127,1.3214285714,0.8214285714,1.8128582015,0.3471701558,0.186,0.94,0.1139420046,22.91634888,0.3587730502,0.2151954704,0.5705804968,2.96462376,0.0554298829,-0.8531922756,0.7876747619,10.00258434
+2.1945,0.2857724132,0.4855634926,0.6426319146,0.7897408686,0.923373012,-0.3117055105,0.2927787224,0.4290081032,1.6849492872,0.1463171964,0.1229216884,0.001432796,0.0242805022,-0.7604340529,-2.8975835688,2.3142690591,17.872747262,0.1252429352,0.0211855055,0.0184750321,0.00283892,0.999571743,2.5602804971,1.7676877105,-0.8397250706,0.0955682377,0.0722449483,0.0120842339,0.009488304,0.0011792038,-0.303170517,-1.9002231169,1.7726147378,0.2919360597,0.222765577,697.637168142,0.8230088496,0.1609657391,0.9035285273,0.1879728818,1,0.5854892756,0.5377487349,0.0003623603,0.1330412794,-5.56786497429E-05,76.71641791,12.278,9.3305,1.0895,2.1390951062,7.889,0.62737528,0.0541532813,0.0761817347,0.1064545744,2.7722459419,0.40248963,0.1742738589,3.2994822291,348.58243204,3.453919777,3.3395417584,0.05925052,0.4301775459,1.279772667,11.6164598093,0.9751156768,9.49116371
```

### Comparing `cesium-0.9.7/cesium/features/tests/data/257141.dat` & `cesium-0.9.9/cesium/features/tests/data/257141.dat`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,475 +1,475 @@
-1962.88722,13.147,0.051
-1964.8884,13.14,0.045
-1966.88442,13.41,0.045
-1980.85669,13.21,0.053
-1997.88895,13.387,0.057
-2025.78317,13.412,0.051
-2026.84913,13.142,0.073
-2027.82398,13.19,0.053
-2030.82658,13.269,0.059
-2031.83369,13.365,0.065
-2032.81596,13.232,0.056
-2033.83164,13.404,0.049
-2037.77098,13.373,0.07
-2039.7905,13.398,0.076
-2052.76005,13.242,0.071
-2053.77969,13.337,0.071
-2054.77453,13.427,0.074
-2055.7609,13.46,0.076
-2056.76205,13.338,0.073
-2057.76027,13.187,0.063
-2058.75927,13.321,0.07
-2061.78736,13.196,0.068
-2065.71782,13.14,0.07
-2067.65515,13.283,0.06
-2069.79994,13.216,0.048
-2070.72847,13.322,0.07
-2080.64382,13.409,0.073
-2081.69588,13.235,0.063
-2082.71382,13.175,0.063
-2083.70479,13.166,0.075
-2085.69149,13.263,0.062
-2086.71353,13.292,0.066
-2087.69475,13.334,0.068
-2088.69376,13.319,0.073
-2093.59882,13.059,0.069
-2094.62199,13.247,0.076
-2103.65512,13.266,0.058
-2104.66357,13.297,0.056
-2105.6555,13.253,0.065
-2106.6587,13.412,0.061
-2114.75039,13.36,0.043
-2115.64078,13.16,0.046
-2116.62873,13.067,0.052
-2117.62459,13.089,0.059
-2125.60163,13.437,0.052
-2128.6284,13.271,0.058
-2129.60457,13.306,0.051
-2130.60692,13.26,0.065
-2131.59721,13.204,0.06
-2132.60312,13.159,0.065
-2133.59721,13.145,0.052
-2134.60018,13.158,0.064
-2135.59421,13.217,0.061
-2140.5736,13.36,0.052
-2141.58527,13.315,0.059
-2142.57953,13.312,0.054
-2143.57779,13.404,0.058
-2144.57101,13.491,0.064
-2145.56652,13.496,0.056
-2163.52919,13.345,0.067
-2167.5059,13.172,0.058
-2169.55409,13.078,0.061
-2172.50438,13.144,0.054
-2179.48854,13.516,0.067
-2183.48468,13.063,0.065
-2185.55277,13.292,0.051
-2188.52984,13.319,0.052
-2191.49279,13.297,0.059
-2193.56128,13.364,0.06
-2198.50652,13.168,0.059
-2202.51008,13.302,0.053
-2207.49848,13.362,0.052
-2213.49454,13.35,0.06
-2216.50919,13.143,0.076
-2226.51749,13.106,0.071
-2442.71552,13.151,0.045
-2443.70612,13.28,0.029
-2444.71035,13.205,0.038
-2446.70404,13.062,0.044
-2459.67127,13.121,0.048
-2465.66316,13.299,0.039
-2466.65828,13.202,0.044
-2467.6621,13.446,0.036
-2468.65216,13.269,0.036
-2470.60873,13.408,0.04
-2474.66803,13.101,0.048
-2486.61925,13.408,0.046
-2489.6413,13.15,0.034
-2491.61075,13.244,0.045
-2493.60622,13.079,0.043
-2497.60383,13.315,0.039
-2498.59414,13.096,0.045
-2499.59227,13.289,0.04
-2500.56438,13.425,0.043
-2501.59374,13.293,0.038
-2502.60057,13.195,0.038
-2508.71512,13.445,0.038
-2512.52655,13.383,0.046
-2520.60221,13.297,0.039
-2521.61184,13.263,0.04
-2526.49671,13.348,0.05
-2535.59241,13.273,0.048
-2540.64807,13.303,0.047
-2544.64447,13.428,0.041
-2554.64111,13.193,0.056
-2556.64784,13.486,0.056
-2561.50514,13.191,0.037
-2562.55901,13.204,0.064
-2563.585,13.418,0.04
-2564.59847,13.098,0.046
-2565.62417,13.337,0.049
-2578.55972,13.543,0.041
-2699.88902,13.381,0.042
-2703.88234,13.194,0.036
-2706.87683,13.345,0.039
-2709.8692,13.3,0.041
-2712.86359,13.373,0.039
-2717.8928,13.363,0.041
-2720.86144,13.283,0.039
-2730.8935,13.276,0.039
-2734.81443,13.418,0.037
-2736.85096,13.125,0.041
-2738.85437,13.258,0.035
-2740.86688,13.392,0.035
-2742.85461,13.426,0.036
-2744.84877,13.299,0.037
-2754.84061,13.294,0.038
-2756.84142,13.394,0.035
-2758.85972,13.448,0.033
-2760.82003,13.597,0.042
-2764.81372,13.196,0.037
-2783.69573,13.377,0.035
-2786.75676,13.23,0.037
-2790.77642,13.251,0.036
-2808.85901,13.15,0.036
-2810.70545,13.258,0.036
-2812.67413,13.258,0.037
-2814.84025,13.361,0.049
-2819.73743,13.12,0.04
-2821.73117,13.165,0.036
-2830.77529,13.304,0.037
-2832.61669,13.279,0.036
-2838.8273,13.313,0.037
-2840.88586,13.601,0.044
-2845.82406,13.433,0.049
-2853.59679,13.348,0.035
-2854.8317,13.19,0.032
-2858.6175,13.22,0.033
-2866.69147,13.262,0.04
-2867.74897,13.341,0.038
-2872.71034,13.398,0.04
-2875.71167,13.193,0.041
-2877.67989,13.271,0.038
-2879.72302,13.251,0.039
-2883.52025,13.207,0.035
-2884.70414,13.25,0.037
-2892.69448,13.211,0.046
-2894.60138,13.388,0.041
-2895.72162,13.325,0.038
-2897.72401,13.869,0.037
-2899.69132,13.324,0.042
-2902.4921,13.328,0.037
-2908.50825,13.243,0.034
-2910.52074,13.258,0.037
-2911.69978,13.077,0.039
-2916.51089,13.254,0.038
-2917.60858,13.191,0.037
-2921.59839,13.173,0.037
-2923.58816,13.104,0.044
-2926.58662,13.415,0.036
-2928.58857,13.331,0.038
-2930.5839,13.25,0.037
-2932.58218,13.164,0.036
-2934.57837,13.192,0.036
-2939.58244,13.258,0.037
-2944.51893,13.282,0.046
-2945.601,13.118,0.036
-2948.58003,13.154,0.037
-2951.52464,13.149,0.041
-2955.57405,13.381,0.037
-2958.5261,13.324,0.034
-2963.52502,13.255,0.04
-2965.54053,13.252,0.036
-2971.5136,12.968,0.038
-3074.88226,13.425,0.037
-3081.87429,13.318,0.048
-3087.87836,13.485,0.04
-3091.86692,13.176,0.039
-3097.85828,13.161,0.037
-3101.84842,13.233,0.04
-3104.87201,13.606,0.047
-3108.83427,13.281,0.036
-3114.89478,13.384,0.035
-3118.87428,13.388,0.037
-3125.84777,13.223,0.038
-3128.82374,13.13,0.039
-3131.79562,13.146,0.038
-3142.80669,13.264,0.041
-3146.76044,13.38,0.034
-3154.68783,13.195,0.036
-3159.79893,13.188,0.039
-3162.83905,13.276,0.037
-3165.73765,13.014,0.042
-3168.78779,13.393,0.041
-3170.87424,13.085,0.038
-3176.79923,13.087,0.04
-3179.71491,13.444,0.037
-3182.72706,13.219,0.038
-3184.72501,13.11,0.034
-3186.77016,13.311,0.039
-3189.86196,13.166,0.038
-3191.9053,13.45,0.061
-3266.54772,13.239,0.038
-3272.5278,13.29,0.043
-3326.55554,13.303,0.043
-3339.52341,13.576,0.085
-3425.88823,13.255,0.087
-3433.88137,13.2,0.041
-3444.86552,13.233,0.054
-3447.89204,13.316,0.063
-3452.87085,13.412,0.052
-3455.85282,13.557,0.051
-3458.87374,13.182,0.037
-3464.84401,13.191,0.053
-3468.85636,13.624,0.07
-3472.86852,13.311,0.053
-3478.84387,13.495,0.054
-3481.83559,13.185,0.068
-3484.85419,13.432,0.055
-3490.90558,13.17,0.043
-3496.86288,13.405,0.044
-3500.84031,13.271,0.051
-3503.80976,13.293,0.041
-3506.85582,13.218,0.038
-3509.85222,13.214,0.04
-3512.75349,13.021,0.038
-3521.77708,13.5,0.071
-3523.86171,13.313,0.055
-3528.81285,13.333,0.049
-3538.77677,13.116,0.054
-3550.74479,13.533,0.044
-3552.84508,13.404,0.041
-3555.76247,13.254,0.037
-3558.90417,13.295,0.042
-3561.65958,13.353,0.061
-3563.70797,13.148,0.048
-3570.66813,13.378,0.038
-3572.83513,13.62,0.036
-3574.85452,13.283,0.044
-3576.84187,13.326,0.039
-3583.73178,13.286,0.052
-3585.76118,13.208,0.049
-3587.78418,13.31,0.038
-3590.61543,13.442,0.063
-3592.63336,13.252,0.044
-3596.62222,13.176,0.036
-3602.60171,13.323,0.037
-3617.61447,13.181,0.044
-3619.7006,13.276,0.043
-3622.52912,13.191,0.057
-3628.56356,13.229,0.037
-3630.644,13.427,0.038
-3632.64616,13.236,0.039
-3634.68178,13.142,0.042
-3637.67901,13.203,0.039
-3640.69042,13.178,0.039
-3643.52314,13.492,0.04
-3646.60084,13.377,0.037
-3649.54879,13.109,0.053
-3655.52622,13.378,0.055
-3657.59891,12.982,0.065
-3659.63513,13.541,0.036
-3662.51946,13.137,0.044
-3664.54331,13.302,0.046
-3668.52358,13.368,0.035
-3670.57711,13.291,0.034
-3673.53419,13.316,0.037
-3675.60558,13.261,0.055
-3678.55411,13.274,0.049
-3700.53501,13.373,0.047
-3703.52505,13.36,0.04
-3793.8949,13.156,0.07
-3797.89717,13.359,0.057
-3804.88216,13.19,0.06
-3808.88257,13.074,0.044
-3812.88382,13.387,0.05
-3819.87713,13.022,0.087
-3823.85786,13.253,0.078
-3827.84953,13.267,0.08
-3831.84168,13.429,0.068
-3834.87089,13.32,0.067
-3857.8793,13.679,0.047
-3860.8273,13.238,0.055
-3863.80866,13.463,0.074
-3865.84155,13.239,0.078
-3867.81598,13.199,0.077
-3869.82153,13.281,0.042
-3874.80632,13.251,0.055
-3877.79377,13.235,0.043
-3880.86315,13.191,0.038
-3883.86175,13.075,0.079
-3887.79933,13.321,0.037
-3892.74013,13.215,0.048
-3894.73489,13.343,0.038
-3900.78606,13.248,0.046
-3902.78191,13.124,0.041
-3904.7999,13.319,0.041
-3906.85525,13.377,0.046
-3909.71921,13.133,0.071
-3913.74977,13.426,0.051
-4159.89093,13.357,0.046
-4163.8898,13.557,0.06
-4167.88095,13.035,0.077
-4179.88322,13.334,0.066
-4182.90901,13.4,0.048
-4191.85369,13.478,0.048
-4203.85933,13.384,0.06
-4207.88567,13.391,0.055
-4215.86587,13.486,0.039
-4228.88706,13.328,0.05
-4230.86994,13.21,0.041
-4233.80466,13.096,0.036
-4235.87083,13.327,0.056
-4247.77352,13.368,0.037
-4251.82102,13.157,0.044
-4256.81366,13.744,0.043
-4272.72091,13.433,0.042
-4274.75606,13.34,0.036
-4277.72019,13.242,0.034
-4283.74129,13.275,0.058
-4285.72947,13.158,0.043
-4289.72336,13.211,0.035
-4291.72547,13.486,0.035
-4293.71421,13.687,0.037
-4295.72697,13.354,0.035
-4299.69132,13.29,0.036
-4301.68244,13.187,0.045
-4303.68697,13.296,0.04
-4305.67826,13.17,0.037
-4307.65443,13.23,0.048
-4312.66217,13.348,0.039
-4315.66243,13.3,0.036
-4330.61068,13.278,0.036
-4332.60711,13.57,0.037
-4334.59904,13.495,0.032
-4338.61325,13.27,0.037
-4340.67356,13.584,0.037
-4342.6678,13.266,0.053
-4344.67186,13.456,0.041
-4346.66873,13.196,0.057
-4348.67379,13.216,0.061
-4350.68213,13.22,0.047
-4353.54385,13.455,0.047
-4355.63203,13.419,0.035
-4357.63592,13.464,0.039
-4359.67082,13.294,0.038
-4361.61975,13.445,0.043
-4365.52702,13.322,0.036
-4372.5185,13.23,0.043
-4375.54944,13.207,0.039
-4377.55668,13.597,0.047
-4379.5581,13.502,0.053
-4381.61027,13.31,0.041
-4383.6505,13.401,0.049
-4386.55108,12.93,0.046
-4388.53482,12.941,0.049
-4393.5195,13.346,0.048
-4400.61515,13.4,0.042
-4404.60026,13.303,0.036
-4408.53987,13.497,0.044
-4411.5635,13.421,0.038
-4422.54904,13.328,0.042
-4428.52228,13.437,0.045
-4431.53044,13.264,0.041
-4435.52149,13.197,0.044
-4521.89568,13.439,0.047
-4530.89645,13.354,0.055
-4537.89701,13.346,0.045
-4541.88924,13.423,0.049
-4545.88708,13.301,0.052
-4561.84422,13.3,0.055
-4564.88318,13.143,0.041
-4567.89831,13.26,0.044
-4571.83721,13.514,0.035
-4574.83014,13.286,0.042
-4577.86727,13.002,0.044
-4583.91369,13.222,0.034
-4587.80486,13.279,0.041
-4590.82466,13.238,0.047
-4593.81059,13.256,0.039
-4601.80901,13.313,0.043
-4611.84073,13.327,0.036
-4616.91278,13.141,0.039
-4623.74101,13.478,0.045
-4627.78573,13.308,0.04
-4629.76998,13.337,0.04
-4631.7834,13.265,0.035
-4633.76823,13.188,0.041
-4639.75778,13.469,0.034
-4641.76493,13.363,0.036
-4643.7593,13.235,0.041
-4645.79075,13.348,0.046
-4647.85553,13.259,0.088
-4650.68073,13.161,0.048
-4652.73206,13.178,0.038
-4654.72494,13.356,0.049
-4656.71356,13.34,0.042
-4660.65107,13.311,0.039
-4662.69692,13.287,0.041
-4665.69421,12.981,0.036
-4672.77724,13.231,0.063
-4675.78414,13.204,0.048
-4681.71257,13.59,0.046
-4683.76477,13.376,0.049
-4685.68374,13.331,0.04
-4687.66787,13.443,0.051
-4696.81322,13.241,0.04
-4698.71895,13.249,0.051
-4700.71952,13.526,0.055
-4705.52693,13.336,0.037
-4707.65148,13.241,0.06
-4709.75444,13.461,0.066
-4716.59223,13.292,0.045
-4720.63579,13.591,0.045
-4722.66344,13.349,0.047
-4725.6878,13.161,0.069
-4728.61777,13.416,0.04
-4730.65686,13.314,0.065
-4733.66063,13.392,0.048
-4738.60117,13.572,0.035
-4741.58001,13.405,0.059
-4743.59971,13.218,0.053
-4754.6438,13.143,0.06
-4757.55182,13.454,0.07
-4760.54749,13.231,0.063
-4763.54526,13.403,0.071
-4766.53046,13.56,0.062
-4768.60658,13.614,0.059
-4771.54135,13.369,0.056
-4775.53074,13.343,0.038
-4777.56782,13.365,0.043
-4780.56444,13.171,0.069
-4784.54265,13.231,0.069
-4787.53628,13.301,0.063
-4793.53567,13.177,0.069
-4797.5192,13.141,0.076
-4906.87954,13.368,0.06
-4917.87108,13.382,0.045
-4928.90721,13.277,0.054
-4935.87248,13.649,0.05
-4946.86532,13.448,0.048
-4949.84677,13.557,0.047
-4952.84301,13.51,0.058
-4968.79754,13.469,0.045
-4974.7902,13.4,0.051
-4985.74019,13.369,0.045
-4993.79549,13.311,0.042
-5006.85032,13.325,0.051
-5012.80173,13.474,0.049
-5014.74093,13.253,0.045
-5022.71146,13.374,0.044
-5037.6678,13.69,0.058
-5039.65209,13.671,0.041
-5041.63562,13.507,0.04
-5048.63806,13.369,0.042
-5063.67214,13.774,0.045
-5070.72112,13.205,0.068
-5075.58973,13.11,0.042
-5083.64578,13.203,0.05
-5089.72847,13.279,0.049
-5092.58166,13.315,0.042
-5098.54825,13.315,0.043
-5105.60764,13.249,0.048
-5124.58221,13.844,0.073
-5129.51864,13.36,0.044
+1962.88722,13.147,0.051
+1964.8884,13.14,0.045
+1966.88442,13.41,0.045
+1980.85669,13.21,0.053
+1997.88895,13.387,0.057
+2025.78317,13.412,0.051
+2026.84913,13.142,0.073
+2027.82398,13.19,0.053
+2030.82658,13.269,0.059
+2031.83369,13.365,0.065
+2032.81596,13.232,0.056
+2033.83164,13.404,0.049
+2037.77098,13.373,0.07
+2039.7905,13.398,0.076
+2052.76005,13.242,0.071
+2053.77969,13.337,0.071
+2054.77453,13.427,0.074
+2055.7609,13.46,0.076
+2056.76205,13.338,0.073
+2057.76027,13.187,0.063
+2058.75927,13.321,0.07
+2061.78736,13.196,0.068
+2065.71782,13.14,0.07
+2067.65515,13.283,0.06
+2069.79994,13.216,0.048
+2070.72847,13.322,0.07
+2080.64382,13.409,0.073
+2081.69588,13.235,0.063
+2082.71382,13.175,0.063
+2083.70479,13.166,0.075
+2085.69149,13.263,0.062
+2086.71353,13.292,0.066
+2087.69475,13.334,0.068
+2088.69376,13.319,0.073
+2093.59882,13.059,0.069
+2094.62199,13.247,0.076
+2103.65512,13.266,0.058
+2104.66357,13.297,0.056
+2105.6555,13.253,0.065
+2106.6587,13.412,0.061
+2114.75039,13.36,0.043
+2115.64078,13.16,0.046
+2116.62873,13.067,0.052
+2117.62459,13.089,0.059
+2125.60163,13.437,0.052
+2128.6284,13.271,0.058
+2129.60457,13.306,0.051
+2130.60692,13.26,0.065
+2131.59721,13.204,0.06
+2132.60312,13.159,0.065
+2133.59721,13.145,0.052
+2134.60018,13.158,0.064
+2135.59421,13.217,0.061
+2140.5736,13.36,0.052
+2141.58527,13.315,0.059
+2142.57953,13.312,0.054
+2143.57779,13.404,0.058
+2144.57101,13.491,0.064
+2145.56652,13.496,0.056
+2163.52919,13.345,0.067
+2167.5059,13.172,0.058
+2169.55409,13.078,0.061
+2172.50438,13.144,0.054
+2179.48854,13.516,0.067
+2183.48468,13.063,0.065
+2185.55277,13.292,0.051
+2188.52984,13.319,0.052
+2191.49279,13.297,0.059
+2193.56128,13.364,0.06
+2198.50652,13.168,0.059
+2202.51008,13.302,0.053
+2207.49848,13.362,0.052
+2213.49454,13.35,0.06
+2216.50919,13.143,0.076
+2226.51749,13.106,0.071
+2442.71552,13.151,0.045
+2443.70612,13.28,0.029
+2444.71035,13.205,0.038
+2446.70404,13.062,0.044
+2459.67127,13.121,0.048
+2465.66316,13.299,0.039
+2466.65828,13.202,0.044
+2467.6621,13.446,0.036
+2468.65216,13.269,0.036
+2470.60873,13.408,0.04
+2474.66803,13.101,0.048
+2486.61925,13.408,0.046
+2489.6413,13.15,0.034
+2491.61075,13.244,0.045
+2493.60622,13.079,0.043
+2497.60383,13.315,0.039
+2498.59414,13.096,0.045
+2499.59227,13.289,0.04
+2500.56438,13.425,0.043
+2501.59374,13.293,0.038
+2502.60057,13.195,0.038
+2508.71512,13.445,0.038
+2512.52655,13.383,0.046
+2520.60221,13.297,0.039
+2521.61184,13.263,0.04
+2526.49671,13.348,0.05
+2535.59241,13.273,0.048
+2540.64807,13.303,0.047
+2544.64447,13.428,0.041
+2554.64111,13.193,0.056
+2556.64784,13.486,0.056
+2561.50514,13.191,0.037
+2562.55901,13.204,0.064
+2563.585,13.418,0.04
+2564.59847,13.098,0.046
+2565.62417,13.337,0.049
+2578.55972,13.543,0.041
+2699.88902,13.381,0.042
+2703.88234,13.194,0.036
+2706.87683,13.345,0.039
+2709.8692,13.3,0.041
+2712.86359,13.373,0.039
+2717.8928,13.363,0.041
+2720.86144,13.283,0.039
+2730.8935,13.276,0.039
+2734.81443,13.418,0.037
+2736.85096,13.125,0.041
+2738.85437,13.258,0.035
+2740.86688,13.392,0.035
+2742.85461,13.426,0.036
+2744.84877,13.299,0.037
+2754.84061,13.294,0.038
+2756.84142,13.394,0.035
+2758.85972,13.448,0.033
+2760.82003,13.597,0.042
+2764.81372,13.196,0.037
+2783.69573,13.377,0.035
+2786.75676,13.23,0.037
+2790.77642,13.251,0.036
+2808.85901,13.15,0.036
+2810.70545,13.258,0.036
+2812.67413,13.258,0.037
+2814.84025,13.361,0.049
+2819.73743,13.12,0.04
+2821.73117,13.165,0.036
+2830.77529,13.304,0.037
+2832.61669,13.279,0.036
+2838.8273,13.313,0.037
+2840.88586,13.601,0.044
+2845.82406,13.433,0.049
+2853.59679,13.348,0.035
+2854.8317,13.19,0.032
+2858.6175,13.22,0.033
+2866.69147,13.262,0.04
+2867.74897,13.341,0.038
+2872.71034,13.398,0.04
+2875.71167,13.193,0.041
+2877.67989,13.271,0.038
+2879.72302,13.251,0.039
+2883.52025,13.207,0.035
+2884.70414,13.25,0.037
+2892.69448,13.211,0.046
+2894.60138,13.388,0.041
+2895.72162,13.325,0.038
+2897.72401,13.869,0.037
+2899.69132,13.324,0.042
+2902.4921,13.328,0.037
+2908.50825,13.243,0.034
+2910.52074,13.258,0.037
+2911.69978,13.077,0.039
+2916.51089,13.254,0.038
+2917.60858,13.191,0.037
+2921.59839,13.173,0.037
+2923.58816,13.104,0.044
+2926.58662,13.415,0.036
+2928.58857,13.331,0.038
+2930.5839,13.25,0.037
+2932.58218,13.164,0.036
+2934.57837,13.192,0.036
+2939.58244,13.258,0.037
+2944.51893,13.282,0.046
+2945.601,13.118,0.036
+2948.58003,13.154,0.037
+2951.52464,13.149,0.041
+2955.57405,13.381,0.037
+2958.5261,13.324,0.034
+2963.52502,13.255,0.04
+2965.54053,13.252,0.036
+2971.5136,12.968,0.038
+3074.88226,13.425,0.037
+3081.87429,13.318,0.048
+3087.87836,13.485,0.04
+3091.86692,13.176,0.039
+3097.85828,13.161,0.037
+3101.84842,13.233,0.04
+3104.87201,13.606,0.047
+3108.83427,13.281,0.036
+3114.89478,13.384,0.035
+3118.87428,13.388,0.037
+3125.84777,13.223,0.038
+3128.82374,13.13,0.039
+3131.79562,13.146,0.038
+3142.80669,13.264,0.041
+3146.76044,13.38,0.034
+3154.68783,13.195,0.036
+3159.79893,13.188,0.039
+3162.83905,13.276,0.037
+3165.73765,13.014,0.042
+3168.78779,13.393,0.041
+3170.87424,13.085,0.038
+3176.79923,13.087,0.04
+3179.71491,13.444,0.037
+3182.72706,13.219,0.038
+3184.72501,13.11,0.034
+3186.77016,13.311,0.039
+3189.86196,13.166,0.038
+3191.9053,13.45,0.061
+3266.54772,13.239,0.038
+3272.5278,13.29,0.043
+3326.55554,13.303,0.043
+3339.52341,13.576,0.085
+3425.88823,13.255,0.087
+3433.88137,13.2,0.041
+3444.86552,13.233,0.054
+3447.89204,13.316,0.063
+3452.87085,13.412,0.052
+3455.85282,13.557,0.051
+3458.87374,13.182,0.037
+3464.84401,13.191,0.053
+3468.85636,13.624,0.07
+3472.86852,13.311,0.053
+3478.84387,13.495,0.054
+3481.83559,13.185,0.068
+3484.85419,13.432,0.055
+3490.90558,13.17,0.043
+3496.86288,13.405,0.044
+3500.84031,13.271,0.051
+3503.80976,13.293,0.041
+3506.85582,13.218,0.038
+3509.85222,13.214,0.04
+3512.75349,13.021,0.038
+3521.77708,13.5,0.071
+3523.86171,13.313,0.055
+3528.81285,13.333,0.049
+3538.77677,13.116,0.054
+3550.74479,13.533,0.044
+3552.84508,13.404,0.041
+3555.76247,13.254,0.037
+3558.90417,13.295,0.042
+3561.65958,13.353,0.061
+3563.70797,13.148,0.048
+3570.66813,13.378,0.038
+3572.83513,13.62,0.036
+3574.85452,13.283,0.044
+3576.84187,13.326,0.039
+3583.73178,13.286,0.052
+3585.76118,13.208,0.049
+3587.78418,13.31,0.038
+3590.61543,13.442,0.063
+3592.63336,13.252,0.044
+3596.62222,13.176,0.036
+3602.60171,13.323,0.037
+3617.61447,13.181,0.044
+3619.7006,13.276,0.043
+3622.52912,13.191,0.057
+3628.56356,13.229,0.037
+3630.644,13.427,0.038
+3632.64616,13.236,0.039
+3634.68178,13.142,0.042
+3637.67901,13.203,0.039
+3640.69042,13.178,0.039
+3643.52314,13.492,0.04
+3646.60084,13.377,0.037
+3649.54879,13.109,0.053
+3655.52622,13.378,0.055
+3657.59891,12.982,0.065
+3659.63513,13.541,0.036
+3662.51946,13.137,0.044
+3664.54331,13.302,0.046
+3668.52358,13.368,0.035
+3670.57711,13.291,0.034
+3673.53419,13.316,0.037
+3675.60558,13.261,0.055
+3678.55411,13.274,0.049
+3700.53501,13.373,0.047
+3703.52505,13.36,0.04
+3793.8949,13.156,0.07
+3797.89717,13.359,0.057
+3804.88216,13.19,0.06
+3808.88257,13.074,0.044
+3812.88382,13.387,0.05
+3819.87713,13.022,0.087
+3823.85786,13.253,0.078
+3827.84953,13.267,0.08
+3831.84168,13.429,0.068
+3834.87089,13.32,0.067
+3857.8793,13.679,0.047
+3860.8273,13.238,0.055
+3863.80866,13.463,0.074
+3865.84155,13.239,0.078
+3867.81598,13.199,0.077
+3869.82153,13.281,0.042
+3874.80632,13.251,0.055
+3877.79377,13.235,0.043
+3880.86315,13.191,0.038
+3883.86175,13.075,0.079
+3887.79933,13.321,0.037
+3892.74013,13.215,0.048
+3894.73489,13.343,0.038
+3900.78606,13.248,0.046
+3902.78191,13.124,0.041
+3904.7999,13.319,0.041
+3906.85525,13.377,0.046
+3909.71921,13.133,0.071
+3913.74977,13.426,0.051
+4159.89093,13.357,0.046
+4163.8898,13.557,0.06
+4167.88095,13.035,0.077
+4179.88322,13.334,0.066
+4182.90901,13.4,0.048
+4191.85369,13.478,0.048
+4203.85933,13.384,0.06
+4207.88567,13.391,0.055
+4215.86587,13.486,0.039
+4228.88706,13.328,0.05
+4230.86994,13.21,0.041
+4233.80466,13.096,0.036
+4235.87083,13.327,0.056
+4247.77352,13.368,0.037
+4251.82102,13.157,0.044
+4256.81366,13.744,0.043
+4272.72091,13.433,0.042
+4274.75606,13.34,0.036
+4277.72019,13.242,0.034
+4283.74129,13.275,0.058
+4285.72947,13.158,0.043
+4289.72336,13.211,0.035
+4291.72547,13.486,0.035
+4293.71421,13.687,0.037
+4295.72697,13.354,0.035
+4299.69132,13.29,0.036
+4301.68244,13.187,0.045
+4303.68697,13.296,0.04
+4305.67826,13.17,0.037
+4307.65443,13.23,0.048
+4312.66217,13.348,0.039
+4315.66243,13.3,0.036
+4330.61068,13.278,0.036
+4332.60711,13.57,0.037
+4334.59904,13.495,0.032
+4338.61325,13.27,0.037
+4340.67356,13.584,0.037
+4342.6678,13.266,0.053
+4344.67186,13.456,0.041
+4346.66873,13.196,0.057
+4348.67379,13.216,0.061
+4350.68213,13.22,0.047
+4353.54385,13.455,0.047
+4355.63203,13.419,0.035
+4357.63592,13.464,0.039
+4359.67082,13.294,0.038
+4361.61975,13.445,0.043
+4365.52702,13.322,0.036
+4372.5185,13.23,0.043
+4375.54944,13.207,0.039
+4377.55668,13.597,0.047
+4379.5581,13.502,0.053
+4381.61027,13.31,0.041
+4383.6505,13.401,0.049
+4386.55108,12.93,0.046
+4388.53482,12.941,0.049
+4393.5195,13.346,0.048
+4400.61515,13.4,0.042
+4404.60026,13.303,0.036
+4408.53987,13.497,0.044
+4411.5635,13.421,0.038
+4422.54904,13.328,0.042
+4428.52228,13.437,0.045
+4431.53044,13.264,0.041
+4435.52149,13.197,0.044
+4521.89568,13.439,0.047
+4530.89645,13.354,0.055
+4537.89701,13.346,0.045
+4541.88924,13.423,0.049
+4545.88708,13.301,0.052
+4561.84422,13.3,0.055
+4564.88318,13.143,0.041
+4567.89831,13.26,0.044
+4571.83721,13.514,0.035
+4574.83014,13.286,0.042
+4577.86727,13.002,0.044
+4583.91369,13.222,0.034
+4587.80486,13.279,0.041
+4590.82466,13.238,0.047
+4593.81059,13.256,0.039
+4601.80901,13.313,0.043
+4611.84073,13.327,0.036
+4616.91278,13.141,0.039
+4623.74101,13.478,0.045
+4627.78573,13.308,0.04
+4629.76998,13.337,0.04
+4631.7834,13.265,0.035
+4633.76823,13.188,0.041
+4639.75778,13.469,0.034
+4641.76493,13.363,0.036
+4643.7593,13.235,0.041
+4645.79075,13.348,0.046
+4647.85553,13.259,0.088
+4650.68073,13.161,0.048
+4652.73206,13.178,0.038
+4654.72494,13.356,0.049
+4656.71356,13.34,0.042
+4660.65107,13.311,0.039
+4662.69692,13.287,0.041
+4665.69421,12.981,0.036
+4672.77724,13.231,0.063
+4675.78414,13.204,0.048
+4681.71257,13.59,0.046
+4683.76477,13.376,0.049
+4685.68374,13.331,0.04
+4687.66787,13.443,0.051
+4696.81322,13.241,0.04
+4698.71895,13.249,0.051
+4700.71952,13.526,0.055
+4705.52693,13.336,0.037
+4707.65148,13.241,0.06
+4709.75444,13.461,0.066
+4716.59223,13.292,0.045
+4720.63579,13.591,0.045
+4722.66344,13.349,0.047
+4725.6878,13.161,0.069
+4728.61777,13.416,0.04
+4730.65686,13.314,0.065
+4733.66063,13.392,0.048
+4738.60117,13.572,0.035
+4741.58001,13.405,0.059
+4743.59971,13.218,0.053
+4754.6438,13.143,0.06
+4757.55182,13.454,0.07
+4760.54749,13.231,0.063
+4763.54526,13.403,0.071
+4766.53046,13.56,0.062
+4768.60658,13.614,0.059
+4771.54135,13.369,0.056
+4775.53074,13.343,0.038
+4777.56782,13.365,0.043
+4780.56444,13.171,0.069
+4784.54265,13.231,0.069
+4787.53628,13.301,0.063
+4793.53567,13.177,0.069
+4797.5192,13.141,0.076
+4906.87954,13.368,0.06
+4917.87108,13.382,0.045
+4928.90721,13.277,0.054
+4935.87248,13.649,0.05
+4946.86532,13.448,0.048
+4949.84677,13.557,0.047
+4952.84301,13.51,0.058
+4968.79754,13.469,0.045
+4974.7902,13.4,0.051
+4985.74019,13.369,0.045
+4993.79549,13.311,0.042
+5006.85032,13.325,0.051
+5012.80173,13.474,0.049
+5014.74093,13.253,0.045
+5022.71146,13.374,0.044
+5037.6678,13.69,0.058
+5039.65209,13.671,0.041
+5041.63562,13.507,0.04
+5048.63806,13.369,0.042
+5063.67214,13.774,0.045
+5070.72112,13.205,0.068
+5075.58973,13.11,0.042
+5083.64578,13.203,0.05
+5089.72847,13.279,0.049
+5092.58166,13.315,0.042
+5098.54825,13.315,0.043
+5105.60764,13.249,0.048
+5124.58221,13.844,0.073
+5129.51864,13.36,0.044
```

### Comparing `cesium-0.9.7/cesium/features/tests/test_lomb_scargle_features.py` & `cesium-0.9.9/cesium/features/tests/test_lomb_scargle_features.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,231 +1,231 @@
-import numpy as np
-import numpy.testing as npt
-
-from cesium.features import lomb_scargle
-from cesium.features.graphs import LOMB_SCARGLE_FEATS
-from cesium.features.tests.util import (generate_features, irregular_random,
-                                        regular_periodic, irregular_periodic)
-
-
-# These values are chosen because they lie exactly on the grid of frequencies
-# searched by the Lomb Scargle optimization procedure
-WAVE_FREQS = np.array([5.3, 3.3, 2.1])
-
-
-def test_lomb_scargle_regular_single_freq():
-    """Test Lomb-Scargle model features on regularly-sampled periodic data with
-    one frequency/multiple harmonics. Estimated parameters should be very
-    accurate in this case.
-    """
-    frequencies = np.hstack((WAVE_FREQS[0], np.zeros(len(WAVE_FREQS)-1)))
-    amplitudes = np.zeros((len(frequencies),4))
-    amplitudes[0,:] = [8,4,2,1]
-    phase = 0.1
-    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
-    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
-
-    # Only test the first (true) frequency; the rest correspond to noise
-    npt.assert_allclose(all_lomb['freq1_freq'], frequencies[0])
-
-    # Hard-coded value from previous solution
-    npt.assert_allclose(0.001996007984, all_lomb['freq1_lambda'], rtol=1e-7)
-
-    for (i,j), amplitude in np.ndenumerate(amplitudes):
-        npt.assert_allclose(amplitude,
-                all_lomb['freq{}_amplitude{}'.format(i+1,j+1)], rtol=1e-2,
-                    atol=1e-2)
-
-    # Only test the first (true) frequency; the rest correspond to noise
-    for j in range(1, amplitudes.shape[1]):
-        npt.assert_allclose(phase*j*(-1**j),
-            all_lomb['freq1_rel_phase{}'.format(j+1)], rtol=1e-2, atol=1e-2)
-
-    # Frequency ratio not relevant since there is only; only test amplitude/signif
-    for i in [2,3]:
-        npt.assert_allclose(0., all_lomb['freq_amplitude_ratio_{}1'.format(i)], atol=1e-3)
-
-    npt.assert_array_less(10., all_lomb['freq1_signif'])
-
-    # Only one frequency, so this should explain basically all the variance
-    npt.assert_allclose(0., all_lomb['freq_varrat'], atol=5e-3)
-
-    # Exactly periodic, so the same minima/maxima should reoccur
-    npt.assert_allclose(0., all_lomb['freq_model_max_delta_mags'], atol=1e-6)
-    npt.assert_allclose(0., all_lomb['freq_model_min_delta_mags'], atol=1e-6)
-
-    # Linear trend should be zero since the signal is exactly sinusoidal
-    npt.assert_allclose(0., all_lomb['linear_trend'], atol=1e-4)
-
-    folded_times = times % 1./(frequencies[0]/2.)
-    sort_indices = np.argsort(folded_times)
-    folded_times = folded_times[sort_indices]
-    folded_values = values[sort_indices]
-
-    # Residuals from doubling period should be much higher
-    npt.assert_array_less(10., all_lomb['medperc90_2p_p'])
-
-    # Slopes should be the same for {un,}folded data; use unfolded for stability
-    slopes = np.diff(values) / np.diff(times)
-    npt.assert_allclose(np.percentile(slopes,10),
-        all_lomb['fold2P_slope_10percentile'], rtol=1e-2)
-    npt.assert_allclose(np.percentile(slopes,90),
-        all_lomb['fold2P_slope_90percentile'], rtol=1e-2)
-
-
-def test_lomb_scargle_irregular_single_freq():
-    """Test Lomb-Scargle model features on irregularly-sampled periodic data
-    with one frequency/multiple harmonics. More difficult than
-    regularly-sampled case, so we allow parameter estimates to be slightly
-    noisy.
-    """
-    frequencies = np.hstack((WAVE_FREQS[0], np.zeros(len(WAVE_FREQS)-1)))
-    amplitudes = np.zeros((len(WAVE_FREQS),4))
-    amplitudes[0,:] = [8,4,2,1]
-    phase = 0.1
-    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
-    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
-
-    # Only test the first (true) frequency; the rest correspond to noise
-    npt.assert_allclose(all_lomb['freq1_freq'], frequencies[0], rtol=1e-2)
-
-    # Only test first frequency here; noise gives non-zero amplitudes for residuals
-    for j in range(amplitudes.shape[1]):
-        npt.assert_allclose(amplitudes[0,j],
-                all_lomb['freq1_amplitude{}'.format(j+1)], rtol=5e-2, atol=5e-2)
-        if j >= 1:
-            npt.assert_allclose(phase*j*(-1**j),
-                all_lomb['freq1_rel_phase{}'.format(j+1)], rtol=1e-1, atol=1e-1)
-
-    npt.assert_array_less(10., all_lomb['freq1_signif'])
-
-    # Only one frequency, so this should explain basically all the variance
-    npt.assert_allclose(0., all_lomb['freq_varrat'], atol=5e-3)
-
-    npt.assert_allclose(-np.mean(values), all_lomb['freq_y_offset'], rtol=5e-2)
-
-
-def test_lomb_scargle_period_folding():
-    """Tests for features derived from fitting a Lomb-Scargle periodic model
-    and period-folding the data by the estimated period.
-    """
-    frequencies = np.hstack((WAVE_FREQS[0], np.zeros(len(WAVE_FREQS)-1)))
-    amplitudes = np.zeros((len(WAVE_FREQS),4))
-    amplitudes[0,:] = [8,4,2,1]
-    phase = 0.1
-    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
-    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
-
-    # Folding is numerically unstable so we need to use the exact fitted frequency
-    freq_est = all_lomb['freq1_freq']
-    # Fold by 1*period
-    fold1ed_times = (times-times[0]) % (1./freq_est)
-    sort_indices = np.argsort(fold1ed_times)
-    fold1ed_times = fold1ed_times[sort_indices]
-    fold1ed_values = values[sort_indices]
-    # Fold by 2*period
-    fold2ed_times = (times-times[0]) % (2./freq_est)
-    sort_indices = np.argsort(fold2ed_times)
-    fold2ed_times = fold2ed_times[sort_indices]
-    fold2ed_values = values[sort_indices]
-
-    npt.assert_allclose(np.sum(np.diff(fold2ed_values)**2) /
-            np.sum(np.diff(values)**2), all_lomb['p2p_scatter_2praw'])
-    npt.assert_allclose(np.sum(np.diff(values)**2) / ((len(values) - 1) *
-        np.var(values)), all_lomb['p2p_ssqr_diff_over_var'])
-    npt.assert_allclose(np.median(np.abs(np.diff(values))) /
-            np.median(np.abs(values-np.median(values))),
-            all_lomb['p2p_scatter_over_mad'])
-    npt.assert_allclose(np.median(np.abs(np.diff(fold1ed_values))) /
-                        np.median(np.abs(values-np.median(values))),
-                        all_lomb['p2p_scatter_pfold_over_mad'])
-
-
-def test_lomb_scargle_regular_multi_freq():
-    """Test Lomb-Scargle model features on regularly-sampled periodic data with
-    multiple frequencies, each with a single harmonic. Estimated parameters
-    should be very accurate in this case.
-    """
-    frequencies = WAVE_FREQS
-    amplitudes = np.zeros((len(frequencies),4))
-    amplitudes[:,0] = [4,2,1]
-    phase = 0.1
-    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
-    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
-
-    for i, frequency in enumerate(frequencies):
-        npt.assert_allclose(frequency,
-                all_lomb['freq{}_freq'.format(i+1)])
-
-    for (i,j), amplitude in np.ndenumerate(amplitudes):
-        npt.assert_allclose(amplitude,
-                all_lomb['freq{}_amplitude{}'.format(i+1,j+1)],
-                rtol=5e-2, atol=5e-2)
-
-    for i in [2,3]:
-        npt.assert_allclose(amplitudes[i-1,0] / amplitudes[0,0],
-                all_lomb['freq_amplitude_ratio_{}1'.format(i)], atol=2e-2)
-
-    npt.assert_array_less(10., all_lomb['freq1_signif'])
-
-
-def test_lomb_scargle_irregular_multi_freq():
-    """Test Lomb-Scargle model features on irregularly-sampled periodic data
-    with multiple frequencies, each with a single harmonic. More difficult than
-    regularly-sampled case, so we allow parameter estimates to be slightly
-    noisy.
-    """
-    frequencies = WAVE_FREQS
-    amplitudes = np.zeros((len(frequencies),4))
-    amplitudes[:,0] = [4,2,1]
-    phase = 0.1
-    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
-    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
-
-    for i, frequency in enumerate(frequencies):
-        npt.assert_allclose(frequency,
-                all_lomb['freq{}_freq'.format(i+1)], rtol=1e-2)
-
-    for (i,j), amplitude in np.ndenumerate(amplitudes):
-        npt.assert_allclose(amplitude,
-                all_lomb['freq{}_amplitude{}'.format(i+1,j+1)],
-                rtol=1e-1, atol=1e-1)
-
-    for i in [2,3]:
-        npt.assert_allclose(amplitudes[i-1,0] / amplitudes[0,0],
-                all_lomb['freq_amplitude_ratio_{}1'.format(i)], atol=2e-2)
-        npt.assert_allclose(frequencies[i-1] / frequencies[0],
-                all_lomb['freq_frequency_ratio_{}1'.format(i)], atol=5e-2)
-
-    npt.assert_array_less(10., all_lomb['freq1_signif'])
-
-
-def test_lomb_scargle_linear_trend():
-    frequencies = np.hstack((WAVE_FREQS[0], np.zeros(len(WAVE_FREQS)-1)))
-    amplitudes = np.zeros((len(WAVE_FREQS),4))
-    amplitudes[0,:] = [8,4,2,1]
-    phase = 0.1
-    slope = 0.5
-
-    # Estimated trend should be almost exact for noiseless data
-    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
-    values += slope * times
-    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
-    npt.assert_allclose(slope, all_lomb['linear_trend'], rtol=1e-3)
-
-    # Should still be close to true trend when noise is present
-    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
-    values += slope * times
-    values += np.random.normal(scale=1e-3, size=len(times))
-    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
-    npt.assert_allclose(slope, all_lomb['linear_trend'], rtol=1e-1)
-
-
-def test_scatter_res_raw():
-    """Test feature that measures scatter of Lomb-Scargle residuals."""
-    times, values, errors = irregular_random()
-    lomb_model = lomb_scargle.lomb_scargle_model(times, values, errors)
-    residuals = values - lomb_model['freq_fits'][0]['model']
-    resid_mad = np.median(np.abs(residuals - np.median(residuals)))
-    value_mad = np.median(np.abs(values - np.median(values)))
-    f = generate_features(times, values, errors, ['scatter_res_raw'])
-    npt.assert_allclose(f['scatter_res_raw'], resid_mad / value_mad, atol=3e-2)
+import numpy as np
+import numpy.testing as npt
+
+from cesium.features import lomb_scargle
+from cesium.features.graphs import LOMB_SCARGLE_FEATS
+from cesium.features.tests.util import (generate_features, irregular_random,
+                                        regular_periodic, irregular_periodic)
+
+
+# These values are chosen because they lie exactly on the grid of frequencies
+# searched by the Lomb Scargle optimization procedure
+WAVE_FREQS = np.array([5.3, 3.3, 2.1])
+
+
+def test_lomb_scargle_regular_single_freq():
+    """Test Lomb-Scargle model features on regularly-sampled periodic data with
+    one frequency/multiple harmonics. Estimated parameters should be very
+    accurate in this case.
+    """
+    frequencies = np.hstack((WAVE_FREQS[0], np.zeros(len(WAVE_FREQS)-1)))
+    amplitudes = np.zeros((len(frequencies),4))
+    amplitudes[0,:] = [8,4,2,1]
+    phase = 0.1
+    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
+    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
+
+    # Only test the first (true) frequency; the rest correspond to noise
+    npt.assert_allclose(all_lomb['freq1_freq'], frequencies[0])
+
+    # Hard-coded value from previous solution
+    npt.assert_allclose(0.001996007984, all_lomb['freq1_lambda'], rtol=1e-7)
+
+    for (i,j), amplitude in np.ndenumerate(amplitudes):
+        npt.assert_allclose(amplitude,
+                all_lomb['freq{}_amplitude{}'.format(i+1,j+1)], rtol=1e-2,
+                    atol=1e-2)
+
+    # Only test the first (true) frequency; the rest correspond to noise
+    for j in range(1, amplitudes.shape[1]):
+        npt.assert_allclose(phase*j*(-1**j),
+            all_lomb['freq1_rel_phase{}'.format(j+1)], rtol=1e-2, atol=1e-2)
+
+    # Frequency ratio not relevant since there is only; only test amplitude/signif
+    for i in [2,3]:
+        npt.assert_allclose(0., all_lomb['freq_amplitude_ratio_{}1'.format(i)], atol=1e-3)
+
+    npt.assert_array_less(10., all_lomb['freq1_signif'])
+
+    # Only one frequency, so this should explain basically all the variance
+    npt.assert_allclose(0., all_lomb['freq_varrat'], atol=5e-3)
+
+    # Exactly periodic, so the same minima/maxima should reoccur
+    npt.assert_allclose(0., all_lomb['freq_model_max_delta_mags'], atol=1e-6)
+    npt.assert_allclose(0., all_lomb['freq_model_min_delta_mags'], atol=1e-6)
+
+    # Linear trend should be zero since the signal is exactly sinusoidal
+    npt.assert_allclose(0., all_lomb['linear_trend'], atol=1e-4)
+
+    folded_times = times % 1./(frequencies[0]/2.)
+    sort_indices = np.argsort(folded_times)
+    folded_times = folded_times[sort_indices]
+    folded_values = values[sort_indices]
+
+    # Residuals from doubling period should be much higher
+    npt.assert_array_less(10., all_lomb['medperc90_2p_p'])
+
+    # Slopes should be the same for {un,}folded data; use unfolded for stability
+    slopes = np.diff(values) / np.diff(times)
+    npt.assert_allclose(np.percentile(slopes,10),
+        all_lomb['fold2P_slope_10percentile'], rtol=1e-2)
+    npt.assert_allclose(np.percentile(slopes,90),
+        all_lomb['fold2P_slope_90percentile'], rtol=1e-2)
+
+
+def test_lomb_scargle_irregular_single_freq():
+    """Test Lomb-Scargle model features on irregularly-sampled periodic data
+    with one frequency/multiple harmonics. More difficult than
+    regularly-sampled case, so we allow parameter estimates to be slightly
+    noisy.
+    """
+    frequencies = np.hstack((WAVE_FREQS[0], np.zeros(len(WAVE_FREQS)-1)))
+    amplitudes = np.zeros((len(WAVE_FREQS),4))
+    amplitudes[0,:] = [8,4,2,1]
+    phase = 0.1
+    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
+    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
+
+    # Only test the first (true) frequency; the rest correspond to noise
+    npt.assert_allclose(all_lomb['freq1_freq'], frequencies[0], rtol=1e-2)
+
+    # Only test first frequency here; noise gives non-zero amplitudes for residuals
+    for j in range(amplitudes.shape[1]):
+        npt.assert_allclose(amplitudes[0,j],
+                all_lomb['freq1_amplitude{}'.format(j+1)], rtol=5e-2, atol=5e-2)
+        if j >= 1:
+            npt.assert_allclose(phase*j*(-1**j),
+                all_lomb['freq1_rel_phase{}'.format(j+1)], rtol=1e-1, atol=1e-1)
+
+    npt.assert_array_less(10., all_lomb['freq1_signif'])
+
+    # Only one frequency, so this should explain basically all the variance
+    npt.assert_allclose(0., all_lomb['freq_varrat'], atol=5e-3)
+
+    npt.assert_allclose(-np.mean(values), all_lomb['freq_y_offset'], rtol=5e-2)
+
+
+def test_lomb_scargle_period_folding():
+    """Tests for features derived from fitting a Lomb-Scargle periodic model
+    and period-folding the data by the estimated period.
+    """
+    frequencies = np.hstack((WAVE_FREQS[0], np.zeros(len(WAVE_FREQS)-1)))
+    amplitudes = np.zeros((len(WAVE_FREQS),4))
+    amplitudes[0,:] = [8,4,2,1]
+    phase = 0.1
+    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
+    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
+
+    # Folding is numerically unstable so we need to use the exact fitted frequency
+    freq_est = all_lomb['freq1_freq']
+    # Fold by 1*period
+    fold1ed_times = (times-times[0]) % (1./freq_est)
+    sort_indices = np.argsort(fold1ed_times)
+    fold1ed_times = fold1ed_times[sort_indices]
+    fold1ed_values = values[sort_indices]
+    # Fold by 2*period
+    fold2ed_times = (times-times[0]) % (2./freq_est)
+    sort_indices = np.argsort(fold2ed_times)
+    fold2ed_times = fold2ed_times[sort_indices]
+    fold2ed_values = values[sort_indices]
+
+    npt.assert_allclose(np.sum(np.diff(fold2ed_values)**2) /
+            np.sum(np.diff(values)**2), all_lomb['p2p_scatter_2praw'])
+    npt.assert_allclose(np.sum(np.diff(values)**2) / ((len(values) - 1) *
+        np.var(values)), all_lomb['p2p_ssqr_diff_over_var'])
+    npt.assert_allclose(np.median(np.abs(np.diff(values))) /
+            np.median(np.abs(values-np.median(values))),
+            all_lomb['p2p_scatter_over_mad'])
+    npt.assert_allclose(np.median(np.abs(np.diff(fold1ed_values))) /
+                        np.median(np.abs(values-np.median(values))),
+                        all_lomb['p2p_scatter_pfold_over_mad'])
+
+
+def test_lomb_scargle_regular_multi_freq():
+    """Test Lomb-Scargle model features on regularly-sampled periodic data with
+    multiple frequencies, each with a single harmonic. Estimated parameters
+    should be very accurate in this case.
+    """
+    frequencies = WAVE_FREQS
+    amplitudes = np.zeros((len(frequencies),4))
+    amplitudes[:,0] = [4,2,1]
+    phase = 0.1
+    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
+    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
+
+    for i, frequency in enumerate(frequencies):
+        npt.assert_allclose(frequency,
+                all_lomb['freq{}_freq'.format(i+1)])
+
+    for (i,j), amplitude in np.ndenumerate(amplitudes):
+        npt.assert_allclose(amplitude,
+                all_lomb['freq{}_amplitude{}'.format(i+1,j+1)],
+                rtol=5e-2, atol=5e-2)
+
+    for i in [2,3]:
+        npt.assert_allclose(amplitudes[i-1,0] / amplitudes[0,0],
+                all_lomb['freq_amplitude_ratio_{}1'.format(i)], atol=2e-2)
+
+    npt.assert_array_less(10., all_lomb['freq1_signif'])
+
+
+def test_lomb_scargle_irregular_multi_freq():
+    """Test Lomb-Scargle model features on irregularly-sampled periodic data
+    with multiple frequencies, each with a single harmonic. More difficult than
+    regularly-sampled case, so we allow parameter estimates to be slightly
+    noisy.
+    """
+    frequencies = WAVE_FREQS
+    amplitudes = np.zeros((len(frequencies),4))
+    amplitudes[:,0] = [4,2,1]
+    phase = 0.1
+    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
+    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
+
+    for i, frequency in enumerate(frequencies):
+        npt.assert_allclose(frequency,
+                all_lomb['freq{}_freq'.format(i+1)], rtol=1e-2)
+
+    for (i,j), amplitude in np.ndenumerate(amplitudes):
+        npt.assert_allclose(amplitude,
+                all_lomb['freq{}_amplitude{}'.format(i+1,j+1)],
+                rtol=1e-1, atol=1e-1)
+
+    for i in [2,3]:
+        npt.assert_allclose(amplitudes[i-1,0] / amplitudes[0,0],
+                all_lomb['freq_amplitude_ratio_{}1'.format(i)], atol=2e-2)
+        npt.assert_allclose(frequencies[i-1] / frequencies[0],
+                all_lomb['freq_frequency_ratio_{}1'.format(i)], atol=5e-2)
+
+    npt.assert_array_less(10., all_lomb['freq1_signif'])
+
+
+def test_lomb_scargle_linear_trend():
+    frequencies = np.hstack((WAVE_FREQS[0], np.zeros(len(WAVE_FREQS)-1)))
+    amplitudes = np.zeros((len(WAVE_FREQS),4))
+    amplitudes[0,:] = [8,4,2,1]
+    phase = 0.1
+    slope = 0.5
+
+    # Estimated trend should be almost exact for noiseless data
+    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
+    values += slope * times
+    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
+    npt.assert_allclose(slope, all_lomb['linear_trend'], rtol=1e-3)
+
+    # Should still be close to true trend when noise is present
+    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
+    values += slope * times
+    values += np.random.normal(scale=1e-3, size=len(times))
+    all_lomb = generate_features(times, values, errors, LOMB_SCARGLE_FEATS)
+    npt.assert_allclose(slope, all_lomb['linear_trend'], rtol=1e-1)
+
+
+def test_scatter_res_raw():
+    """Test feature that measures scatter of Lomb-Scargle residuals."""
+    times, values, errors = irregular_random()
+    lomb_model = lomb_scargle.lomb_scargle_model(times, values, errors)
+    residuals = values - lomb_model['freq_fits'][0]['model']
+    resid_mad = np.median(np.abs(residuals - np.median(residuals)))
+    value_mad = np.median(np.abs(values - np.median(values)))
+    f = generate_features(times, values, errors, ['scatter_res_raw'])
+    npt.assert_allclose(f['scatter_res_raw'], resid_mad / value_mad, atol=3e-2)
```

### Comparing `cesium-0.9.7/cesium/features/tests/test_graphs.py` & `cesium-0.9.9/cesium/features/tests/test_graphs.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,46 +1,46 @@
-import os
-import numpy as np
-import numpy.testing as npt
-
-from cesium import data_management
-from cesium.features import graphs
-from cesium.features.tests.util import generate_features
-
-
-# Fixed set of features w/ known values
-SCIENCE_FEATS = graphs.GENERAL_FEATS + graphs.LOMB_SCARGLE_FEATS
-
-
-def test_feature_generation():
-    """Compare generated features to reference values."""
-    this_dir = os.path.join(os.path.dirname(__file__))
-    test_files = [
-            os.path.join(this_dir, 'data/257141.dat'),
-            os.path.join(this_dir, 'data/245486.dat'),
-            os.path.join(this_dir, 'data/247327.dat'),
-            ]
-    features_extracted = None
-    values_computed = None
-    for i, ts_data_file_path in enumerate(test_files):
-        t, m, e = data_management.parse_ts_data(ts_data_file_path)
-        features = generate_features(t, m, e, SCIENCE_FEATS)
-        sorted_features = sorted(features.items())
-        if features_extracted is None:
-            features_extracted = [f[0] for f in sorted_features]
-            values_computed = np.zeros((len(test_files),
-                len(features_extracted)))
-        values_computed[i,:] = [f[1] for f in sorted_features]
-
-    def features_from_csv(filename):
-        with open(filename) as f:
-            feature_names = f.readline().strip().split(",")
-            feature_values = np.loadtxt(f, delimiter=',')
-
-        return feature_names, feature_values
-
-    this_dir = os.path.join(os.path.dirname(__file__))
-    features_expected, values_expected = features_from_csv(
-        os.path.join(this_dir, "data/expected_features.csv"))
-
-    npt.assert_equal(features_extracted, features_expected)
-    npt.assert_array_almost_equal(values_computed, values_expected)
+import os
+import numpy as np
+import numpy.testing as npt
+
+from cesium import data_management
+from cesium.features import graphs
+from cesium.features.tests.util import generate_features
+
+
+# Fixed set of features w/ known values
+SCIENCE_FEATS = graphs.GENERAL_FEATS + graphs.LOMB_SCARGLE_FEATS
+
+
+def test_feature_generation():
+    """Compare generated features to reference values."""
+    this_dir = os.path.join(os.path.dirname(__file__))
+    test_files = [
+            os.path.join(this_dir, 'data/257141.dat'),
+            os.path.join(this_dir, 'data/245486.dat'),
+            os.path.join(this_dir, 'data/247327.dat'),
+            ]
+    features_extracted = None
+    values_computed = None
+    for i, ts_data_file_path in enumerate(test_files):
+        t, m, e = data_management.parse_ts_data(ts_data_file_path)
+        features = generate_features(t, m, e, SCIENCE_FEATS)
+        sorted_features = sorted(features.items())
+        if features_extracted is None:
+            features_extracted = [f[0] for f in sorted_features]
+            values_computed = np.zeros((len(test_files),
+                len(features_extracted)))
+        values_computed[i,:] = [f[1] for f in sorted_features]
+
+    def features_from_csv(filename):
+        with open(filename) as f:
+            feature_names = f.readline().strip().split(",")
+            feature_values = np.loadtxt(f, delimiter=',')
+
+        return feature_names, feature_values
+
+    this_dir = os.path.join(os.path.dirname(__file__))
+    features_expected, values_expected = features_from_csv(
+        os.path.join(this_dir, "data/expected_features.csv"))
+
+    npt.assert_equal(features_extracted, features_expected)
+    npt.assert_array_almost_equal(values_computed, values_expected)
```

### Comparing `cesium-0.9.7/cesium/features/tests/test_general_features.py` & `cesium-0.9.9/cesium/features/tests/test_general_features.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,266 +1,266 @@
-import numpy as np
-import numpy.testing as npt
-
-import time
-import os
-import shutil
-import glob
-
-from cesium.features.tests.util import (generate_features, irregular_random,
-                                        regular_periodic, irregular_periodic)
-
-
-def test_amplitude():
-    """Test features related to amplitude/magnitude percentiles."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['amplitude'])
-    npt.assert_allclose(f['amplitude'], (max(values) - min(values)) /2.)
-
-    f = generate_features(times, values, errors, ['percent_amplitude'])
-    max_scaled = 10**(-0.4 * max(values))
-    min_scaled = 10**(-0.4 * min(values))
-    med_scaled = 10**(-0.4 * np.median(values))
-    peak_from_median = max(abs((max_scaled - med_scaled) / med_scaled),
-            abs((min_scaled - med_scaled)) / med_scaled)
-    npt.assert_allclose(f['percent_amplitude'], peak_from_median, rtol=5e-4)
-
-    f = generate_features(times, values, errors, ['percent_difference_flux_percentile'])
-    band_offset = 13.72
-    w_m2 = 10**(-0.4*(values+band_offset)-3)  # 1 erg/s/cm^2 = 10^-3 w/m^2
-    npt.assert_allclose(f['percent_difference_flux_percentile'], np.diff(
-        np.percentile(w_m2, [5, 95])) / np.median(w_m2))
-
-    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid20'])
-    npt.assert_allclose(f['flux_percentile_ratio_mid20'],
-                            np.diff(np.percentile(w_m2, [40, 60])) /
-                            np.diff(np.percentile(w_m2, [5, 95])))
-
-    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid35'])
-    npt.assert_allclose(f['flux_percentile_ratio_mid35'],
-                            np.diff(np.percentile(w_m2, [32.5, 67.5])) /
-                            np.diff(np.percentile(w_m2, [5, 95])))
-
-    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid50'])
-    npt.assert_allclose(f['flux_percentile_ratio_mid50'],
-                            np.diff(np.percentile(w_m2, [25, 75])) /
-                            np.diff(np.percentile(w_m2, [5, 95])))
-
-    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid65'])
-    npt.assert_allclose(f['flux_percentile_ratio_mid65'],
-                            np.diff(np.percentile(w_m2, [17.5, 82.5])) /
-                            np.diff(np.percentile(w_m2, [5, 95])))
-
-    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid80'])
-    npt.assert_allclose(f['flux_percentile_ratio_mid80'],
-                            np.diff(np.percentile(w_m2, [10, 90])) /
-                            np.diff(np.percentile(w_m2, [5, 95])))
-
-
-# AR-IS features are currently ignored
-"""
-def test_ar_is():
-    times = np.linspace(0, 500, 201)
-    theta = 0.95
-    sigma = 0.0
-    values = theta ** (times/250.) + sigma*np.random.randn(len(times))
-    errors = 1e-4*np.ones(len(times))
-
-    f = generate_features(times, values, errors, ['ar_is_theta'])
-    npt.assert_allclose(f['ar_is_theta'], theta, atol=3e-2)
-
-    f = generate_features(times, values, errors, ['ar_is_sigma'])
-    npt.assert_allclose(f['ar_is_sigma'], sigma, atol=1e-5)
-
-# Hard-coded values from reference data set
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['ar_is_theta'])
-    npt.assert_allclose(f['ar_is_theta'], 5.9608609865491405e-06, rtol=1e-3)
-    f = generate_features(times, values, errors, ['ar_is_sigma'])
-    npt.assert_allclose(f['ar_is_sigma'], 1.6427095072108497, rtol=1e-3)
-"""
-
-
-# The smoothed model fit in lcmodel seems insanely oversmoothed; in general
-# all these extractors are a complete mess, and are currently ignored
-"""
-def test_lcmodel():
-    frequencies = np.hstack((1., np.zeros(len(WAVE_FREQS)-1)))
-    amplitudes = np.zeros((len(frequencies),4))
-    amplitudes[0,:] = [2,0,0,0]
-    phase = 0.0
-    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
-
-    f = generate_features(times, values, errors, ['lcmodel'])
-    lc_feats = f['lcmodel']
-
-    # Median is zero for this data, so crossing median = changing sign
-    incr_median_crosses = sum((np.abs(np.diff(np.sign(values))) > 1) &
-                             (np.diff(values) > 0))
-    npt.assert_allclose(lc_feats['median_n_per_day'], (incr_median_crosses+1) /
-                        (max(times)-min(times)))
-"""
-
-
-def test_lomb_scargle_fast_regular():
-    """Test gatspy's fast Lomb-Scargle period estimate on regularly-sampled
-    periodic data.
-
-    Note: this model fits only a single sinusoid with no additional harmonics,
-    so we use only 1 frequency and 1 amplitude to generate test data.
-    """
-    frequencies = np.array([4])
-    amplitudes = np.array([[1]])
-    phase = 0.1
-    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
-    f = generate_features(times, values, errors, ['period_fast'])
-
-    npt.assert_allclose(f['period_fast'], 1. / frequencies[0], rtol=5e-4)
-
-
-def test_lomb_scargle_fast_irregular():
-    """Test gatspy's fast Lomb-Scargle period estimate on irregularly-sampled
-    periodic data.
-
-    Note: this model fits only a single sinusoid with no additional harmonics,
-    so we use only 1 frequency and 1 amplitude to generate test data.
-    """
-    frequencies = np.array([4])
-    amplitudes = np.array([[1]])
-    phase = 0.1
-    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
-    f = generate_features(times, values, errors, ['period_fast'])
-
-    npt.assert_allclose(f['period_fast'], 1. / frequencies[0], rtol=3e-2)
-
-
-def test_max():
-    """Test maximum value feature."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['maximum'])
-    npt.assert_equal(f['maximum'], max(values))
-
-
-def test_max_slope():
-    """Test maximum slope feature, which finds the INDEX of the largest slope."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['max_slope'])
-    slopes = np.diff(values) / np.diff(times)
-    npt.assert_allclose(f['max_slope'], np.max(np.abs(slopes)))
-
-
-def test_median_absolute_deviation():
-    """Test median absolute deviation (from the median) feature."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['median_absolute_deviation'])
-    npt.assert_allclose(f['median_absolute_deviation'], np.median(np.abs(values -
-        np.median(values))))
-
-
-def test_percent_close_to_median():
-    """Test feature which finds the percentage of points near the median value."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors,
-            ['percent_close_to_median'])
-    amplitude = (max(values) - min(values)) / 2.
-    within_buffer = np.abs(values - np.median(values)) < 0.2*amplitude
-    npt.assert_allclose(f['percent_close_to_median'], np.mean(within_buffer))
-
-
-def test_median():
-    """Test median value feature."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['median'])
-    npt.assert_allclose(f['median'], np.median(values))
-
-
-def test_min():
-    """Test minimum value feature."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['minimum'])
-    npt.assert_equal(f['minimum'], min(values))
-
-
-# These features are currently ignored
-"""
-def test_phase_dispersion():
-# Frequency chosen to lie on the relevant search grid
-    frequencies = np.hstack((5.36, np.zeros(len(WAVE_FREQS)-1)))
-    amplitudes = np.zeros((len(frequencies),4))
-    amplitudes[0,:] = [1,0,0,0]
-    phase = 0.1
-    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
-    f = generate_features(times, values, errors, ['phase_dispersion_freq0'])
-    npt.assert_allclose(f['phase_dispersion_freq0'], frequencies[0])
-
-    f = generate_features(times, values, errors, ['freq1_freq'])
-    lomb_freq = f['freq1_freq']
-    f = generate_features(times, values, errors, ['ratio_PDM_LS_freq0'])
-    npt.assert_allclose(f['ratio_PDM_LS_freq0'], frequencies[0]/lomb_freq)
-"""
-
-
-def test_qso_features():
-    """Test features which measure fit of QSO model.
-
-    Reference values are hard-coded values from previous implementation; not sure
-    of examples with a closed-form solution.
-    """
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors,
-            ['qso_log_chi2_qsonu', 'qso_log_chi2nuNULL_chi2nu'])
-    npt.assert_allclose(f['qso_log_chi2_qsonu'], 6.9844064754)
-    npt.assert_allclose(f['qso_log_chi2nuNULL_chi2nu'], -0.456526327522)
-
-
-def test_skew():
-    """Test statistical skew feature."""
-    from scipy import stats
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['skew'])
-    npt.assert_allclose(f['skew'], stats.skew(values))
-
-
-def test_std():
-    """Test standard deviation feature."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['std'])
-    npt.assert_allclose(f['std'], np.std(values))
-
-
-def test_stetson():
-    """Test Stetson variability features."""
-    times, values, errors = irregular_random(size=201)
-    f = generate_features(times, values, errors, ['stetson_j'])
-    # Stetson mean approximately equal to standard mean for large inputs
-    dists = np.sqrt(float(len(values)) / (len(values) - 1.)) * (values - np.mean(values)) / 0.1
-    npt.assert_allclose(f['stetson_j'],
-                        np.mean(np.sign(dists**2-1)*np.sqrt(np.abs(dists**2-1))),
-                        rtol=1e-2)
-    # Stetson_j should be somewhat close to (scaled) variance for normal data
-    npt.assert_allclose(f['stetson_j']*0.1, np.var(values), rtol=2e-1)
-    # Hard-coded original value
-    npt.assert_allclose(f['stetson_j'], 7.591347175195703)
-
-    f = generate_features(times, values, errors, ['stetson_k'])
-    npt.assert_allclose(f['stetson_k'], 1./0.798 * np.mean(np.abs(dists)) / np.sqrt(np.mean(dists**2)), rtol=5e-4)
-    # Hard-coded original value
-    npt.assert_allclose(f['stetson_k'], 1.0087218792719013)
-
-
-def test_weighted_average():
-    """Test weighted average and distance from weighted average features."""
-    times, values, errors = irregular_random()
-    f = generate_features(times, values, errors, ['weighted_average'])
-    weighted_avg = np.average(values, weights=1. / (errors**2))
-    weighted_var = np.average((values - weighted_avg)**2,
-                              weights=1. / (errors**2))
-    npt.assert_allclose(f['weighted_average'], weighted_avg)
-
-    dists_from_weighted_avg = values - weighted_avg
-    stds_from_weighted_avg = (dists_from_weighted_avg /
-            np.sqrt(weighted_var))
-
-    f = generate_features(times, values, errors,
-                                      ['percent_beyond_1_std'])
-    npt.assert_equal(f['percent_beyond_1_std'],
-                     np.mean(np.abs(stds_from_weighted_avg) > 1.))
+import numpy as np
+import numpy.testing as npt
+
+import time
+import os
+import shutil
+import glob
+
+from cesium.features.tests.util import (generate_features, irregular_random,
+                                        regular_periodic, irregular_periodic)
+
+
+def test_amplitude():
+    """Test features related to amplitude/magnitude percentiles."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['amplitude'])
+    npt.assert_allclose(f['amplitude'], (max(values) - min(values)) /2.)
+
+    f = generate_features(times, values, errors, ['percent_amplitude'])
+    max_scaled = 10**(-0.4 * max(values))
+    min_scaled = 10**(-0.4 * min(values))
+    med_scaled = 10**(-0.4 * np.median(values))
+    peak_from_median = max(abs((max_scaled - med_scaled) / med_scaled),
+            abs((min_scaled - med_scaled)) / med_scaled)
+    npt.assert_allclose(f['percent_amplitude'], peak_from_median, rtol=5e-4)
+
+    f = generate_features(times, values, errors, ['percent_difference_flux_percentile'])
+    band_offset = 13.72
+    w_m2 = 10**(-0.4*(values+band_offset)-3)  # 1 erg/s/cm^2 = 10^-3 w/m^2
+    npt.assert_allclose(f['percent_difference_flux_percentile'], np.diff(
+        np.percentile(w_m2, [5, 95])) / np.median(w_m2))
+
+    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid20'])
+    npt.assert_allclose(f['flux_percentile_ratio_mid20'],
+                            np.diff(np.percentile(w_m2, [40, 60])) /
+                            np.diff(np.percentile(w_m2, [5, 95])))
+
+    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid35'])
+    npt.assert_allclose(f['flux_percentile_ratio_mid35'],
+                            np.diff(np.percentile(w_m2, [32.5, 67.5])) /
+                            np.diff(np.percentile(w_m2, [5, 95])))
+
+    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid50'])
+    npt.assert_allclose(f['flux_percentile_ratio_mid50'],
+                            np.diff(np.percentile(w_m2, [25, 75])) /
+                            np.diff(np.percentile(w_m2, [5, 95])))
+
+    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid65'])
+    npt.assert_allclose(f['flux_percentile_ratio_mid65'],
+                            np.diff(np.percentile(w_m2, [17.5, 82.5])) /
+                            np.diff(np.percentile(w_m2, [5, 95])))
+
+    f = generate_features(times, values, errors, ['flux_percentile_ratio_mid80'])
+    npt.assert_allclose(f['flux_percentile_ratio_mid80'],
+                            np.diff(np.percentile(w_m2, [10, 90])) /
+                            np.diff(np.percentile(w_m2, [5, 95])))
+
+
+# AR-IS features are currently ignored
+"""
+def test_ar_is():
+    times = np.linspace(0, 500, 201)
+    theta = 0.95
+    sigma = 0.0
+    values = theta ** (times/250.) + sigma*np.random.randn(len(times))
+    errors = 1e-4*np.ones(len(times))
+
+    f = generate_features(times, values, errors, ['ar_is_theta'])
+    npt.assert_allclose(f['ar_is_theta'], theta, atol=3e-2)
+
+    f = generate_features(times, values, errors, ['ar_is_sigma'])
+    npt.assert_allclose(f['ar_is_sigma'], sigma, atol=1e-5)
+
+# Hard-coded values from reference data set
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['ar_is_theta'])
+    npt.assert_allclose(f['ar_is_theta'], 5.9608609865491405e-06, rtol=1e-3)
+    f = generate_features(times, values, errors, ['ar_is_sigma'])
+    npt.assert_allclose(f['ar_is_sigma'], 1.6427095072108497, rtol=1e-3)
+"""
+
+
+# The smoothed model fit in lcmodel seems insanely oversmoothed; in general
+# all these extractors are a complete mess, and are currently ignored
+"""
+def test_lcmodel():
+    frequencies = np.hstack((1., np.zeros(len(WAVE_FREQS)-1)))
+    amplitudes = np.zeros((len(frequencies),4))
+    amplitudes[0,:] = [2,0,0,0]
+    phase = 0.0
+    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
+
+    f = generate_features(times, values, errors, ['lcmodel'])
+    lc_feats = f['lcmodel']
+
+    # Median is zero for this data, so crossing median = changing sign
+    incr_median_crosses = sum((np.abs(np.diff(np.sign(values))) > 1) &
+                             (np.diff(values) > 0))
+    npt.assert_allclose(lc_feats['median_n_per_day'], (incr_median_crosses+1) /
+                        (max(times)-min(times)))
+"""
+
+
+def test_lomb_scargle_fast_regular():
+    """Test gatspy's fast Lomb-Scargle period estimate on regularly-sampled
+    periodic data.
+
+    Note: this model fits only a single sinusoid with no additional harmonics,
+    so we use only 1 frequency and 1 amplitude to generate test data.
+    """
+    frequencies = np.array([4])
+    amplitudes = np.array([[1]])
+    phase = 0.1
+    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
+    f = generate_features(times, values, errors, ['period_fast'])
+
+    npt.assert_allclose(f['period_fast'], 1. / frequencies[0], rtol=5e-4)
+
+
+def test_lomb_scargle_fast_irregular():
+    """Test gatspy's fast Lomb-Scargle period estimate on irregularly-sampled
+    periodic data.
+
+    Note: this model fits only a single sinusoid with no additional harmonics,
+    so we use only 1 frequency and 1 amplitude to generate test data.
+    """
+    frequencies = np.array([4])
+    amplitudes = np.array([[1]])
+    phase = 0.1
+    times, values, errors = irregular_periodic(frequencies, amplitudes, phase)
+    f = generate_features(times, values, errors, ['period_fast'])
+
+    npt.assert_allclose(f['period_fast'], 1. / frequencies[0], rtol=3e-2)
+
+
+def test_max():
+    """Test maximum value feature."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['maximum'])
+    npt.assert_equal(f['maximum'], max(values))
+
+
+def test_max_slope():
+    """Test maximum slope feature, which finds the INDEX of the largest slope."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['max_slope'])
+    slopes = np.diff(values) / np.diff(times)
+    npt.assert_allclose(f['max_slope'], np.max(np.abs(slopes)))
+
+
+def test_median_absolute_deviation():
+    """Test median absolute deviation (from the median) feature."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['median_absolute_deviation'])
+    npt.assert_allclose(f['median_absolute_deviation'], np.median(np.abs(values -
+        np.median(values))))
+
+
+def test_percent_close_to_median():
+    """Test feature which finds the percentage of points near the median value."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors,
+            ['percent_close_to_median'])
+    amplitude = (max(values) - min(values)) / 2.
+    within_buffer = np.abs(values - np.median(values)) < 0.2*amplitude
+    npt.assert_allclose(f['percent_close_to_median'], np.mean(within_buffer))
+
+
+def test_median():
+    """Test median value feature."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['median'])
+    npt.assert_allclose(f['median'], np.median(values))
+
+
+def test_min():
+    """Test minimum value feature."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['minimum'])
+    npt.assert_equal(f['minimum'], min(values))
+
+
+# These features are currently ignored
+"""
+def test_phase_dispersion():
+# Frequency chosen to lie on the relevant search grid
+    frequencies = np.hstack((5.36, np.zeros(len(WAVE_FREQS)-1)))
+    amplitudes = np.zeros((len(frequencies),4))
+    amplitudes[0,:] = [1,0,0,0]
+    phase = 0.1
+    times, values, errors = regular_periodic(frequencies, amplitudes, phase)
+    f = generate_features(times, values, errors, ['phase_dispersion_freq0'])
+    npt.assert_allclose(f['phase_dispersion_freq0'], frequencies[0])
+
+    f = generate_features(times, values, errors, ['freq1_freq'])
+    lomb_freq = f['freq1_freq']
+    f = generate_features(times, values, errors, ['ratio_PDM_LS_freq0'])
+    npt.assert_allclose(f['ratio_PDM_LS_freq0'], frequencies[0]/lomb_freq)
+"""
+
+
+def test_qso_features():
+    """Test features which measure fit of QSO model.
+
+    Reference values are hard-coded values from previous implementation; not sure
+    of examples with a closed-form solution.
+    """
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors,
+            ['qso_log_chi2_qsonu', 'qso_log_chi2nuNULL_chi2nu'])
+    npt.assert_allclose(f['qso_log_chi2_qsonu'], 6.9844064754)
+    npt.assert_allclose(f['qso_log_chi2nuNULL_chi2nu'], -0.456526327522)
+
+
+def test_skew():
+    """Test statistical skew feature."""
+    from scipy import stats
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['skew'])
+    npt.assert_allclose(f['skew'], stats.skew(values))
+
+
+def test_std():
+    """Test standard deviation feature."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['std'])
+    npt.assert_allclose(f['std'], np.std(values))
+
+
+def test_stetson():
+    """Test Stetson variability features."""
+    times, values, errors = irregular_random(size=201)
+    f = generate_features(times, values, errors, ['stetson_j'])
+    # Stetson mean approximately equal to standard mean for large inputs
+    dists = np.sqrt(float(len(values)) / (len(values) - 1.)) * (values - np.mean(values)) / 0.1
+    npt.assert_allclose(f['stetson_j'],
+                        np.mean(np.sign(dists**2-1)*np.sqrt(np.abs(dists**2-1))),
+                        rtol=1e-2)
+    # Stetson_j should be somewhat close to (scaled) variance for normal data
+    npt.assert_allclose(f['stetson_j']*0.1, np.var(values), rtol=2e-1)
+    # Hard-coded original value
+    npt.assert_allclose(f['stetson_j'], 7.591347175195703)
+
+    f = generate_features(times, values, errors, ['stetson_k'])
+    npt.assert_allclose(f['stetson_k'], 1./0.798 * np.mean(np.abs(dists)) / np.sqrt(np.mean(dists**2)), rtol=5e-4)
+    # Hard-coded original value
+    npt.assert_allclose(f['stetson_k'], 1.0087218792719013)
+
+
+def test_weighted_average():
+    """Test weighted average and distance from weighted average features."""
+    times, values, errors = irregular_random()
+    f = generate_features(times, values, errors, ['weighted_average'])
+    weighted_avg = np.average(values, weights=1. / (errors**2))
+    weighted_var = np.average((values - weighted_avg)**2,
+                              weights=1. / (errors**2))
+    npt.assert_allclose(f['weighted_average'], weighted_avg)
+
+    dists_from_weighted_avg = values - weighted_avg
+    stds_from_weighted_avg = (dists_from_weighted_avg /
+            np.sqrt(weighted_var))
+
+    f = generate_features(times, values, errors,
+                                      ['percent_beyond_1_std'])
+    npt.assert_equal(f['percent_beyond_1_std'],
+                     np.mean(np.abs(stds_from_weighted_avg) > 1.))
```

### Comparing `cesium-0.9.7/cesium/features/_lomb_scargle.pyx` & `cesium-0.9.9/cesium/features/_lomb_scargle.pyx`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-from _lomb_scargle cimport lomb_scargle as _lomb_scargle
-
-cimport numpy as cnp
-import numpy as np
-
-def lomb_scargle(int numt, int numf, int nharm, int detrend_order,
-                 double[:] psd, double[:] cn, cnp.ndarray wth,
-                 double[:] sinx, double[:] cosx, double[:] sinx_step,
-                 double[:] cosx_step, double[:] sinx_back,
-                 double[:] cosx_back, double[:] sinx_smallstep,
-                 double[:] cosx_smallstep, double[:, :] hat_matr,
-                 double[:, :] hat_hat, double[:, :] hat0,
-                 double[:] soln, double chi0, double freq_zoom,
-                 double psdmin, double tone_control,
-                 cnp.ndarray[dtype=double, ndim=0] lambda0,
-                 double[:] lambda0_range,
-                 cnp.ndarray[dtype=double, ndim=0] Tr,
-                 cnp.ndarray[dtype=cnp.int32_t, ndim=0] ifreq):
-
-    assert wth.dtype == np.double
-
-    _lomb_scargle(numt, numf, nharm, detrend_order, &psd[0], &cn[0],
-                  <double*>(wth.data), &sinx[0], &cosx[0], &sinx_step[0],
-                  &cosx_step[0], &sinx_back[0], &cosx_back[0],
-                  &sinx_smallstep[0], &cosx_smallstep[0], &hat_matr[0, 0],
-                  &hat_hat[0, 0], &hat0[0, 0],
-                  &soln[0], chi0, freq_zoom, psdmin, tone_control,
-                  <double*>(lambda0.data), &lambda0_range[0],
-                  <double*>(Tr.data), <int*>(ifreq.data))
+from _lomb_scargle cimport lomb_scargle as _lomb_scargle
+
+cimport numpy as cnp
+import numpy as np
+
+def lomb_scargle(int numt, int numf, int nharm, int detrend_order,
+                 double[:] psd, double[:] cn, cnp.ndarray wth,
+                 double[:] sinx, double[:] cosx, double[:] sinx_step,
+                 double[:] cosx_step, double[:] sinx_back,
+                 double[:] cosx_back, double[:] sinx_smallstep,
+                 double[:] cosx_smallstep, double[:, :] hat_matr,
+                 double[:, :] hat_hat, double[:, :] hat0,
+                 double[:] soln, double chi0, double freq_zoom,
+                 double psdmin, double tone_control,
+                 cnp.ndarray[dtype=double, ndim=0] lambda0,
+                 double[:] lambda0_range,
+                 cnp.ndarray[dtype=double, ndim=0] Tr,
+                 cnp.ndarray[dtype=cnp.int32_t, ndim=0] ifreq):
+
+    assert wth.dtype == np.double
+
+    _lomb_scargle(numt, numf, nharm, detrend_order, &psd[0], &cn[0],
+                  <double*>(wth.data), &sinx[0], &cosx[0], &sinx_step[0],
+                  &cosx_step[0], &sinx_back[0], &cosx_back[0],
+                  &sinx_smallstep[0], &cosx_smallstep[0], &hat_matr[0, 0],
+                  &hat_hat[0, 0], &hat0[0, 0],
+                  &soln[0], chi0, freq_zoom, psdmin, tone_control,
+                  <double*>(lambda0.data), &lambda0_range[0],
+                  <double*>(Tr.data), <int*>(ifreq.data))
```

### Comparing `cesium-0.9.7/cesium/features/period_folding.py` & `cesium-0.9.9/cesium/features/period_folding.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,137 +1,137 @@
-import numpy as np
-from . import lomb_scargle as ls
-from . import common_functions as cf
-
-
-# TODO is this worth it since it doubles running time?
-def period_folding(x, y, dy, lomb_model, sys_err=0.05):
-    """
-    This section is used to calculate Dubath (10. Percentile90:2P/P),
-    which requires regenerating a model using 2P where P is the original found period
-
-    NOTE: this essentially runs everything a second time, so makes feature
-    generation take roughly twice as long.
-    """
-    out_dict = {}
-    model_vals = np.zeros(len(y))
-    freq_2p = lomb_model['freq_fits'][0]['freq'] * 0.5
-    ytest_2p = y.copy()
-    dy0 = np.sqrt(dy**2 + sys_err**2)
-
-    # Here we force the freq to just 2*freq1_Period; we also do not use linear
-    # detrending since we are not searching for freqs, and we want the
-    # resulting model to be smooth when in phase-space. Detrending would result
-    # in non-smooth model when period folded
-    lambda0_range = [-np.log10(len(x)), 8.]
-    fit = ls.fit_lomb_scargle(x, ytest_2p, dy0, freq_2p, lomb_model['df'], 1,
-            lambda0_range=lambda0_range, nharm=lomb_model['nharm'], detrend_order=0)
-    model_vals += fit['model']
-
-    ytest_2p -= fit['model']
-    for i in range(1, lomb_model['nfreq']):
-        fit = ls.fit_lomb_scargle(x, ytest_2p, dy0, lomb_model['f0'],
-                lomb_model['df'], lomb_model['numf'],
-                lambda0_range=lambda0_range, nharm=lomb_model['nharm'],
-                detrend_order=0)
-        ytest_2p -= fit['model']
-
-    out_dict['1p_resid'] = lomb_model['freq_fits'][-1]['resid']
-    out_dict['2p_resid'] = ytest_2p
-
-    # So the following uses the 2*Period model, and gets a time-sorted, folded t and m:
-    # NOTE: if this is succesful, I think a lot of other features could characterize the
-    # shapes of the 2P folded data (not P or 2P dependent).
-    # the reason we choose 2P is that occasionally for eclipsing
-    # sources the LS code chooses 0.5 of true period (but never 2x
-    # the true period).  slopes are not dependent upon the actual
-    # period so 2P is fine if it gives a high chance of correct fitting.
-    # NOTE: we only use the model from freq1 because this with its harmonics seems to
-    # adequately model shapes such as RRLyr skewed sawtooth, multi minima of rvtau
-    # without getting the scatter from using additional LS found frequencies.
-    t_2per_fold = np.array(x % (1. / freq_2p))
-    t_2per_sort_inds = np.argsort(t_2per_fold)
-    t_2per_fold = t_2per_fold[t_2per_sort_inds]
-    y_2per_fold = np.array(model_vals)[t_2per_sort_inds]
-    out_dict['folded_slopes'] = slopes = np.diff(y_2per_fold) / np.diff(t_2per_fold)
-
-    return out_dict
-
-
-def p2p_model(x, y, frequency):
-    """
-    Compute features that compare the residuals of data folded by estimated
-    period from Lomb-Scargle model with residuals folded by twice the estimated
-    period.
-    """
-
-    sumsqr_diff_unfold = np.sum((np.diff(y)**2))
-    median_diff = np.median(np.abs(np.diff(y)))
-    mad = cf.median_absolute_deviation(y)
-    x = x.copy()
-    x = x - min(x)
-
-    t_2per_fold = np.array(x % (2. / frequency))
-    t_2per_sort_inds = np.argsort(t_2per_fold)
-    t_2per_fold = t_2per_fold[t_2per_sort_inds]
-    y_2per_fold = np.array(y)[t_2per_sort_inds]
-    sumsqr_diff_2per_fold = np.sum(np.diff(y_2per_fold)**2)
-
-    ### eta feature from arXiv 1101.3316 Kim QSO paper:
-    t_1per_fold = np.array(x % (1. / frequency))
-    t_1per_sort_inds = np.argsort(t_1per_fold)
-    t_1per_fold = t_1per_fold[t_1per_sort_inds]
-    y_1per_fold = np.array(y)[t_1per_sort_inds]
-    median_1per_fold_diff = np.median(np.abs(np.diff(y_1per_fold)))
-
-    out_dict = {}
-    out_dict['scatter_2praw'] = sumsqr_diff_2per_fold / sumsqr_diff_unfold
-    out_dict['scatter_over_mad'] = median_diff / mad
-    out_dict['ssqr_diff_over_var'] = sumsqr_diff_unfold / ((len(y) - 1)
-            * np.var(y))
-    out_dict['scatter_pfold_over_mad'] = median_1per_fold_diff / mad
-    return out_dict
-
-
-# TODO why not just get the (almost) steepest positive/negative slopes directly?
-# TODO wrong for strictly increasing/decreasing
-def get_fold2P_slope_percentile(model, alpha):
-    """Get alphath percentile of slopes of period-folded model."""
-    return np.percentile(model['folded_slopes'], alpha)
-
-
-def get_medperc90_2p_p(model):
-    """
-    Get ratio of 90th percentiles of residuals for data folded by twice the
-    estimated period and the estimated period, respectively.
-    """
-    return (np.percentile(np.abs(model['2p_resid']), 90) /
-            np.percentile(np.abs(model['1p_resid']), 90))
-
-
-def get_p2p_scatter_2praw(model):
-    """
-    Get ratio of variability (sum of squared differences of consecutive
-    values) of folded and unfolded models.
-    """
-    return model['scatter_2praw']
-
-
-def get_p2p_scatter_over_mad(model):
-    """Get ratio of variability of folded and unfolded models."""
-    return model['scatter_over_mad']
-
-
-def get_p2p_scatter_pfold_over_mad(model):
-    """
-    Get ratio of median of period-folded data over median absolute
-    deviation of observed values.
-    """
-    return model['scatter_pfold_over_mad']
-
-
-def get_p2p_ssqr_diff_over_var(model):
-    """
-    Get sum of squared differences of consecutive values as a fraction of the
-    variance of the data.
-    """
-    return model['ssqr_diff_over_var']
+import numpy as np
+from . import lomb_scargle as ls
+from . import common_functions as cf
+
+
+# TODO is this worth it since it doubles running time?
+def period_folding(x, y, dy, lomb_model, sys_err=0.05):
+    """
+    This section is used to calculate Dubath (10. Percentile90:2P/P),
+    which requires regenerating a model using 2P where P is the original found period
+
+    NOTE: this essentially runs everything a second time, so makes feature
+    generation take roughly twice as long.
+    """
+    out_dict = {}
+    model_vals = np.zeros(len(y))
+    freq_2p = lomb_model['freq_fits'][0]['freq'] * 0.5
+    ytest_2p = y.copy()
+    dy0 = np.sqrt(dy**2 + sys_err**2)
+
+    # Here we force the freq to just 2*freq1_Period; we also do not use linear
+    # detrending since we are not searching for freqs, and we want the
+    # resulting model to be smooth when in phase-space. Detrending would result
+    # in non-smooth model when period folded
+    lambda0_range = [-np.log10(len(x)), 8.]
+    fit = ls.fit_lomb_scargle(x, ytest_2p, dy0, freq_2p, lomb_model['df'], 1,
+            lambda0_range=lambda0_range, nharm=lomb_model['nharm'], detrend_order=0)
+    model_vals += fit['model']
+
+    ytest_2p -= fit['model']
+    for i in range(1, lomb_model['nfreq']):
+        fit = ls.fit_lomb_scargle(x, ytest_2p, dy0, lomb_model['f0'],
+                lomb_model['df'], lomb_model['numf'],
+                lambda0_range=lambda0_range, nharm=lomb_model['nharm'],
+                detrend_order=0)
+        ytest_2p -= fit['model']
+
+    out_dict['1p_resid'] = lomb_model['freq_fits'][-1]['resid']
+    out_dict['2p_resid'] = ytest_2p
+
+    # So the following uses the 2*Period model, and gets a time-sorted, folded t and m:
+    # NOTE: if this is succesful, I think a lot of other features could characterize the
+    # shapes of the 2P folded data (not P or 2P dependent).
+    # the reason we choose 2P is that occasionally for eclipsing
+    # sources the LS code chooses 0.5 of true period (but never 2x
+    # the true period).  slopes are not dependent upon the actual
+    # period so 2P is fine if it gives a high chance of correct fitting.
+    # NOTE: we only use the model from freq1 because this with its harmonics seems to
+    # adequately model shapes such as RRLyr skewed sawtooth, multi minima of rvtau
+    # without getting the scatter from using additional LS found frequencies.
+    t_2per_fold = np.array(x % (1. / freq_2p))
+    t_2per_sort_inds = np.argsort(t_2per_fold)
+    t_2per_fold = t_2per_fold[t_2per_sort_inds]
+    y_2per_fold = np.array(model_vals)[t_2per_sort_inds]
+    out_dict['folded_slopes'] = slopes = np.diff(y_2per_fold) / np.diff(t_2per_fold)
+
+    return out_dict
+
+
+def p2p_model(x, y, frequency):
+    """
+    Compute features that compare the residuals of data folded by estimated
+    period from Lomb-Scargle model with residuals folded by twice the estimated
+    period.
+    """
+
+    sumsqr_diff_unfold = np.sum((np.diff(y)**2))
+    median_diff = np.median(np.abs(np.diff(y)))
+    mad = cf.median_absolute_deviation(y)
+    x = x.copy()
+    x = x - min(x)
+
+    t_2per_fold = np.array(x % (2. / frequency))
+    t_2per_sort_inds = np.argsort(t_2per_fold)
+    t_2per_fold = t_2per_fold[t_2per_sort_inds]
+    y_2per_fold = np.array(y)[t_2per_sort_inds]
+    sumsqr_diff_2per_fold = np.sum(np.diff(y_2per_fold)**2)
+
+    ### eta feature from arXiv 1101.3316 Kim QSO paper:
+    t_1per_fold = np.array(x % (1. / frequency))
+    t_1per_sort_inds = np.argsort(t_1per_fold)
+    t_1per_fold = t_1per_fold[t_1per_sort_inds]
+    y_1per_fold = np.array(y)[t_1per_sort_inds]
+    median_1per_fold_diff = np.median(np.abs(np.diff(y_1per_fold)))
+
+    out_dict = {}
+    out_dict['scatter_2praw'] = sumsqr_diff_2per_fold / sumsqr_diff_unfold
+    out_dict['scatter_over_mad'] = median_diff / mad
+    out_dict['ssqr_diff_over_var'] = sumsqr_diff_unfold / ((len(y) - 1)
+            * np.var(y))
+    out_dict['scatter_pfold_over_mad'] = median_1per_fold_diff / mad
+    return out_dict
+
+
+# TODO why not just get the (almost) steepest positive/negative slopes directly?
+# TODO wrong for strictly increasing/decreasing
+def get_fold2P_slope_percentile(model, alpha):
+    """Get alphath percentile of slopes of period-folded model."""
+    return np.percentile(model['folded_slopes'], alpha)
+
+
+def get_medperc90_2p_p(model):
+    """
+    Get ratio of 90th percentiles of residuals for data folded by twice the
+    estimated period and the estimated period, respectively.
+    """
+    return (np.percentile(np.abs(model['2p_resid']), 90) /
+            np.percentile(np.abs(model['1p_resid']), 90))
+
+
+def get_p2p_scatter_2praw(model):
+    """
+    Get ratio of variability (sum of squared differences of consecutive
+    values) of folded and unfolded models.
+    """
+    return model['scatter_2praw']
+
+
+def get_p2p_scatter_over_mad(model):
+    """Get ratio of variability of folded and unfolded models."""
+    return model['scatter_over_mad']
+
+
+def get_p2p_scatter_pfold_over_mad(model):
+    """
+    Get ratio of median of period-folded data over median absolute
+    deviation of observed values.
+    """
+    return model['scatter_pfold_over_mad']
+
+
+def get_p2p_ssqr_diff_over_var(model):
+    """
+    Get sum of squared differences of consecutive values as a fraction of the
+    variance of the data.
+    """
+    return model['ssqr_diff_over_var']
```

### Comparing `cesium-0.9.7/cesium/features/graphs.py` & `cesium-0.9.9/cesium/features/graphs.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,416 +1,416 @@
-import numpy as np
-
-from .cadence_features import (cad_prob, delta_t_hist, double_to_single_step,
-                               normalize_hist, find_sorted_peaks, peak_bin,
-                               peak_ratio)
-
-from .common_functions import (maximum, median, max_slope,
-                               median_absolute_deviation, minimum,
-                               percent_beyond_1_std, percent_close_to_median,
-                               skew, std, weighted_average)
-from .amplitude import (amplitude, percent_amplitude, flux_percentile_ratio,
-                        percent_difference_flux_percentile)
-from .qso_model import (qso_fit, get_qso_log_chi2_qsonu,
-                        get_qso_log_chi2nuNULL_chi2nu)
-from .stetson import (stetson_j, stetson_k)
-
-from .lomb_scargle import (lomb_scargle_model, get_lomb_frequency,
-                           get_lomb_amplitude, get_lomb_rel_phase,
-                           get_lomb_amplitude_ratio, get_lomb_frequency_ratio,
-                           get_lomb_signif_ratio, get_lomb_lambda,
-                           get_lomb_signif, get_lomb_varrat, get_lomb_trend,
-                           get_lomb_y_offset)
-from .lomb_scargle_fast import lomb_scargle_fast_period
-from .num_alias import num_alias
-from .periodic_model import (periodic_model, get_max_delta_mags,
-                             get_min_delta_mags, get_model_phi1_phi2)
-from .period_folding import (period_folding, get_fold2P_slope_percentile,
-                             get_medperc90_2p_p, p2p_model,
-                             get_p2p_scatter_2praw, get_p2p_scatter_over_mad,
-                             get_p2p_scatter_pfold_over_mad,
-                             get_p2p_ssqr_diff_over_var)
-from .scatter_res_raw import scatter_res_raw
-
-
-__all__ = ['CADENCE_FEATS', 'GENERAL_FEATS', 'LOMB_SCARGLE_FEATS',
-           'generate_dask_graph', 'feature_categories', 'dask_feature_graph']
-
-feature_categories = {
-    'Cadence/Error': [
-        'n_epochs','avg_err','med_err','std_err',
-        'total_time','avgt','cads_std','mean',
-        'cads_avg','cads_med','cad_probs_1',
-        'cad_probs_10','cad_probs_20','cad_probs_30',
-        'cad_probs_40','cad_probs_50','cad_probs_100',
-        'cad_probs_500','cad_probs_1000','cad_probs_5000',
-        'cad_probs_10000','cad_probs_50000','cad_probs_100000',
-        'cad_probs_500000','cad_probs_1000000','cad_probs_5000000',
-        'cad_probs_10000000','med_double_to_single_step',
-        'avg_double_to_single_step','std_double_to_single_step',
-        'all_times_nhist_numpeaks','all_times_nhist_peak_val',
-        'all_times_nhist_peak_1_to_2','all_times_nhist_peak_1_to_3',
-        'all_times_nhist_peak_2_to_3','all_times_nhist_peak_1_to_4',
-        'all_times_nhist_peak_2_to_4','all_times_nhist_peak_3_to_4',
-        'all_times_nhist_peak1_bin','all_times_nhist_peak2_bin',
-        'all_times_nhist_peak3_bin','all_times_nhist_peak4_bin'
-        ],
-
-    'General': [
-        'amplitude', 'flux_percentile_ratio_mid20',
-        'flux_percentile_ratio_mid35', 'flux_percentile_ratio_mid50',
-        'flux_percentile_ratio_mid65', 'flux_percentile_ratio_mid80',
-        'max_slope', 'maximum', 'median', 'median_absolute_deviation',
-        'minimum', 'percent_amplitude', 'percent_beyond_1_std',
-        'percent_close_to_median',
-        'percent_difference_flux_percentile', 'period_fast',
-        'qso_log_chi2_qsonu', 'qso_log_chi2nuNULL_chi2nu', 'skew',
-        'std', 'stetson_j', 'stetson_k', 'weighted_average'
-        ],
-
-    'Lomb-Scargle (Periodic)': [
-        'fold2P_slope_10percentile', 'fold2P_slope_90percentile',
-        'freq1_amplitude1', 'freq1_amplitude2', 'freq1_amplitude3',
-        'freq1_amplitude4', 'freq1_freq', 'freq1_lambda',
-        'freq1_rel_phase2', 'freq1_rel_phase3', 'freq1_rel_phase4',
-        'freq1_signif', 'freq2_amplitude1', 'freq2_amplitude2',
-        'freq2_amplitude3', 'freq2_amplitude4', 'freq2_freq',
-        'freq2_rel_phase2', 'freq2_rel_phase3', 'freq2_rel_phase4',
-        'freq3_amplitude1', 'freq3_amplitude2', 'freq3_amplitude3',
-        'freq3_amplitude4', 'freq3_freq', 'freq3_rel_phase2',
-        'freq3_rel_phase3', 'freq3_rel_phase4',
-        'freq_amplitude_ratio_21', 'freq_amplitude_ratio_31',
-        'freq_frequency_ratio_21', 'freq_frequency_ratio_31',
-        'freq_model_max_delta_mags', 'freq_model_min_delta_mags',
-        'freq_model_phi1_phi2', 'freq_n_alias',
-        'freq_signif_ratio_21', 'freq_signif_ratio_31', 'freq_varrat',
-        'freq_y_offset', 'linear_trend', 'medperc90_2p_p',
-        'p2p_scatter_2praw', 'p2p_scatter_over_mad',
-        'p2p_scatter_pfold_over_mad', 'p2p_ssqr_diff_over_var',
-        'scatter_res_raw'
-    ]
-}
-
-CADENCE_FEATS = feature_categories['Cadence/Error']
-GENERAL_FEATS = feature_categories['General']
-LOMB_SCARGLE_FEATS = feature_categories['Lomb-Scargle (Periodic)']
-
-
-# See http://dask.pydata.org/en/latest/custom-graphs.html
-
-dask_feature_graph = {
-    'n_epochs': (len, 't'),
-    'avg_err': (np.mean, 'e'),
-    'med_err': (np.median, 'e'),
-    'std_err': (np.std, 'e'),
-    'total_time': (lambda x: np.max(x) - np.min(x), 't'),
-    'avgt': (np.mean, 't'),
-    'cads': (np.diff, 't'),
-    'cads_std': (np.std, 'cads'),
-    'mean': (np.mean, 'm'),
-    'cads_avg': (np.mean, 'cads'),
-    'cads_med': (np.median, 'cads'),
-    'cad_probs_1': (cad_prob, 'cads', 1),
-    'cad_probs_10': (cad_prob, 'cads', 10),
-    'cad_probs_20': (cad_prob, 'cads', 20),
-    'cad_probs_30': (cad_prob, 'cads', 30),
-    'cad_probs_40': (cad_prob, 'cads', 40),
-    'cad_probs_50': (cad_prob, 'cads', 50),
-    'cad_probs_100': (cad_prob, 'cads', 100),
-    'cad_probs_500': (cad_prob, 'cads', 500),
-    'cad_probs_1000': (cad_prob, 'cads', 1000),
-    'cad_probs_5000': (cad_prob, 'cads', 5000),
-    'cad_probs_10000': (cad_prob, 'cads', 10000),
-    'cad_probs_50000': (cad_prob, 'cads', 50000),
-    'cad_probs_100000': (cad_prob, 'cads', 100000),
-    'cad_probs_500000': (cad_prob, 'cads', 500000),
-    'cad_probs_1000000': (cad_prob, 'cads', 1000000),
-    'cad_probs_5000000': (cad_prob, 'cads', 5000000),
-    'cad_probs_10000000': (cad_prob, 'cads', 10000000),
-    'double_to_single_step': (double_to_single_step, 'cads'),
-    'avg_double_to_single_step': (np.mean, 'double_to_single_step'),
-    'med_double_to_single_step': (np.median, 'double_to_single_step'),
-    'std_double_to_single_step': (np.std, 'double_to_single_step'),
-    'delta_t_hist': (delta_t_hist, 't'),
-    'delta_t_nhist': (normalize_hist, 'delta_t_hist', 'total_time'),
-    'nhist_peaks': (find_sorted_peaks, 'delta_t_nhist'),
-    'all_times_nhist_numpeaks': (len, 'nhist_peaks'),
-    'all_times_nhist_peak_val': (np.max, 'delta_t_nhist'),
-    'all_times_nhist_peak_1_to_2': (peak_ratio, 'nhist_peaks', 1, 2),
-    'all_times_nhist_peak_1_to_3': (peak_ratio, 'nhist_peaks', 1, 3),
-    'all_times_nhist_peak_2_to_3': (peak_ratio, 'nhist_peaks', 2, 3),
-    'all_times_nhist_peak_1_to_4': (peak_ratio, 'nhist_peaks', 1, 4),
-    'all_times_nhist_peak_2_to_4': (peak_ratio, 'nhist_peaks', 2, 4),
-    'all_times_nhist_peak_3_to_4': (peak_ratio, 'nhist_peaks', 3, 4),
-    'all_times_nhist_peak1_bin': (peak_bin, 'nhist_peaks', 1),
-    'all_times_nhist_peak2_bin': (peak_bin, 'nhist_peaks', 2),
-    'all_times_nhist_peak3_bin': (peak_bin, 'nhist_peaks', 3),
-    'all_times_nhist_peak4_bin': (peak_bin, 'nhist_peaks', 4),
-
-    # Standalone features (disconnected nodes)
-    'amplitude': (amplitude, 'm'),
-    'flux_percentile_ratio_mid20': (flux_percentile_ratio, 'm', 20),
-    'flux_percentile_ratio_mid35': (flux_percentile_ratio, 'm', 35),
-    'flux_percentile_ratio_mid50': (flux_percentile_ratio, 'm', 50),
-    'flux_percentile_ratio_mid65': (flux_percentile_ratio, 'm', 65),
-    'flux_percentile_ratio_mid80': (flux_percentile_ratio, 'm', 80),
-    'maximum': (maximum, 'm'),
-    'max_slope': (max_slope, 't', 'm'),
-    'median': (median, 'm'),
-    'median_absolute_deviation': (median_absolute_deviation, 'm'),
-    'minimum': (minimum, 'm'),
-    'percent_amplitude': (percent_amplitude, 'm'),
-    'percent_beyond_1_std': (percent_beyond_1_std, 'm', 'e'),
-    'percent_close_to_median': (percent_close_to_median, 'm'),
-    'percent_difference_flux_percentile': (
-        percent_difference_flux_percentile, 'm'),
-    'skew': (skew, 'm'),
-    'std': (std, 'm'),
-    'stetson_j': (stetson_j, 'm'),
-    'stetson_k': (stetson_k, 'm'),
-    'weighted_average': (weighted_average, 'm', 'e'),
-
-    # QSO model features
-    'qso_model': (qso_fit, 't', 'm', 'e'),
-    'qso_log_chi2_qsonu': (get_qso_log_chi2_qsonu, 'qso_model'),
-    'qso_log_chi2nuNULL_chi2nu': (get_qso_log_chi2nuNULL_chi2nu,
-                                  'qso_model'),
-
-    # Fast Lomb-Scargle from Gatspy
-    'period_fast': (lomb_scargle_fast_period, 't', 'm', 'e'),
-
-    '_lomb_model': (lomb_scargle_model, 't', 'm', 'e'),
-    # These could easily be programmatically generated, but this is more readable
-    'freq1_freq': (get_lomb_frequency, '_lomb_model', 1),
-    'freq2_freq': (get_lomb_frequency, '_lomb_model', 2),
-    'freq3_freq': (get_lomb_frequency, '_lomb_model', 3),
-    'freq1_amplitude1': (get_lomb_amplitude, '_lomb_model', 1, 1),
-    'freq1_amplitude2': (get_lomb_amplitude, '_lomb_model', 1, 2),
-    'freq1_amplitude3': (get_lomb_amplitude, '_lomb_model', 1, 3),
-    'freq1_amplitude4': (get_lomb_amplitude, '_lomb_model', 1, 4),
-    'freq2_amplitude1': (get_lomb_amplitude, '_lomb_model', 2, 1),
-    'freq2_amplitude2': (get_lomb_amplitude, '_lomb_model', 2, 2),
-    'freq2_amplitude3': (get_lomb_amplitude, '_lomb_model', 2, 3),
-    'freq2_amplitude4': (get_lomb_amplitude, '_lomb_model', 2, 4),
-    'freq3_amplitude1': (get_lomb_amplitude, '_lomb_model', 3, 1),
-    'freq3_amplitude2': (get_lomb_amplitude, '_lomb_model', 3, 2),
-    'freq3_amplitude3': (get_lomb_amplitude, '_lomb_model', 3, 3),
-    'freq3_amplitude4': (get_lomb_amplitude, '_lomb_model', 3, 4),
-    #        'freq1_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 1, 1),
-    'freq1_rel_phase2': (get_lomb_rel_phase, '_lomb_model', 1, 2),
-    'freq1_rel_phase3': (get_lomb_rel_phase, '_lomb_model', 1, 3),
-    'freq1_rel_phase4': (get_lomb_rel_phase, '_lomb_model', 1, 4),
-    #        'freq2_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 2, 1),
-    'freq2_rel_phase2': (get_lomb_rel_phase, '_lomb_model', 2, 2),
-    'freq2_rel_phase3': (get_lomb_rel_phase, '_lomb_model', 2, 3),
-    'freq2_rel_phase4': (get_lomb_rel_phase, '_lomb_model', 2, 4),
-    #        'freq3_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 3, 1),
-    'freq3_rel_phase2': (get_lomb_rel_phase, '_lomb_model', 3, 2),
-    'freq3_rel_phase3': (get_lomb_rel_phase, '_lomb_model', 3, 3),
-    'freq3_rel_phase4': (get_lomb_rel_phase, '_lomb_model', 3, 4),
-    'freq_amplitude_ratio_21': (get_lomb_amplitude_ratio, '_lomb_model', 2),
-    'freq_amplitude_ratio_31': (get_lomb_amplitude_ratio, '_lomb_model', 3),
-    'freq_frequency_ratio_21': (get_lomb_frequency_ratio, '_lomb_model', 2),
-    'freq_frequency_ratio_31': (get_lomb_frequency_ratio, '_lomb_model', 3),
-    'freq_signif_ratio_21': (get_lomb_signif_ratio, '_lomb_model', 2),
-    'freq_signif_ratio_31': (get_lomb_signif_ratio, '_lomb_model', 3),
-    'freq1_lambda': (get_lomb_lambda, '_lomb_model'),
-    'freq1_signif': (get_lomb_signif, '_lomb_model'),
-    'freq_varrat': (get_lomb_varrat, '_lomb_model'),
-    'linear_trend': (get_lomb_trend, '_lomb_model'),
-    'freq_y_offset': (get_lomb_y_offset, '_lomb_model'),
-
-     # Other features that operate on Lomb-Scargle residuals
-    'freq_n_alias': (num_alias, '_lomb_model'),
-    'scatter_res_raw': (scatter_res_raw, 't', 'm', 'e', '_lomb_model'),
-
-    '_periodic_model': (periodic_model, '_lomb_model'),
-    '_period_folded_model': (period_folding, 't', 'm', 'e', '_lomb_model'),
-
-    'freq_model_max_delta_mags': (get_max_delta_mags, '_periodic_model'),
-    'freq_model_min_delta_mags': (get_min_delta_mags, '_periodic_model'),
-    'freq_model_phi1_phi2': (get_model_phi1_phi2, '_periodic_model'),
-    'fold2P_slope_10percentile': (get_fold2P_slope_percentile,
-                                  '_period_folded_model', 10),
-    'fold2P_slope_90percentile': (get_fold2P_slope_percentile,
-                                  '_period_folded_model', 90),
-    'medperc90_2p_p': (get_medperc90_2p_p, '_period_folded_model'),
-
-    '_p2p_model': (p2p_model, 't', 'm', 'freq1_freq'),
-    'p2p_scatter_2praw': (get_p2p_scatter_2praw, '_p2p_model'),
-    'p2p_scatter_over_mad': (get_p2p_scatter_over_mad, '_p2p_model'),
-    'p2p_scatter_pfold_over_mad': (get_p2p_scatter_pfold_over_mad,
-                                   '_p2p_model'),
-    'p2p_ssqr_diff_over_var': (get_p2p_ssqr_diff_over_var, '_p2p_model')
-}
-
-def generate_dask_graph(t, m, e):
-    full_graph = {'t': t, 'm': m, 'e': e}
-    full_graph.update(dask_feature_graph)
-    return full_graph
-
-
-extra_feature_docs = {
-    'n_epochs': 'Total number of observed values.',
-    'avg_err': 'Mean of the error estimates.',
-    'med_err': 'Median of error estimates.',
-    'std_err': 'Standard deviation of the error estimates.',
-    'total_time': 'Absolute difference between max and min of time values.',
-    'avgt': 'Mean of the time values.',
-    'mean': 'Mean of observed values.',
-    'cads': 'List of differences between successive time values (`np.diff(t)`).',
-    'cads_std': 'Standard deviation of `cads` (discrete difference between times).',
-    'cads_avg': 'Mean value of `cads` (discrete difference between times).',
-    'cads_med': 'Median value of `cads` (discrete difference between times).',
-    'avg_double_to_single_step':
-    'Mean value of ratios (t[i+2] - t[i]) / (t[i+2] - t[i+1]).',
-    'med_double_to_single_step':
-    'Median value of ratios (t[i+2] - t[i]) / (t[i+2] - t[i+1]).',
-    'std_double_to_single_step':
-    'Standard deviation of ratios (t[i+2] - t[i]) / (t[i+2] - t[i+1]).',
-    'all_times_nhist_numpeaks':
-    'Number of peaks (local maxima) in histogram of all possible delta_t\'s.',
-    'all_times_nhist_peak_val':
-    'Peak value in histogram of all possible delta_t\'s.'
-}
-
-
-feature_tags = {
-    'n_epochs': ['Astronomy', 'General'],
-    'avg_err': ['Astronomy', 'Error', 'General'],
-    'med_err': ['Astronomy', 'Error', 'General'],
-    'std_err': ['Astronomy', 'Error', 'General'],
-    'total_time': ['Astronomy', 'General'],
-    'avgt': ['Astronomy', 'General'],
-    'cads': ['Astronomy', 'General', 'Cadence'],
-    'cads_std': ['Astronomy', 'General', 'Cadence'],
-    'mean': ['Astronomy', 'General'],
-    'cads_avg': ['Astronomy', 'General', 'Cadence'],
-    'cads_med': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_1': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_10': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_20': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_30': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_40': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_50': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_100': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_500': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_1000': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_5000': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_10000': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_50000': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_100000': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_500000': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_1000000': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_5000000': ['Astronomy', 'General', 'Cadence'],
-    'cad_probs_10000000': ['Astronomy', 'General', 'Cadence'],
-    'double_to_single_step': ['Astronomy', 'General', 'Cadence'],
-    'avg_double_to_single_step': ['Astronomy', 'General', 'Cadence'],
-    'med_double_to_single_step': ['Astronomy', 'General', 'Cadence'],
-    'std_double_to_single_step': ['Astronomy', 'General', 'Cadence'],
-    'delta_t_hist': ['Astronomy', 'General', 'Cadence'],
-    'delta_t_nhist': ['Astronomy', 'General', 'Cadence'],
-    'nhist_peaks': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_numpeaks': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak_val': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak_1_to_2': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak_1_to_3': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak_2_to_3': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak_1_to_4': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak_2_to_4': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak_3_to_4': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak1_bin': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak2_bin': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak3_bin': ['Astronomy', 'General', 'Cadence'],
-    'all_times_nhist_peak4_bin': ['Astronomy', 'General', 'Cadence'],
-
-    # Standalone features (disconnected nodes)
-    'amplitude': ['Astronomy', 'General'],
-    'flux_percentile_ratio_mid20': ['Astronomy'],
-    'flux_percentile_ratio_mid35': ['Astronomy'],
-    'flux_percentile_ratio_mid50': ['Astronomy'],
-    'flux_percentile_ratio_mid65': ['Astronomy'],
-    'flux_percentile_ratio_mid80': ['Astronomy'],
-    'maximum': ['Astronomy', 'General'],
-    'max_slope': ['Astronomy', 'General'],
-    'median': ['Astronomy', 'General'],
-    'median_absolute_deviation': ['Astronomy', 'General'],
-    'minimum': ['Astronomy', 'General'],
-    'percent_amplitude': ['Astronomy', 'General'],
-    'percent_beyond_1_std': ['Astronomy', 'General'],
-    'percent_close_to_median': ['Astronomy', 'General'],
-    'percent_difference_flux_percentile': ['Astronomy', 'General'],
-    'skew': ['Astronomy', 'General'],
-    'std': ['Astronomy', 'General'],
-    'stetson_j': ['Astronomy', 'General'],
-    'stetson_k': ['Astronomy', 'General'],
-    'weighted_average': ['Astronomy', 'General'],
-
-    # QSO model features
-    'qso_model': ['Astronomy'],
-    'qso_log_chi2_qsonu': ['Astronomy'],
-    'qso_log_chi2nuNULL_chi2nu': ['Astronomy'],
-
-    # Fast Lomb-Scargle from Gatspy
-    'period_fast': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-
-    '_lomb_model': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    # These could easily be programmatically generated, but this is more readable
-    'freq1_freq': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq2_freq': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq3_freq': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq1_amplitude1': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq1_amplitude2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq1_amplitude3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq1_amplitude4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq2_amplitude1': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq2_amplitude2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq2_amplitude3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq2_amplitude4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq3_amplitude1': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq3_amplitude2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq3_amplitude3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq3_amplitude4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    #        'freq1_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 1, 1),
-    'freq1_rel_phase2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq1_rel_phase3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq1_rel_phase4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    #        'freq2_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 2, 1),
-    'freq2_rel_phase2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq2_rel_phase3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq2_rel_phase4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    #        'freq3_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 3, 1),
-    'freq3_rel_phase2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq3_rel_phase3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq3_rel_phase4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_amplitude_ratio_21': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_amplitude_ratio_31': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_frequency_ratio_21': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_frequency_ratio_31': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_signif_ratio_21': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_signif_ratio_31': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq1_lambda': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq1_signif': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_varrat': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'linear_trend': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_y_offset': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-
-     # Other features that operate on Lomb-Scargle residuals
-    'freq_n_alias': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'scatter_res_raw': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-
-    '_periodic_model': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    '_period_folded_model': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-
-    'freq_model_max_delta_mags': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_model_min_delta_mags': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'freq_model_phi1_phi2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'fold2P_slope_10percentile': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'fold2P_slope_90percentile': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'medperc90_2p_p': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-
-    '_p2p_model': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'p2p_scatter_2praw': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'p2p_scatter_over_mad': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'p2p_scatter_pfold_over_mad': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
-    'p2p_ssqr_diff_over_var': ['Astronomy', 'Periodic', 'Lomb-Scargle']
-}
+import numpy as np
+
+from .cadence_features import (cad_prob, delta_t_hist, double_to_single_step,
+                               normalize_hist, find_sorted_peaks, peak_bin,
+                               peak_ratio)
+
+from .common_functions import (maximum, median, max_slope,
+                               median_absolute_deviation, minimum,
+                               percent_beyond_1_std, percent_close_to_median,
+                               skew, std, weighted_average)
+from .amplitude import (amplitude, percent_amplitude, flux_percentile_ratio,
+                        percent_difference_flux_percentile)
+from .qso_model import (qso_fit, get_qso_log_chi2_qsonu,
+                        get_qso_log_chi2nuNULL_chi2nu)
+from .stetson import (stetson_j, stetson_k)
+
+from .lomb_scargle import (lomb_scargle_model, get_lomb_frequency,
+                           get_lomb_amplitude, get_lomb_rel_phase,
+                           get_lomb_amplitude_ratio, get_lomb_frequency_ratio,
+                           get_lomb_signif_ratio, get_lomb_lambda,
+                           get_lomb_signif, get_lomb_varrat, get_lomb_trend,
+                           get_lomb_y_offset)
+from .lomb_scargle_fast import lomb_scargle_fast_period
+from .num_alias import num_alias
+from .periodic_model import (periodic_model, get_max_delta_mags,
+                             get_min_delta_mags, get_model_phi1_phi2)
+from .period_folding import (period_folding, get_fold2P_slope_percentile,
+                             get_medperc90_2p_p, p2p_model,
+                             get_p2p_scatter_2praw, get_p2p_scatter_over_mad,
+                             get_p2p_scatter_pfold_over_mad,
+                             get_p2p_ssqr_diff_over_var)
+from .scatter_res_raw import scatter_res_raw
+
+
+__all__ = ['CADENCE_FEATS', 'GENERAL_FEATS', 'LOMB_SCARGLE_FEATS',
+           'generate_dask_graph', 'feature_categories', 'dask_feature_graph']
+
+feature_categories = {
+    'Cadence/Error': [
+        'n_epochs','avg_err','med_err','std_err',
+        'total_time','avgt','cads_std','mean',
+        'cads_avg','cads_med','cad_probs_1',
+        'cad_probs_10','cad_probs_20','cad_probs_30',
+        'cad_probs_40','cad_probs_50','cad_probs_100',
+        'cad_probs_500','cad_probs_1000','cad_probs_5000',
+        'cad_probs_10000','cad_probs_50000','cad_probs_100000',
+        'cad_probs_500000','cad_probs_1000000','cad_probs_5000000',
+        'cad_probs_10000000','med_double_to_single_step',
+        'avg_double_to_single_step','std_double_to_single_step',
+        'all_times_nhist_numpeaks','all_times_nhist_peak_val',
+        'all_times_nhist_peak_1_to_2','all_times_nhist_peak_1_to_3',
+        'all_times_nhist_peak_2_to_3','all_times_nhist_peak_1_to_4',
+        'all_times_nhist_peak_2_to_4','all_times_nhist_peak_3_to_4',
+        'all_times_nhist_peak1_bin','all_times_nhist_peak2_bin',
+        'all_times_nhist_peak3_bin','all_times_nhist_peak4_bin'
+        ],
+
+    'General': [
+        'amplitude', 'flux_percentile_ratio_mid20',
+        'flux_percentile_ratio_mid35', 'flux_percentile_ratio_mid50',
+        'flux_percentile_ratio_mid65', 'flux_percentile_ratio_mid80',
+        'max_slope', 'maximum', 'median', 'median_absolute_deviation',
+        'minimum', 'percent_amplitude', 'percent_beyond_1_std',
+        'percent_close_to_median',
+        'percent_difference_flux_percentile', 'period_fast',
+        'qso_log_chi2_qsonu', 'qso_log_chi2nuNULL_chi2nu', 'skew',
+        'std', 'stetson_j', 'stetson_k', 'weighted_average'
+        ],
+
+    'Lomb-Scargle (Periodic)': [
+        'fold2P_slope_10percentile', 'fold2P_slope_90percentile',
+        'freq1_amplitude1', 'freq1_amplitude2', 'freq1_amplitude3',
+        'freq1_amplitude4', 'freq1_freq', 'freq1_lambda',
+        'freq1_rel_phase2', 'freq1_rel_phase3', 'freq1_rel_phase4',
+        'freq1_signif', 'freq2_amplitude1', 'freq2_amplitude2',
+        'freq2_amplitude3', 'freq2_amplitude4', 'freq2_freq',
+        'freq2_rel_phase2', 'freq2_rel_phase3', 'freq2_rel_phase4',
+        'freq3_amplitude1', 'freq3_amplitude2', 'freq3_amplitude3',
+        'freq3_amplitude4', 'freq3_freq', 'freq3_rel_phase2',
+        'freq3_rel_phase3', 'freq3_rel_phase4',
+        'freq_amplitude_ratio_21', 'freq_amplitude_ratio_31',
+        'freq_frequency_ratio_21', 'freq_frequency_ratio_31',
+        'freq_model_max_delta_mags', 'freq_model_min_delta_mags',
+        'freq_model_phi1_phi2', 'freq_n_alias',
+        'freq_signif_ratio_21', 'freq_signif_ratio_31', 'freq_varrat',
+        'freq_y_offset', 'linear_trend', 'medperc90_2p_p',
+        'p2p_scatter_2praw', 'p2p_scatter_over_mad',
+        'p2p_scatter_pfold_over_mad', 'p2p_ssqr_diff_over_var',
+        'scatter_res_raw'
+    ]
+}
+
+CADENCE_FEATS = feature_categories['Cadence/Error']
+GENERAL_FEATS = feature_categories['General']
+LOMB_SCARGLE_FEATS = feature_categories['Lomb-Scargle (Periodic)']
+
+
+# See http://dask.pydata.org/en/latest/custom-graphs.html
+
+dask_feature_graph = {
+    'n_epochs': (len, 't'),
+    'avg_err': (np.mean, 'e'),
+    'med_err': (np.median, 'e'),
+    'std_err': (np.std, 'e'),
+    'total_time': (lambda x: np.max(x) - np.min(x), 't'),
+    'avgt': (np.mean, 't'),
+    'cads': (np.diff, 't'),
+    'cads_std': (np.std, 'cads'),
+    'mean': (np.mean, 'm'),
+    'cads_avg': (np.mean, 'cads'),
+    'cads_med': (np.median, 'cads'),
+    'cad_probs_1': (cad_prob, 'cads', 1),
+    'cad_probs_10': (cad_prob, 'cads', 10),
+    'cad_probs_20': (cad_prob, 'cads', 20),
+    'cad_probs_30': (cad_prob, 'cads', 30),
+    'cad_probs_40': (cad_prob, 'cads', 40),
+    'cad_probs_50': (cad_prob, 'cads', 50),
+    'cad_probs_100': (cad_prob, 'cads', 100),
+    'cad_probs_500': (cad_prob, 'cads', 500),
+    'cad_probs_1000': (cad_prob, 'cads', 1000),
+    'cad_probs_5000': (cad_prob, 'cads', 5000),
+    'cad_probs_10000': (cad_prob, 'cads', 10000),
+    'cad_probs_50000': (cad_prob, 'cads', 50000),
+    'cad_probs_100000': (cad_prob, 'cads', 100000),
+    'cad_probs_500000': (cad_prob, 'cads', 500000),
+    'cad_probs_1000000': (cad_prob, 'cads', 1000000),
+    'cad_probs_5000000': (cad_prob, 'cads', 5000000),
+    'cad_probs_10000000': (cad_prob, 'cads', 10000000),
+    'double_to_single_step': (double_to_single_step, 'cads'),
+    'avg_double_to_single_step': (np.mean, 'double_to_single_step'),
+    'med_double_to_single_step': (np.median, 'double_to_single_step'),
+    'std_double_to_single_step': (np.std, 'double_to_single_step'),
+    'delta_t_hist': (delta_t_hist, 't'),
+    'delta_t_nhist': (normalize_hist, 'delta_t_hist', 'total_time'),
+    'nhist_peaks': (find_sorted_peaks, 'delta_t_nhist'),
+    'all_times_nhist_numpeaks': (len, 'nhist_peaks'),
+    'all_times_nhist_peak_val': (np.max, 'delta_t_nhist'),
+    'all_times_nhist_peak_1_to_2': (peak_ratio, 'nhist_peaks', 1, 2),
+    'all_times_nhist_peak_1_to_3': (peak_ratio, 'nhist_peaks', 1, 3),
+    'all_times_nhist_peak_2_to_3': (peak_ratio, 'nhist_peaks', 2, 3),
+    'all_times_nhist_peak_1_to_4': (peak_ratio, 'nhist_peaks', 1, 4),
+    'all_times_nhist_peak_2_to_4': (peak_ratio, 'nhist_peaks', 2, 4),
+    'all_times_nhist_peak_3_to_4': (peak_ratio, 'nhist_peaks', 3, 4),
+    'all_times_nhist_peak1_bin': (peak_bin, 'nhist_peaks', 1),
+    'all_times_nhist_peak2_bin': (peak_bin, 'nhist_peaks', 2),
+    'all_times_nhist_peak3_bin': (peak_bin, 'nhist_peaks', 3),
+    'all_times_nhist_peak4_bin': (peak_bin, 'nhist_peaks', 4),
+
+    # Standalone features (disconnected nodes)
+    'amplitude': (amplitude, 'm'),
+    'flux_percentile_ratio_mid20': (flux_percentile_ratio, 'm', 20),
+    'flux_percentile_ratio_mid35': (flux_percentile_ratio, 'm', 35),
+    'flux_percentile_ratio_mid50': (flux_percentile_ratio, 'm', 50),
+    'flux_percentile_ratio_mid65': (flux_percentile_ratio, 'm', 65),
+    'flux_percentile_ratio_mid80': (flux_percentile_ratio, 'm', 80),
+    'maximum': (maximum, 'm'),
+    'max_slope': (max_slope, 't', 'm'),
+    'median': (median, 'm'),
+    'median_absolute_deviation': (median_absolute_deviation, 'm'),
+    'minimum': (minimum, 'm'),
+    'percent_amplitude': (percent_amplitude, 'm'),
+    'percent_beyond_1_std': (percent_beyond_1_std, 'm', 'e'),
+    'percent_close_to_median': (percent_close_to_median, 'm'),
+    'percent_difference_flux_percentile': (
+        percent_difference_flux_percentile, 'm'),
+    'skew': (skew, 'm'),
+    'std': (std, 'm'),
+    'stetson_j': (stetson_j, 'm'),
+    'stetson_k': (stetson_k, 'm'),
+    'weighted_average': (weighted_average, 'm', 'e'),
+
+    # QSO model features
+    'qso_model': (qso_fit, 't', 'm', 'e'),
+    'qso_log_chi2_qsonu': (get_qso_log_chi2_qsonu, 'qso_model'),
+    'qso_log_chi2nuNULL_chi2nu': (get_qso_log_chi2nuNULL_chi2nu,
+                                  'qso_model'),
+
+    # Fast Lomb-Scargle from Gatspy
+    'period_fast': (lomb_scargle_fast_period, 't', 'm', 'e'),
+
+    '_lomb_model': (lomb_scargle_model, 't', 'm', 'e'),
+    # These could easily be programmatically generated, but this is more readable
+    'freq1_freq': (get_lomb_frequency, '_lomb_model', 1),
+    'freq2_freq': (get_lomb_frequency, '_lomb_model', 2),
+    'freq3_freq': (get_lomb_frequency, '_lomb_model', 3),
+    'freq1_amplitude1': (get_lomb_amplitude, '_lomb_model', 1, 1),
+    'freq1_amplitude2': (get_lomb_amplitude, '_lomb_model', 1, 2),
+    'freq1_amplitude3': (get_lomb_amplitude, '_lomb_model', 1, 3),
+    'freq1_amplitude4': (get_lomb_amplitude, '_lomb_model', 1, 4),
+    'freq2_amplitude1': (get_lomb_amplitude, '_lomb_model', 2, 1),
+    'freq2_amplitude2': (get_lomb_amplitude, '_lomb_model', 2, 2),
+    'freq2_amplitude3': (get_lomb_amplitude, '_lomb_model', 2, 3),
+    'freq2_amplitude4': (get_lomb_amplitude, '_lomb_model', 2, 4),
+    'freq3_amplitude1': (get_lomb_amplitude, '_lomb_model', 3, 1),
+    'freq3_amplitude2': (get_lomb_amplitude, '_lomb_model', 3, 2),
+    'freq3_amplitude3': (get_lomb_amplitude, '_lomb_model', 3, 3),
+    'freq3_amplitude4': (get_lomb_amplitude, '_lomb_model', 3, 4),
+    #        'freq1_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 1, 1),
+    'freq1_rel_phase2': (get_lomb_rel_phase, '_lomb_model', 1, 2),
+    'freq1_rel_phase3': (get_lomb_rel_phase, '_lomb_model', 1, 3),
+    'freq1_rel_phase4': (get_lomb_rel_phase, '_lomb_model', 1, 4),
+    #        'freq2_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 2, 1),
+    'freq2_rel_phase2': (get_lomb_rel_phase, '_lomb_model', 2, 2),
+    'freq2_rel_phase3': (get_lomb_rel_phase, '_lomb_model', 2, 3),
+    'freq2_rel_phase4': (get_lomb_rel_phase, '_lomb_model', 2, 4),
+    #        'freq3_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 3, 1),
+    'freq3_rel_phase2': (get_lomb_rel_phase, '_lomb_model', 3, 2),
+    'freq3_rel_phase3': (get_lomb_rel_phase, '_lomb_model', 3, 3),
+    'freq3_rel_phase4': (get_lomb_rel_phase, '_lomb_model', 3, 4),
+    'freq_amplitude_ratio_21': (get_lomb_amplitude_ratio, '_lomb_model', 2),
+    'freq_amplitude_ratio_31': (get_lomb_amplitude_ratio, '_lomb_model', 3),
+    'freq_frequency_ratio_21': (get_lomb_frequency_ratio, '_lomb_model', 2),
+    'freq_frequency_ratio_31': (get_lomb_frequency_ratio, '_lomb_model', 3),
+    'freq_signif_ratio_21': (get_lomb_signif_ratio, '_lomb_model', 2),
+    'freq_signif_ratio_31': (get_lomb_signif_ratio, '_lomb_model', 3),
+    'freq1_lambda': (get_lomb_lambda, '_lomb_model'),
+    'freq1_signif': (get_lomb_signif, '_lomb_model'),
+    'freq_varrat': (get_lomb_varrat, '_lomb_model'),
+    'linear_trend': (get_lomb_trend, '_lomb_model'),
+    'freq_y_offset': (get_lomb_y_offset, '_lomb_model'),
+
+     # Other features that operate on Lomb-Scargle residuals
+    'freq_n_alias': (num_alias, '_lomb_model'),
+    'scatter_res_raw': (scatter_res_raw, 't', 'm', 'e', '_lomb_model'),
+
+    '_periodic_model': (periodic_model, '_lomb_model'),
+    '_period_folded_model': (period_folding, 't', 'm', 'e', '_lomb_model'),
+
+    'freq_model_max_delta_mags': (get_max_delta_mags, '_periodic_model'),
+    'freq_model_min_delta_mags': (get_min_delta_mags, '_periodic_model'),
+    'freq_model_phi1_phi2': (get_model_phi1_phi2, '_periodic_model'),
+    'fold2P_slope_10percentile': (get_fold2P_slope_percentile,
+                                  '_period_folded_model', 10),
+    'fold2P_slope_90percentile': (get_fold2P_slope_percentile,
+                                  '_period_folded_model', 90),
+    'medperc90_2p_p': (get_medperc90_2p_p, '_period_folded_model'),
+
+    '_p2p_model': (p2p_model, 't', 'm', 'freq1_freq'),
+    'p2p_scatter_2praw': (get_p2p_scatter_2praw, '_p2p_model'),
+    'p2p_scatter_over_mad': (get_p2p_scatter_over_mad, '_p2p_model'),
+    'p2p_scatter_pfold_over_mad': (get_p2p_scatter_pfold_over_mad,
+                                   '_p2p_model'),
+    'p2p_ssqr_diff_over_var': (get_p2p_ssqr_diff_over_var, '_p2p_model')
+}
+
+def generate_dask_graph(t, m, e):
+    full_graph = {'t': t, 'm': m, 'e': e}
+    full_graph.update(dask_feature_graph)
+    return full_graph
+
+
+extra_feature_docs = {
+    'n_epochs': 'Total number of observed values.',
+    'avg_err': 'Mean of the error estimates.',
+    'med_err': 'Median of error estimates.',
+    'std_err': 'Standard deviation of the error estimates.',
+    'total_time': 'Absolute difference between max and min of time values.',
+    'avgt': 'Mean of the time values.',
+    'mean': 'Mean of observed values.',
+    'cads': 'List of differences between successive time values (`np.diff(t)`).',
+    'cads_std': 'Standard deviation of `cads` (discrete difference between times).',
+    'cads_avg': 'Mean value of `cads` (discrete difference between times).',
+    'cads_med': 'Median value of `cads` (discrete difference between times).',
+    'avg_double_to_single_step':
+    'Mean value of ratios (t[i+2] - t[i]) / (t[i+2] - t[i+1]).',
+    'med_double_to_single_step':
+    'Median value of ratios (t[i+2] - t[i]) / (t[i+2] - t[i+1]).',
+    'std_double_to_single_step':
+    'Standard deviation of ratios (t[i+2] - t[i]) / (t[i+2] - t[i+1]).',
+    'all_times_nhist_numpeaks':
+    'Number of peaks (local maxima) in histogram of all possible delta_t\'s.',
+    'all_times_nhist_peak_val':
+    'Peak value in histogram of all possible delta_t\'s.'
+}
+
+
+feature_tags = {
+    'n_epochs': ['Astronomy', 'General'],
+    'avg_err': ['Astronomy', 'Error', 'General'],
+    'med_err': ['Astronomy', 'Error', 'General'],
+    'std_err': ['Astronomy', 'Error', 'General'],
+    'total_time': ['Astronomy', 'General'],
+    'avgt': ['Astronomy', 'General'],
+    'cads': ['Astronomy', 'General', 'Cadence'],
+    'cads_std': ['Astronomy', 'General', 'Cadence'],
+    'mean': ['Astronomy', 'General'],
+    'cads_avg': ['Astronomy', 'General', 'Cadence'],
+    'cads_med': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_1': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_10': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_20': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_30': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_40': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_50': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_100': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_500': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_1000': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_5000': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_10000': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_50000': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_100000': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_500000': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_1000000': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_5000000': ['Astronomy', 'General', 'Cadence'],
+    'cad_probs_10000000': ['Astronomy', 'General', 'Cadence'],
+    'double_to_single_step': ['Astronomy', 'General', 'Cadence'],
+    'avg_double_to_single_step': ['Astronomy', 'General', 'Cadence'],
+    'med_double_to_single_step': ['Astronomy', 'General', 'Cadence'],
+    'std_double_to_single_step': ['Astronomy', 'General', 'Cadence'],
+    'delta_t_hist': ['Astronomy', 'General', 'Cadence'],
+    'delta_t_nhist': ['Astronomy', 'General', 'Cadence'],
+    'nhist_peaks': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_numpeaks': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak_val': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak_1_to_2': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak_1_to_3': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak_2_to_3': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak_1_to_4': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak_2_to_4': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak_3_to_4': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak1_bin': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak2_bin': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak3_bin': ['Astronomy', 'General', 'Cadence'],
+    'all_times_nhist_peak4_bin': ['Astronomy', 'General', 'Cadence'],
+
+    # Standalone features (disconnected nodes)
+    'amplitude': ['Astronomy', 'General'],
+    'flux_percentile_ratio_mid20': ['Astronomy'],
+    'flux_percentile_ratio_mid35': ['Astronomy'],
+    'flux_percentile_ratio_mid50': ['Astronomy'],
+    'flux_percentile_ratio_mid65': ['Astronomy'],
+    'flux_percentile_ratio_mid80': ['Astronomy'],
+    'maximum': ['Astronomy', 'General'],
+    'max_slope': ['Astronomy', 'General'],
+    'median': ['Astronomy', 'General'],
+    'median_absolute_deviation': ['Astronomy', 'General'],
+    'minimum': ['Astronomy', 'General'],
+    'percent_amplitude': ['Astronomy', 'General'],
+    'percent_beyond_1_std': ['Astronomy', 'General'],
+    'percent_close_to_median': ['Astronomy', 'General'],
+    'percent_difference_flux_percentile': ['Astronomy', 'General'],
+    'skew': ['Astronomy', 'General'],
+    'std': ['Astronomy', 'General'],
+    'stetson_j': ['Astronomy', 'General'],
+    'stetson_k': ['Astronomy', 'General'],
+    'weighted_average': ['Astronomy', 'General'],
+
+    # QSO model features
+    'qso_model': ['Astronomy'],
+    'qso_log_chi2_qsonu': ['Astronomy'],
+    'qso_log_chi2nuNULL_chi2nu': ['Astronomy'],
+
+    # Fast Lomb-Scargle from Gatspy
+    'period_fast': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+
+    '_lomb_model': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    # These could easily be programmatically generated, but this is more readable
+    'freq1_freq': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq2_freq': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq3_freq': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq1_amplitude1': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq1_amplitude2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq1_amplitude3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq1_amplitude4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq2_amplitude1': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq2_amplitude2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq2_amplitude3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq2_amplitude4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq3_amplitude1': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq3_amplitude2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq3_amplitude3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq3_amplitude4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    #        'freq1_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 1, 1),
+    'freq1_rel_phase2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq1_rel_phase3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq1_rel_phase4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    #        'freq2_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 2, 1),
+    'freq2_rel_phase2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq2_rel_phase3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq2_rel_phase4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    #        'freq3_rel_phase1': (get_lomb_rel_phase, 'lomb_model', 3, 1),
+    'freq3_rel_phase2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq3_rel_phase3': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq3_rel_phase4': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_amplitude_ratio_21': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_amplitude_ratio_31': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_frequency_ratio_21': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_frequency_ratio_31': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_signif_ratio_21': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_signif_ratio_31': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq1_lambda': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq1_signif': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_varrat': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'linear_trend': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_y_offset': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+
+     # Other features that operate on Lomb-Scargle residuals
+    'freq_n_alias': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'scatter_res_raw': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+
+    '_periodic_model': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    '_period_folded_model': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+
+    'freq_model_max_delta_mags': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_model_min_delta_mags': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'freq_model_phi1_phi2': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'fold2P_slope_10percentile': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'fold2P_slope_90percentile': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'medperc90_2p_p': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+
+    '_p2p_model': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'p2p_scatter_2praw': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'p2p_scatter_over_mad': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'p2p_scatter_pfold_over_mad': ['Astronomy', 'Periodic', 'Lomb-Scargle'],
+    'p2p_ssqr_diff_over_var': ['Astronomy', 'Periodic', 'Lomb-Scargle']
+}
```

### Comparing `cesium-0.9.7/cesium/features/common_functions.py` & `cesium-0.9.9/cesium/features/common_functions.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,73 +1,73 @@
-import numpy as np
-from scipy import stats
-
-
-def max_slope(t, x):
-    """Compute the largest rate of change in the observed data."""
-    slopes = np.diff(x) / np.diff(t)
-    return np.max(np.abs(slopes))
-
-
-def maximum(x):
-    """Maximum observed value."""
-    return np.max(x)
-
-
-def median(x):
-    """Median of observed values."""
-    return np.median(x)
-
-
-def median_absolute_deviation(x):
-    """Median absolute deviation (from the median) of the observed values."""
-    return np.median(np.abs(x - np.median(x)))
-
-
-def minimum(x):
-    """Minimum observed value."""
-    return np.min(x)
-
-
-def percent_beyond_1_std(x, e):
-    """Percentage of values more than 1 std. dev. from the weighted average."""
-    dists_from_mu = x - weighted_average(x, e)
-    return np.mean(np.abs(dists_from_mu) > weighted_std_dev(x, e))
-
-
-def percent_close_to_median(x, window_frac=0.1):
-    """Percentage of values within window_frac*(max(x)-min(x)) of median."""
-    window = (x.max() - x.min()) * window_frac
-    return np.mean(np.abs(x - np.median(x)) < window)
-
-
-def skew(x):
-    """Skewness of a dataset. Approximately 0 for Gaussian data."""
-    return stats.skew(x)
-
-
-def std(x):
-    """Standard deviation of observed values."""
-    return np.std(x)
-
-
-def weighted_average(x, e):
-    """Arithmetic mean of observed values, weighted by measurement errors."""
-    return np.average(x, weights=1. / (e**2))
-
-
-def weighted_average_std_err(x, e):
-    """
-    Standard deviation of the sample weighted average of values x with
-    measurement errors e.
-
-    Note: this is not the same as the weighted sample standard deviation;
-    this value only quantifies the measurement errors, not the dispersion of
-    the data.
-    """
-    return np.sqrt(1.0 / np.sum(e**2))
-
-
-def weighted_std_dev(x, e):
-    """Standard deviation of observed values, weighted by measurement errors."""
-    return np.sqrt(np.average((x - weighted_average(x, e))**2,
-                              weights=1. / (e**2)))
+import numpy as np
+from scipy import stats
+
+
+def max_slope(t, x):
+    """Compute the largest rate of change in the observed data."""
+    slopes = np.diff(x) / np.diff(t)
+    return np.max(np.abs(slopes))
+
+
+def maximum(x):
+    """Maximum observed value."""
+    return np.max(x)
+
+
+def median(x):
+    """Median of observed values."""
+    return np.median(x)
+
+
+def median_absolute_deviation(x):
+    """Median absolute deviation (from the median) of the observed values."""
+    return np.median(np.abs(x - np.median(x)))
+
+
+def minimum(x):
+    """Minimum observed value."""
+    return np.min(x)
+
+
+def percent_beyond_1_std(x, e):
+    """Percentage of values more than 1 std. dev. from the weighted average."""
+    dists_from_mu = x - weighted_average(x, e)
+    return np.mean(np.abs(dists_from_mu) > weighted_std_dev(x, e))
+
+
+def percent_close_to_median(x, window_frac=0.1):
+    """Percentage of values within window_frac*(max(x)-min(x)) of median."""
+    window = (x.max() - x.min()) * window_frac
+    return np.mean(np.abs(x - np.median(x)) < window)
+
+
+def skew(x):
+    """Skewness of a dataset. Approximately 0 for Gaussian data."""
+    return stats.skew(x)
+
+
+def std(x):
+    """Standard deviation of observed values."""
+    return np.std(x)
+
+
+def weighted_average(x, e):
+    """Arithmetic mean of observed values, weighted by measurement errors."""
+    return np.average(x, weights=1. / (e**2))
+
+
+def weighted_average_std_err(x, e):
+    """
+    Standard deviation of the sample weighted average of values x with
+    measurement errors e.
+
+    Note: this is not the same as the weighted sample standard deviation;
+    this value only quantifies the measurement errors, not the dispersion of
+    the data.
+    """
+    return np.sqrt(1.0 / np.sum(e**2))
+
+
+def weighted_std_dev(x, e):
+    """Standard deviation of observed values, weighted by measurement errors."""
+    return np.sqrt(np.average((x - weighted_average(x, e))**2,
+                              weights=1. / (e**2)))
```

### Comparing `cesium-0.9.7/cesium/features/cadence_features.py` & `cesium-0.9.9/cesium/features/cadence_features.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,87 +1,87 @@
-import numpy as np
-import scipy.stats as stats
-
-
-__all__ = ['double_to_single_step', 'cad_prob', 'delta_t_hist',
-           'normalize_hist', 'find_sorted_peaks', 'peak_ratio', 'peak_bin']
-
-
-def double_to_single_step(cads):
-    """Ratios (t[i+2] - t[i]) / (t[i+1] - t[i])."""
-    cads = np.asarray(cads)
-    return (cads[2:] + cads[:-2]) / (cads[1:-1] - cads[:-2])
-
-
-def cad_prob(cads, time):
-    """Given the observed distribution of time lags `cads`, compute the probability
-    that the next observation occurs within `time` minutes of an arbitrary epoch.
-    """
-    return stats.percentileofscore(cads, float(time) / (24.0 * 60.0)) / 100.0
-
-
-def delta_t_hist(t, nbins=50, conv_oversample=50):
-    """Build histogram of all possible |t_i - t_j|'s.
-
-    For efficiency, we construct the histogram via a convolution of the PDF
-    rather than by actually computing all the differences. For better accuracy
-    we use a factor `conv_oversample` more bins when performing the convolution
-    and then aggregate the result to have `nbins` total values.
-    """
-    f, x = np.histogram(t, bins=conv_oversample * nbins)
-    g = np.convolve(f, f[::-1])[len(f) - 1:]  # Discard negative domain
-    g[0] -= len(t)  # First bin is double-counted because of i=j terms
-    hist = g.reshape((-1, conv_oversample)).sum(axis=1)  # Combine bins
-    return hist
-
-
-def normalize_hist(hist, total_time):
-    """Normalize histogram such that integral from t_min to t_max equals 1.
-    cf. np.histogram(..., density=True).
-    """
-    return hist / (total_time * np.mean(hist))
-
-
-def find_sorted_peaks(x):
-    """Find peaks, i.e. local maxima, of an array. Interior points are peaks if
-    they are greater than both their neighbors, and edge points are peaks if
-    they are greater than their only neighbor. In the case of ties, we
-    (arbitrarily) choose the first index in the sequence of equal values as the
-    peak.
-    Returns a list of tuples (i, x[i]) of peak indices i and values x[i],
-    sorted in decreasing order by peak value.
-    """
-    peak_inds = []
-    nbins = len(x)
-    for i in range(nbins):
-        if i == 0 or x[i] > x[i - 1]:  # Increasing from left
-            if i == nbins - 1 or x[i] > x[i + 1]:  # Increasing from right
-                peak_inds.append(i)
-            elif x[i] == x[i + 1]:  # Tied; check the next non-equal value
-                for j in range(i + 1, nbins):
-                    if x[j] != x[i]:
-                        if x[j] < x[i]:
-                            peak_inds.append(i)
-                        break
-                if j == nbins - 1 and x[i] == x[j]:  # Reached the end
-                    peak_inds.append(i)
-    sorted_peak_inds = sorted(peak_inds, key=lambda i: x[i], reverse=True)
-    return list(zip(sorted_peak_inds, x[sorted_peak_inds]))
-
-
-def peak_ratio(peaks, i, j):
-    """Compute the ratio of the values of the ith and jth largest peaks. Peaks is a list
-    of tuples (i, x[i]) of peak indices i and values x[i], sorted in decreasing order
-    by peak value."""
-    if len(peaks) > i and len(peaks) > j:
-        return peaks[i][1] / peaks[j][1]
-    else:
-        return np.nan
-
-
-def peak_bin(peaks, i):
-    """Return the (bin) index of the ith largest peak. Peaks is a list of tuples (i, x[i])
-    of peak indices i and values x[i], sorted in decreasing order by peak value."""
-    if len(peaks) > i:
-        return peaks[i][0]
-    else:
-        return np.nan
+import numpy as np
+import scipy.stats as stats
+
+
+__all__ = ['double_to_single_step', 'cad_prob', 'delta_t_hist',
+           'normalize_hist', 'find_sorted_peaks', 'peak_ratio', 'peak_bin']
+
+
+def double_to_single_step(cads):
+    """Ratios (t[i+2] - t[i]) / (t[i+1] - t[i])."""
+    cads = np.asarray(cads)
+    return (cads[2:] + cads[:-2]) / (cads[1:-1] - cads[:-2])
+
+
+def cad_prob(cads, time):
+    """Given the observed distribution of time lags `cads`, compute the probability
+    that the next observation occurs within `time` minutes of an arbitrary epoch.
+    """
+    return stats.percentileofscore(cads, float(time) / (24.0 * 60.0)) / 100.0
+
+
+def delta_t_hist(t, nbins=50, conv_oversample=50):
+    """Build histogram of all possible |t_i - t_j|'s.
+
+    For efficiency, we construct the histogram via a convolution of the PDF
+    rather than by actually computing all the differences. For better accuracy
+    we use a factor `conv_oversample` more bins when performing the convolution
+    and then aggregate the result to have `nbins` total values.
+    """
+    f, x = np.histogram(t, bins=conv_oversample * nbins)
+    g = np.convolve(f, f[::-1])[len(f) - 1:]  # Discard negative domain
+    g[0] -= len(t)  # First bin is double-counted because of i=j terms
+    hist = g.reshape((-1, conv_oversample)).sum(axis=1)  # Combine bins
+    return hist
+
+
+def normalize_hist(hist, total_time):
+    """Normalize histogram such that integral from t_min to t_max equals 1.
+    cf. np.histogram(..., density=True).
+    """
+    return hist / (total_time * np.mean(hist))
+
+
+def find_sorted_peaks(x):
+    """Find peaks, i.e. local maxima, of an array. Interior points are peaks if
+    they are greater than both their neighbors, and edge points are peaks if
+    they are greater than their only neighbor. In the case of ties, we
+    (arbitrarily) choose the first index in the sequence of equal values as the
+    peak.
+    Returns a list of tuples (i, x[i]) of peak indices i and values x[i],
+    sorted in decreasing order by peak value.
+    """
+    peak_inds = []
+    nbins = len(x)
+    for i in range(nbins):
+        if i == 0 or x[i] > x[i - 1]:  # Increasing from left
+            if i == nbins - 1 or x[i] > x[i + 1]:  # Increasing from right
+                peak_inds.append(i)
+            elif x[i] == x[i + 1]:  # Tied; check the next non-equal value
+                for j in range(i + 1, nbins):
+                    if x[j] != x[i]:
+                        if x[j] < x[i]:
+                            peak_inds.append(i)
+                        break
+                if j == nbins - 1 and x[i] == x[j]:  # Reached the end
+                    peak_inds.append(i)
+    sorted_peak_inds = sorted(peak_inds, key=lambda i: x[i], reverse=True)
+    return list(zip(sorted_peak_inds, x[sorted_peak_inds]))
+
+
+def peak_ratio(peaks, i, j):
+    """Compute the ratio of the values of the ith and jth largest peaks. Peaks is a list
+    of tuples (i, x[i]) of peak indices i and values x[i], sorted in decreasing order
+    by peak value."""
+    if len(peaks) > i and len(peaks) > j:
+        return peaks[i][1] / peaks[j][1]
+    else:
+        return np.nan
+
+
+def peak_bin(peaks, i):
+    """Return the (bin) index of the ith largest peak. Peaks is a list of tuples (i, x[i])
+    of peak indices i and values x[i], sorted in decreasing order by peak value."""
+    if len(peaks) > i:
+        return peaks[i][0]
+    else:
+        return np.nan
```

### Comparing `cesium-0.9.7/cesium/features/_lomb_scargle.pxd` & `cesium-0.9.9/cesium/features/_lomb_scargle.pxd`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,12 +1,12 @@
-cdef extern from "_lomb_scargle.h":
-     void lomb_scargle(int numt, int numf, int nharm, int detrend_order,
-                       double psd[], double cn[], double wth[],
-                       double sinx[], double cosx[], double sinx_step[],
-                       double cosx_step[], double sinx_back[],
-                       double cosx_back[], double sinx_smallstep[],
-                       double cosx_smallstep[], double hat_matr[],
-                       double hat_hat[], double hat0[],
-                       double soln[], double chi0, double freq_zoom,
-                       double psdmin, double tone_control,
-                       double lambda0[], double lambda0_range[],
-                       double Tr[], int ifreq[])
+cdef extern from "_lomb_scargle.h":
+     void lomb_scargle(int numt, int numf, int nharm, int detrend_order,
+                       double psd[], double cn[], double wth[],
+                       double sinx[], double cosx[], double sinx_step[],
+                       double cosx_step[], double sinx_back[],
+                       double cosx_back[], double sinx_smallstep[],
+                       double cosx_smallstep[], double hat_matr[],
+                       double hat_hat[], double hat0[],
+                       double soln[], double chi0, double freq_zoom,
+                       double psdmin, double tone_control,
+                       double lambda0[], double lambda0_range[],
+                       double Tr[], int ifreq[])
```

### Comparing `cesium-0.9.7/cesium/features/_eigs.h` & `cesium-0.9.9/cesium/features/_eigs.h`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,138 +1,138 @@
-#include <math.h>
-
-static inline double SQR(double a) {
-    return (a == 0.0 ? 0.0 : a*a);
-}
-
-static inline double SIGN(double a,double b) {
-    return ((b) >= 0.0 ? fabs(a) : -fabs(a));
-}
-
-double pythag(double a, double b) {
-        double absa,absb;
-        absa=fabs(a);
-        absb=fabs(b);
-        if (absa > absb) return absa*sqrt(1.0+SQR(absb/absa));
-        else return (absb == 0.0 ? 0.0 : absb*sqrt(1.0+SQR(absa/absb)));
-}
-
-static inline void tred2(double a[], int n, double d[], double e[]) {
-        int l,k,j,i;
-        double scale,hh,h,g,f;
-
-        for (i=n-1;i>=1;i--) {
-                l=i-1;
-                h=scale=0.0;
-                if (l > 0) {
-                        for (k=0;k<=l;k++)
-                                scale += fabs(a[k+i*n]);
-                        if (scale == 0.0)
-                                e[i]=a[l+i*n];
-                        else {
-                                for (k=0;k<=l;k++) {
-                                        a[k+i*n] /= scale;
-                                        h += a[k+i*n]*a[k+i*n];
-                                }
-                                f=a[l+i*n];
-                                g=(f >= 0.0 ? -sqrt(h) : sqrt(h));
-                                e[i]=scale*g;
-                                h -= f*g;
-                                a[l+i*n]=f-g;
-                                f=0.0;
-                                for (j=0;j<=l;j++) {
-                                        a[i+j*n]=a[j+i*n]/h;
-                                        g=0.0;
-                                        for (k=0;k<=j;k++)
-                                                g += a[k+j*n]*a[k+i*n];
-                                        for (k=j+1;k<=l;k++)
-                                                g += a[j+k*n]*a[k+i*n];
-                                        e[j]=g/h;
-                                        f += e[j]*a[j+i*n];
-                                }
-                                hh=f/(h+h);
-                                for (j=0;j<=l;j++) {
-                                        f=a[j+i*n];
-                                        e[j]=g=e[j]-hh*f;
-                                        for (k=0;k<=j;k++)
-                                                a[k+j*n] -= (f*e[k]+g*a[k+i*n]);
-                                }
-                        }
-                } else
-                        e[i]=a[l+i*n];
-                d[i]=h;
-        }
-        d[0]=0.0;
-        e[0]=0.0;
-        for (i=0;i<n;i++) {
-                l=i-1;
-                if (d[i]) {
-                        for (j=0;j<=l;j++) {
-                                g=0.0;
-                                for (k=0;k<=l;k++)
-                                        g += a[k+i*n]*a[j+k*n];
-                                for (k=0;k<=l;k++)
-                                        a[j+k*n] -= g*a[i+k*n];
-                        }
-                }
-                d[i]=a[i+i*n];
-                a[i+i*n]=1.0;
-                for (j=0;j<=l;j++) a[i+j*n]=a[j+i*n]=0.0;
-        }
-}
-
-void tqli(double d[], double e[], int n, double z[])
-{
-        int m,l,iter,i,k;
-        double s,r,p,g,f,dd,c,b;
-
-        for (i=1;i<n;i++) e[i-1]=e[i];
-        e[n-1]=0.0;
-        for (l=0;l<n;l++) {
-                iter=0;
-                do {
-                        for (m=l;m<n-1;m++) {
-                                dd=fabs(d[m])+fabs(d[m+1]);
-                                if ((double)(fabs(e[m])+dd) == dd) break;
-                        }
-                        if (m != l) {
-                                if (iter++ == 30) break;
-                                g=(d[l+1]-d[l])/(2.0*e[l]);
-                                r=pythag(g,1.0);
-                                g=d[m]-d[l]+e[l]/(g+SIGN(r,g));
-                                s=c=1.0;
-                                p=0.0;
-                                for (i=m-1;i>=l;i--) {
-                                        f=s*e[i];
-                                        b=c*e[i];
-                                        e[i+1]=(r=pythag(f,g));
-                                        if (r == 0.0) {
-                                                d[i+1] -= p;
-                                                e[m]=0.0;
-                                                break;
-                                        }
-                                        s=f/r;
-                                        c=g/r;
-                                        g=d[i+1]-p;
-                                        r=(d[i]-g)*s+2.0*c*b;
-                                        d[i+1]=g+(p=s*r);
-                                        g=c*r-b;
-                                        for (k=0;k<n;k++) {
-                                                f=z[i+1+k*n];
-                                                z[i+1+k*n]=s*z[i+k*n]+c*f;
-                                                z[i+k*n]=c*z[i+k*n]-s*f;
-                                        }
-                                }
-                                if (r == 0.0 && i >= l) continue;
-                                d[l] -= p;
-                                e[l]=g;
-                                e[m]=0.0;
-                        }
-                } while (m != l);
-        }
-}
-
-static inline void get_eigs(int np,double x[],double d[]) {
-      double e[np];
-      tred2(x,np,d,e);
-      tqli(d,e,np,x);
-}
+#include <math.h>
+
+static inline double SQR(double a) {
+    return (a == 0.0 ? 0.0 : a*a);
+}
+
+static inline double SIGN(double a,double b) {
+    return ((b) >= 0.0 ? fabs(a) : -fabs(a));
+}
+
+double pythag(double a, double b) {
+        double absa,absb;
+        absa=fabs(a);
+        absb=fabs(b);
+        if (absa > absb) return absa*sqrt(1.0+SQR(absb/absa));
+        else return (absb == 0.0 ? 0.0 : absb*sqrt(1.0+SQR(absa/absb)));
+}
+
+static inline void tred2(double a[], int n, double d[], double e[]) {
+        int l,k,j,i;
+        double scale,hh,h,g,f;
+
+        for (i=n-1;i>=1;i--) {
+                l=i-1;
+                h=scale=0.0;
+                if (l > 0) {
+                        for (k=0;k<=l;k++)
+                                scale += fabs(a[k+i*n]);
+                        if (scale == 0.0)
+                                e[i]=a[l+i*n];
+                        else {
+                                for (k=0;k<=l;k++) {
+                                        a[k+i*n] /= scale;
+                                        h += a[k+i*n]*a[k+i*n];
+                                }
+                                f=a[l+i*n];
+                                g=(f >= 0.0 ? -sqrt(h) : sqrt(h));
+                                e[i]=scale*g;
+                                h -= f*g;
+                                a[l+i*n]=f-g;
+                                f=0.0;
+                                for (j=0;j<=l;j++) {
+                                        a[i+j*n]=a[j+i*n]/h;
+                                        g=0.0;
+                                        for (k=0;k<=j;k++)
+                                                g += a[k+j*n]*a[k+i*n];
+                                        for (k=j+1;k<=l;k++)
+                                                g += a[j+k*n]*a[k+i*n];
+                                        e[j]=g/h;
+                                        f += e[j]*a[j+i*n];
+                                }
+                                hh=f/(h+h);
+                                for (j=0;j<=l;j++) {
+                                        f=a[j+i*n];
+                                        e[j]=g=e[j]-hh*f;
+                                        for (k=0;k<=j;k++)
+                                                a[k+j*n] -= (f*e[k]+g*a[k+i*n]);
+                                }
+                        }
+                } else
+                        e[i]=a[l+i*n];
+                d[i]=h;
+        }
+        d[0]=0.0;
+        e[0]=0.0;
+        for (i=0;i<n;i++) {
+                l=i-1;
+                if (d[i]) {
+                        for (j=0;j<=l;j++) {
+                                g=0.0;
+                                for (k=0;k<=l;k++)
+                                        g += a[k+i*n]*a[j+k*n];
+                                for (k=0;k<=l;k++)
+                                        a[j+k*n] -= g*a[i+k*n];
+                        }
+                }
+                d[i]=a[i+i*n];
+                a[i+i*n]=1.0;
+                for (j=0;j<=l;j++) a[i+j*n]=a[j+i*n]=0.0;
+        }
+}
+
+void tqli(double d[], double e[], int n, double z[])
+{
+        int m,l,iter,i,k;
+        double s,r,p,g,f,dd,c,b;
+
+        for (i=1;i<n;i++) e[i-1]=e[i];
+        e[n-1]=0.0;
+        for (l=0;l<n;l++) {
+                iter=0;
+                do {
+                        for (m=l;m<n-1;m++) {
+                                dd=fabs(d[m])+fabs(d[m+1]);
+                                if ((double)(fabs(e[m])+dd) == dd) break;
+                        }
+                        if (m != l) {
+                                if (iter++ == 30) break;
+                                g=(d[l+1]-d[l])/(2.0*e[l]);
+                                r=pythag(g,1.0);
+                                g=d[m]-d[l]+e[l]/(g+SIGN(r,g));
+                                s=c=1.0;
+                                p=0.0;
+                                for (i=m-1;i>=l;i--) {
+                                        f=s*e[i];
+                                        b=c*e[i];
+                                        e[i+1]=(r=pythag(f,g));
+                                        if (r == 0.0) {
+                                                d[i+1] -= p;
+                                                e[m]=0.0;
+                                                break;
+                                        }
+                                        s=f/r;
+                                        c=g/r;
+                                        g=d[i+1]-p;
+                                        r=(d[i]-g)*s+2.0*c*b;
+                                        d[i+1]=g+(p=s*r);
+                                        g=c*r-b;
+                                        for (k=0;k<n;k++) {
+                                                f=z[i+1+k*n];
+                                                z[i+1+k*n]=s*z[i+k*n]+c*f;
+                                                z[i+k*n]=c*z[i+k*n]-s*f;
+                                        }
+                                }
+                                if (r == 0.0 && i >= l) continue;
+                                d[l] -= p;
+                                e[l]=g;
+                                e[m]=0.0;
+                        }
+                } while (m != l);
+        }
+}
+
+static inline void get_eigs(int np,double x[],double d[]) {
+      double e[np];
+      tred2(x,np,d,e);
+      tqli(d,e,np,x);
+}
```

### Comparing `cesium-0.9.7/cesium/features/_lomb_scargle.h` & `cesium-0.9.9/cesium/features/_lomb_scargle.h`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,226 +1,226 @@
-#include <math.h>
-#include "_eigs.h"
-
-static inline void copy_sincos (int numt, double sinx0[], double cosx0[], double sinx[], double cosx[]) {
-    int i;
-    for (i=0;i<numt;i++) {
-        sinx[i] = sinx0[i];
-        cosx[i] = cosx0[i];
-    }
-}
-
-static inline void update_sincos (int numt, double sinx0[], double cosx0[], double sinx[], double cosx[], int offset) {
-    int i1, i;
-    double tmp;
-    for (i=0;i<numt;i++) {
-        i1 = i+offset;
-        sinx[i1] = cosx0[i]*(tmp=sinx[i]) + sinx0[i]*cosx[i];
-        cosx[i1] = cosx0[i]*cosx[i] - sinx0[i]*tmp;
-    }
-}
-
-static inline double _lomb_scargle(int numt, double cn[], double sinx[], double cosx[], double st, double ct, double cst) {
-  double cs=0.,s2=0.,c2=0.,sh=0.,ch=0.,px=0.,detm;
-  int i;
-  for (i=0;i<numt;i++) {
-    cs += cosx[i]*sinx[i];
-    c2 += cosx[i]*cosx[i];
-    sh += sinx[i]*cn[i];
-    ch += cosx[i]*cn[i];
-  }
-  cs -= cst; s2 = 1-c2-st; c2 -= ct;
-  detm = c2*s2 - cs*cs;
-  if (detm>0) px = ( c2*sh*sh - 2.*cs*ch*sh + s2*ch*ch ) / detm;
-  return px;
-}
-
-static inline void calc_dotprod(int numt, double sinx[], double cosx[], double wt[], int dord, double *st, double *ct) {
-    int i;
-    unsigned long n2=numt*dord;
-    for (*st=0,*ct=0,i=0;i<numt;i++) {
-        *st += sinx[i]*wt[i + n2];
-        *ct += cosx[i]*wt[i + n2];
-    }
-}
-
-static inline double do_lomb(int numt, int detrend_order, double cn[], double sinx[], double cosx[], double wth[]) {
-    int i;
-    double st,cst,ct,st0,ct0;
-    for (i=0,ct=0,st=0,cst=0;i<=detrend_order;i++) {
-        calc_dotprod(numt,sinx,cosx,wth,i,&st0,&ct0);
-        st += st0*st0; ct += ct0*ct0; cst += st0*ct0;
-    }
-    return _lomb_scargle(numt,cn,sinx,cosx,st,ct,cst);
-}
-
-static inline double do_lomb_zoom(int numt, int detrend_order, double *cn, double *sinx, double *cosx, double *sinx1, double *cosx1, double *sinx_back, double *cosx_back, double *sinx_smallstep, double *cosx_smallstep, double *wth, double freq_zoom, int *ifreq) {
-    int i;
-    double px,pxmax=0.;
-    copy_sincos(numt,sinx,cosx,sinx1,cosx1);
-    update_sincos(numt, sinx_back, cosx_back, sinx1, cosx1, 0);
-    for (i=0;i<freq_zoom;i++) {
-        px = do_lomb(numt,detrend_order,cn,sinx1,cosx1,wth);
-        if (px>pxmax) {
-            pxmax=px;
-            *ifreq = i;
-        }
-        update_sincos(numt, sinx_smallstep, cosx_smallstep, sinx1, cosx1, 0);
-    }
-    copy_sincos(numt,sinx,cosx,sinx1,cosx1);
-    if (*ifreq<freq_zoom/2.) {
-        update_sincos(numt, sinx_back, cosx_back, sinx1, cosx1, 0);
-        for (i=0;i<*ifreq;i++) update_sincos(numt, sinx_smallstep, cosx_smallstep, sinx1, cosx1, 0);
-    } else {
-        for (i=0;i<*ifreq-freq_zoom/2.;i++) update_sincos(numt, sinx_smallstep, cosx_smallstep, sinx1, cosx1, 0);
-    }
-    return px;
-}
-
-static inline void def_hat(int numt, int nharm, int detrend_order, double hat_matr[], double hat0[], double sinx[], double cosx[], double wt[], double cn[], double hat_hat[], double vec[], double lambda0) {
-    int i,j=numt*nharm,k,j1,npar=2*nharm,dord1=detrend_order+1;
-    double sx0[numt],cx0[numt],ct,st,sum;
-    for (i=0;i<numt;i++) {
-        sx0[i] = (hat_matr[i]=sinx[i])/wt[i]; cx0[i] = (hat_matr[i+j]=cosx[i])/wt[i];
-    }
-    for (j=0;j<nharm-1;j++) {
-        update_sincos (numt,sx0,cx0,hat_matr+j*numt,hat_matr+(j+nharm)*numt,numt);
-        for (i=0;i<=detrend_order;i++) calc_dotprod(numt,hat_matr+j*numt,hat_matr+(j+nharm)*numt,wt,i,&hat0[i+j*dord1],&hat0[i+(j+nharm)*dord1]);
-    }
-    for (i=0;i<=detrend_order;i++) calc_dotprod(numt,hat_matr+j*numt,hat_matr+(j+nharm)*numt,wt,i,&hat0[i+j*dord1],&hat0[i+(j+nharm)*dord1]);
-    for (j=0;j<npar;j++) {
-        for (k=j;k<npar;k++) {
-            for (sum=0,i=0;i<numt;i++) sum += hat_matr[i+j*numt]*hat_matr[i+k*numt];
-            for (i=0;i<=detrend_order;i++) sum -= hat0[i+j*dord1]*hat0[i+k*dord1];
-            hat_hat[k+j*npar] = sum;
-        }
-    }
-    for (j=0;j<npar;j++) {
-        ct = (1.+(j%nharm)); ct*=ct;
-        for (sum=0,i=0;i<numt;i++) sum += hat_matr[i+j*numt]*cn[i];
-        vec[j] = sum/ct;
-        for (k=j;k<npar;k++) {
-            st = (1.+(k%nharm)); st*=st;
-            hat_hat[k+j*npar] /= (ct*st);
-            hat_hat[j+k*npar] = hat_hat[k+j*npar];
-        }
-        hat_hat[j+j*npar] += numt*lambda0;
-    }
-}
-
-static inline double optimize_px(int n, int numt, double p[], double hat_hat[], double eigs[], double *lambda0, double *lambda0_range, double chi0, double tc, double *Trace) {
-    int i,j,k,niter=50;
-    double px,lambda,dlambda,lambda_best,eigs1,px_max=0.,start=lambda0_range[0],stop=lambda0_range[1];
-    double m[n][n],s1,s2,s3,sum,v[n],tcn=tc/numt,Tr,Tr0=(1-3./numt)/(1.+tcn);
-
-    for (i=0;i<n;i++) {
-      for (j=i;j<n;j++) m[j][i] = 0.;
-    }
-    for (k=0;k<n;k++) {
-        s1 = 1.+(k%(n/2)); s1*=s1; s1*=s1;
-        for (i=0;i<n;i++) {
-            for (j=i;j<n;j++) m[j][i] += hat_hat[i+k*n]*hat_hat[j+k*n]/s1;
-        }
-    }
-    lambda = start; dlambda = exp(log(stop/start)/niter);
-    for (k=0;k<3;k++) {
-        for (j=0;j<=niter;j++) {
-          Tr = 1-2.*n/numt; px=chi0; s1=0; s2=0, s3=0;
-          for (i=0;i<n;i++) {
-              eigs1 = eigs[i] + numt*(lambda-(*lambda0));
-              Tr += 2.*lambda/eigs1;
-              s1 += p[i]*(v[i]=p[i]/eigs1);
-              s2 += p[i]*v[i]/eigs1;
-              s3 += v[i]* m[i][i]* v[i];
-              for (k=0;k<i;k++) s3 += 2.*v[i] *m[i][k] *v[k];
-           }
-           px = chi0  - (chi0-s1-s2*numt*lambda)*(1.+tcn*(s2/s3))*Tr0/Tr;
-           if (px>px_max && Tr>0) {
-               px_max = px;
-               lambda_best = lambda;
-               *Trace = Tr;
-           }
-           lambda *= dlambda;
-        }
-        if (lambda_best-1.e-5>start) start=lambda_best/dlambda;
-        else break;
-        if(lambda_best+1.e-5<stop) stop = lambda_best*dlambda;
-        else break;
-        dlambda = exp(log(stop/start)/niter);
-    }
-   *lambda0 = lambda_best;
-    return px_max;
-}
-
-static inline void inv_hat(int n, double hat_hat[], double vec[], double vec1[], double eigs[], double lam0, double lam) {
-    int i,j,k;
-    double tmp[n][n], sum;
-    for (i=0;i<n;i++) {
-        for (j=i;j<n;j++) {
-            for (sum=0,k=0;k<n;k++) sum += hat_hat[k+i*n]*hat_hat[k+j*n]/(eigs[k]+lam-lam0);
-            tmp[i][j] = sum;
-        }
-    }
-    for (i=0;i<n;i++) {
-        for (j=i;j<n;j++) hat_hat[j+i*n] = hat_hat[i+j*n] = tmp[i][j];
-        for (sum=0,j=0;j<n;j++) sum += hat_hat[j+i*n]*vec[j];
-        vec1[i] = sum;
-    }
-}
-
-static inline double refine_psd(int numt, int nharm, int detrend_order, double hat_matr[], double hat0[], double hat_hat[], double sinx[], double cosx[], double wt[], double cn[], double vec1[], double *lambda0, double *lambda0_range, double chi0, double tc, double *Tr, int inv) {
-    int i,j,k,npar=2*nharm;
-    double p[npar],vec[npar],eigs[npar],sum,px,lambda00=*lambda0;
-    def_hat(numt,nharm,detrend_order,hat_matr,hat0,sinx,cosx,wt,cn,hat_hat,vec,*lambda0);
-    get_eigs(npar,hat_hat,eigs);
-    for (i=0;i<npar;i++) {
-        for (sum=0,j=0;j<npar;j++) sum += hat_hat[i+j*npar] * vec[j];
-        p[i] = sum;
-    }
-    px = optimize_px(npar,numt,p,hat_hat,eigs,lambda0,lambda0_range,chi0,tc,Tr);
-    if (inv==1) inv_hat(npar,hat_hat,vec,vec1,eigs,numt*lambda00,numt*(*lambda0));
-    return px;
-}
-
-void lomb_scargle(int numt, int numf, int nharm, int detrend_order,
-                  double psd[], double cn[], double wth[], double sinx[],
-                  double cosx[], double sinx_step[], double cosx_step[],
-                  double sinx_back[], double cosx_back[],
-                  double sinx_smallstep[], double cosx_smallstep[],
-                  double hat_matr[], double hat_hat[],
-                  double hat0[], double soln[], double chi0,
-                  double freq_zoom, double psdmin, double tone_control,
-                  double lambda0[], double lambda0_range[],
-                  double Tr[], int ifreq[])
-{
-  int i,k,npar=2*(int)nharm,ifr=(int)(freq_zoom)/2;
-  unsigned long j;
-  unsigned long jmax=0;
-  *ifreq = ifr;
-  double psdmax=0.,psd0max=0.,Trace,sinx1[numt],cosx1[numt],sinx2[numt],cosx2[numt],lambda,px,pxmax;
-  for (j=0;j<numf;j++) {
-      // do a simple lomb-scargle, sin+cos fit
-      psd[j] = do_lomb(numt,detrend_order,cn,sinx,cosx,wth);
-      if (psd[j]>psd0max && psdmax==0) {
-          psd0max = psd[j];
-          copy_sincos(numt,sinx,cosx,sinx2,cosx2);
-          jmax = j;
-      }
-      // refine the fit around significant sin+cos fits
-      if (psd[j]>(double)psdmin) {
-          // first let the frequency vary slightly
-          px = do_lomb_zoom(numt,detrend_order, cn, sinx, cosx, sinx1, cosx1, sinx_back, cosx_back, sinx_smallstep, cosx_smallstep, wth, freq_zoom, &ifr);
-          lambda = *lambda0;
-          // now fit a multi-harmonic model with generalized cross-validation to avoid over-fitting
-          psd[j] = refine_psd(numt,nharm,detrend_order,hat_matr,hat0,hat_hat,sinx1,cosx1,wth,cn,soln,&lambda,lambda0_range,chi0,tone_control,&Trace,0);
-          if (psd[j]>psdmax) {
-              copy_sincos(numt,sinx1,cosx1,sinx2,cosx2);
-              psdmax=psd[j];
-              *ifreq = ifr;
-              jmax = j;
-          }
-      }
-      update_sincos(numt, sinx_step, cosx_step, sinx, cosx, 0);
-  }
-  // finally, rerun at the best-fit period so we get some statistics
-  psd[jmax] = refine_psd(numt,nharm,detrend_order,hat_matr,hat0,hat_hat,sinx2,cosx2,wth,cn,soln,lambda0,lambda0_range,chi0,tone_control,Tr,1);
-}
+#include <math.h>
+#include "_eigs.h"
+
+static inline void copy_sincos (int numt, double sinx0[], double cosx0[], double sinx[], double cosx[]) {
+    int i;
+    for (i=0;i<numt;i++) {
+        sinx[i] = sinx0[i];
+        cosx[i] = cosx0[i];
+    }
+}
+
+static inline void update_sincos (int numt, double sinx0[], double cosx0[], double sinx[], double cosx[], int offset) {
+    int i1, i;
+    double tmp;
+    for (i=0;i<numt;i++) {
+        i1 = i+offset;
+        sinx[i1] = cosx0[i]*(tmp=sinx[i]) + sinx0[i]*cosx[i];
+        cosx[i1] = cosx0[i]*cosx[i] - sinx0[i]*tmp;
+    }
+}
+
+static inline double _lomb_scargle(int numt, double cn[], double sinx[], double cosx[], double st, double ct, double cst) {
+  double cs=0.,s2=0.,c2=0.,sh=0.,ch=0.,px=0.,detm;
+  int i;
+  for (i=0;i<numt;i++) {
+    cs += cosx[i]*sinx[i];
+    c2 += cosx[i]*cosx[i];
+    sh += sinx[i]*cn[i];
+    ch += cosx[i]*cn[i];
+  }
+  cs -= cst; s2 = 1-c2-st; c2 -= ct;
+  detm = c2*s2 - cs*cs;
+  if (detm>0) px = ( c2*sh*sh - 2.*cs*ch*sh + s2*ch*ch ) / detm;
+  return px;
+}
+
+static inline void calc_dotprod(int numt, double sinx[], double cosx[], double wt[], int dord, double *st, double *ct) {
+    int i;
+    unsigned long n2=numt*dord;
+    for (*st=0,*ct=0,i=0;i<numt;i++) {
+        *st += sinx[i]*wt[i + n2];
+        *ct += cosx[i]*wt[i + n2];
+    }
+}
+
+static inline double do_lomb(int numt, int detrend_order, double cn[], double sinx[], double cosx[], double wth[]) {
+    int i;
+    double st,cst,ct,st0,ct0;
+    for (i=0,ct=0,st=0,cst=0;i<=detrend_order;i++) {
+        calc_dotprod(numt,sinx,cosx,wth,i,&st0,&ct0);
+        st += st0*st0; ct += ct0*ct0; cst += st0*ct0;
+    }
+    return _lomb_scargle(numt,cn,sinx,cosx,st,ct,cst);
+}
+
+static inline double do_lomb_zoom(int numt, int detrend_order, double *cn, double *sinx, double *cosx, double *sinx1, double *cosx1, double *sinx_back, double *cosx_back, double *sinx_smallstep, double *cosx_smallstep, double *wth, double freq_zoom, int *ifreq) {
+    int i;
+    double px,pxmax=0.;
+    copy_sincos(numt,sinx,cosx,sinx1,cosx1);
+    update_sincos(numt, sinx_back, cosx_back, sinx1, cosx1, 0);
+    for (i=0;i<freq_zoom;i++) {
+        px = do_lomb(numt,detrend_order,cn,sinx1,cosx1,wth);
+        if (px>pxmax) {
+            pxmax=px;
+            *ifreq = i;
+        }
+        update_sincos(numt, sinx_smallstep, cosx_smallstep, sinx1, cosx1, 0);
+    }
+    copy_sincos(numt,sinx,cosx,sinx1,cosx1);
+    if (*ifreq<freq_zoom/2.) {
+        update_sincos(numt, sinx_back, cosx_back, sinx1, cosx1, 0);
+        for (i=0;i<*ifreq;i++) update_sincos(numt, sinx_smallstep, cosx_smallstep, sinx1, cosx1, 0);
+    } else {
+        for (i=0;i<*ifreq-freq_zoom/2.;i++) update_sincos(numt, sinx_smallstep, cosx_smallstep, sinx1, cosx1, 0);
+    }
+    return px;
+}
+
+static inline void def_hat(int numt, int nharm, int detrend_order, double hat_matr[], double hat0[], double sinx[], double cosx[], double wt[], double cn[], double hat_hat[], double vec[], double lambda0) {
+    int i,j=numt*nharm,k,j1,npar=2*nharm,dord1=detrend_order+1;
+    double sx0[numt],cx0[numt],ct,st,sum;
+    for (i=0;i<numt;i++) {
+        sx0[i] = (hat_matr[i]=sinx[i])/wt[i]; cx0[i] = (hat_matr[i+j]=cosx[i])/wt[i];
+    }
+    for (j=0;j<nharm-1;j++) {
+        update_sincos (numt,sx0,cx0,hat_matr+j*numt,hat_matr+(j+nharm)*numt,numt);
+        for (i=0;i<=detrend_order;i++) calc_dotprod(numt,hat_matr+j*numt,hat_matr+(j+nharm)*numt,wt,i,&hat0[i+j*dord1],&hat0[i+(j+nharm)*dord1]);
+    }
+    for (i=0;i<=detrend_order;i++) calc_dotprod(numt,hat_matr+j*numt,hat_matr+(j+nharm)*numt,wt,i,&hat0[i+j*dord1],&hat0[i+(j+nharm)*dord1]);
+    for (j=0;j<npar;j++) {
+        for (k=j;k<npar;k++) {
+            for (sum=0,i=0;i<numt;i++) sum += hat_matr[i+j*numt]*hat_matr[i+k*numt];
+            for (i=0;i<=detrend_order;i++) sum -= hat0[i+j*dord1]*hat0[i+k*dord1];
+            hat_hat[k+j*npar] = sum;
+        }
+    }
+    for (j=0;j<npar;j++) {
+        ct = (1.+(j%nharm)); ct*=ct;
+        for (sum=0,i=0;i<numt;i++) sum += hat_matr[i+j*numt]*cn[i];
+        vec[j] = sum/ct;
+        for (k=j;k<npar;k++) {
+            st = (1.+(k%nharm)); st*=st;
+            hat_hat[k+j*npar] /= (ct*st);
+            hat_hat[j+k*npar] = hat_hat[k+j*npar];
+        }
+        hat_hat[j+j*npar] += numt*lambda0;
+    }
+}
+
+static inline double optimize_px(int n, int numt, double p[], double hat_hat[], double eigs[], double *lambda0, double *lambda0_range, double chi0, double tc, double *Trace) {
+    int i,j,k,niter=50;
+    double px,lambda,dlambda,lambda_best,eigs1,px_max=0.,start=lambda0_range[0],stop=lambda0_range[1];
+    double m[n][n],s1,s2,s3,sum,v[n],tcn=tc/numt,Tr,Tr0=(1-3./numt)/(1.+tcn);
+
+    for (i=0;i<n;i++) {
+      for (j=i;j<n;j++) m[j][i] = 0.;
+    }
+    for (k=0;k<n;k++) {
+        s1 = 1.+(k%(n/2)); s1*=s1; s1*=s1;
+        for (i=0;i<n;i++) {
+            for (j=i;j<n;j++) m[j][i] += hat_hat[i+k*n]*hat_hat[j+k*n]/s1;
+        }
+    }
+    lambda = start; dlambda = exp(log(stop/start)/niter);
+    for (k=0;k<3;k++) {
+        for (j=0;j<=niter;j++) {
+          Tr = 1-2.*n/numt; px=chi0; s1=0; s2=0, s3=0;
+          for (i=0;i<n;i++) {
+              eigs1 = eigs[i] + numt*(lambda-(*lambda0));
+              Tr += 2.*lambda/eigs1;
+              s1 += p[i]*(v[i]=p[i]/eigs1);
+              s2 += p[i]*v[i]/eigs1;
+              s3 += v[i]* m[i][i]* v[i];
+              for (k=0;k<i;k++) s3 += 2.*v[i] *m[i][k] *v[k];
+           }
+           px = chi0  - (chi0-s1-s2*numt*lambda)*(1.+tcn*(s2/s3))*Tr0/Tr;
+           if (px>px_max && Tr>0) {
+               px_max = px;
+               lambda_best = lambda;
+               *Trace = Tr;
+           }
+           lambda *= dlambda;
+        }
+        if (lambda_best-1.e-5>start) start=lambda_best/dlambda;
+        else break;
+        if(lambda_best+1.e-5<stop) stop = lambda_best*dlambda;
+        else break;
+        dlambda = exp(log(stop/start)/niter);
+    }
+   *lambda0 = lambda_best;
+    return px_max;
+}
+
+static inline void inv_hat(int n, double hat_hat[], double vec[], double vec1[], double eigs[], double lam0, double lam) {
+    int i,j,k;
+    double tmp[n][n], sum;
+    for (i=0;i<n;i++) {
+        for (j=i;j<n;j++) {
+            for (sum=0,k=0;k<n;k++) sum += hat_hat[k+i*n]*hat_hat[k+j*n]/(eigs[k]+lam-lam0);
+            tmp[i][j] = sum;
+        }
+    }
+    for (i=0;i<n;i++) {
+        for (j=i;j<n;j++) hat_hat[j+i*n] = hat_hat[i+j*n] = tmp[i][j];
+        for (sum=0,j=0;j<n;j++) sum += hat_hat[j+i*n]*vec[j];
+        vec1[i] = sum;
+    }
+}
+
+static inline double refine_psd(int numt, int nharm, int detrend_order, double hat_matr[], double hat0[], double hat_hat[], double sinx[], double cosx[], double wt[], double cn[], double vec1[], double *lambda0, double *lambda0_range, double chi0, double tc, double *Tr, int inv) {
+    int i,j,k,npar=2*nharm;
+    double p[npar],vec[npar],eigs[npar],sum,px,lambda00=*lambda0;
+    def_hat(numt,nharm,detrend_order,hat_matr,hat0,sinx,cosx,wt,cn,hat_hat,vec,*lambda0);
+    get_eigs(npar,hat_hat,eigs);
+    for (i=0;i<npar;i++) {
+        for (sum=0,j=0;j<npar;j++) sum += hat_hat[i+j*npar] * vec[j];
+        p[i] = sum;
+    }
+    px = optimize_px(npar,numt,p,hat_hat,eigs,lambda0,lambda0_range,chi0,tc,Tr);
+    if (inv==1) inv_hat(npar,hat_hat,vec,vec1,eigs,numt*lambda00,numt*(*lambda0));
+    return px;
+}
+
+void lomb_scargle(int numt, int numf, int nharm, int detrend_order,
+                  double psd[], double cn[], double wth[], double sinx[],
+                  double cosx[], double sinx_step[], double cosx_step[],
+                  double sinx_back[], double cosx_back[],
+                  double sinx_smallstep[], double cosx_smallstep[],
+                  double hat_matr[], double hat_hat[],
+                  double hat0[], double soln[], double chi0,
+                  double freq_zoom, double psdmin, double tone_control,
+                  double lambda0[], double lambda0_range[],
+                  double Tr[], int ifreq[])
+{
+  int i,k,npar=2*(int)nharm,ifr=(int)(freq_zoom)/2;
+  unsigned long j;
+  unsigned long jmax=0;
+  *ifreq = ifr;
+  double psdmax=0.,psd0max=0.,Trace,sinx1[numt],cosx1[numt],sinx2[numt],cosx2[numt],lambda,px,pxmax;
+  for (j=0;j<numf;j++) {
+      // do a simple lomb-scargle, sin+cos fit
+      psd[j] = do_lomb(numt,detrend_order,cn,sinx,cosx,wth);
+      if (psd[j]>psd0max && psdmax==0) {
+          psd0max = psd[j];
+          copy_sincos(numt,sinx,cosx,sinx2,cosx2);
+          jmax = j;
+      }
+      // refine the fit around significant sin+cos fits
+      if (psd[j]>(double)psdmin) {
+          // first let the frequency vary slightly
+          px = do_lomb_zoom(numt,detrend_order, cn, sinx, cosx, sinx1, cosx1, sinx_back, cosx_back, sinx_smallstep, cosx_smallstep, wth, freq_zoom, &ifr);
+          lambda = *lambda0;
+          // now fit a multi-harmonic model with generalized cross-validation to avoid over-fitting
+          psd[j] = refine_psd(numt,nharm,detrend_order,hat_matr,hat0,hat_hat,sinx1,cosx1,wth,cn,soln,&lambda,lambda0_range,chi0,tone_control,&Trace,0);
+          if (psd[j]>psdmax) {
+              copy_sincos(numt,sinx1,cosx1,sinx2,cosx2);
+              psdmax=psd[j];
+              *ifreq = ifr;
+              jmax = j;
+          }
+      }
+      update_sincos(numt, sinx_step, cosx_step, sinx, cosx, 0);
+  }
+  // finally, rerun at the best-fit period so we get some statistics
+  psd[jmax] = refine_psd(numt,nharm,detrend_order,hat_matr,hat0,hat_hat,sinx2,cosx2,wth,cn,soln,lambda0,lambda0_range,chi0,tone_control,Tr,1);
+}
```

### Comparing `cesium-0.9.7/cesium/features/periodic_model.py` & `cesium-0.9.9/cesium/features/periodic_model.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-import numpy as np
-from scipy import optimize
-
-
-# TODO what is this exactly?
-def periodic_model(lomb_model):
-    """
-    Compute features related to the extreme points of the fitted Lomb Scargle
-    model.
-    """
-    out_dict = {}
-
-    A = lomb_model['freq_fits'][0]['amplitude']
-    ph = lomb_model['freq_fits'][0]['rel_phase']
-
-    def model_f(t):
-        return (A[0] * np.sin(2. * np.pi      * t + ph[0]) +
-                A[1] * np.sin(2. * np.pi * 2. * t + ph[1]) +
-                A[2] * np.sin(2. * np.pi * 3. * t + ph[2]) +
-                A[3] * np.sin(2. * np.pi * 4. * t + ph[3]) +
-                A[4] * np.sin(2. * np.pi * 5. * t + ph[4]) +
-                A[5] * np.sin(2. * np.pi * 6. * t + ph[5]) +
-                A[6] * np.sin(2. * np.pi * 7. * t + ph[6]) +
-                A[7] * np.sin(2. * np.pi * 8. * t + ph[7]))
-
-    def model_neg(t):
-        return -1. * model_f(t)
-
-    # Start finding 1st minima, at 5% of phase (fudge/magic number) > 0.018
-    min_1_a = optimize.fmin(model_neg, 0.05, disp=False)[0]
-    max_2_a = optimize.fmin(model_f, min_1_a + 0.01, disp=False)[0]
-    min_3_a = optimize.fmin(model_neg, max_2_a + 0.01, disp=False)[0]
-    max_4_a = optimize.fmin(model_f, min_3_a + 0.01, disp=False)[0]
-
-# TODO !!! is this wrong? seems like it should be a minus
-    out_dict['phi1_phi2'] = (min_3_a - max_2_a) / (max_4_a / min_3_a)
-    out_dict['min_delta_mags'] = abs(model_f(min_1_a) - model_f(min_3_a))
-    out_dict['max_delta_mags'] = abs(model_f(max_2_a) - model_f(max_4_a))
-    return out_dict
-
-
-def get_max_delta_mags(model):
-    """Largest value minus second largest value of fitted Lomb Scargle model."""
-    return model['max_delta_mags']
-
-
-def get_min_delta_mags(model):
-    """Second smallest value minus smallest value of fitted Lomb Scargle model."""
-    return model['min_delta_mags']
-
-
-def get_model_phi1_phi2(model):
-    """
-    Ratio of distances between the second minimum and first maximum, and the
-    second minimum and second maximum, of the fitted Lomb-Scargle model.
-    """
-    return model['phi1_phi2']
+import numpy as np
+from scipy import optimize
+
+
+# TODO what is this exactly?
+def periodic_model(lomb_model):
+    """
+    Compute features related to the extreme points of the fitted Lomb Scargle
+    model.
+    """
+    out_dict = {}
+
+    A = lomb_model['freq_fits'][0]['amplitude']
+    ph = lomb_model['freq_fits'][0]['rel_phase']
+
+    def model_f(t):
+        return (A[0] * np.sin(2. * np.pi      * t + ph[0]) +
+                A[1] * np.sin(2. * np.pi * 2. * t + ph[1]) +
+                A[2] * np.sin(2. * np.pi * 3. * t + ph[2]) +
+                A[3] * np.sin(2. * np.pi * 4. * t + ph[3]) +
+                A[4] * np.sin(2. * np.pi * 5. * t + ph[4]) +
+                A[5] * np.sin(2. * np.pi * 6. * t + ph[5]) +
+                A[6] * np.sin(2. * np.pi * 7. * t + ph[6]) +
+                A[7] * np.sin(2. * np.pi * 8. * t + ph[7]))
+
+    def model_neg(t):
+        return -1. * model_f(t)
+
+    # Start finding 1st minima, at 5% of phase (fudge/magic number) > 0.018
+    min_1_a = optimize.fmin(model_neg, 0.05, disp=False)[0]
+    max_2_a = optimize.fmin(model_f, min_1_a + 0.01, disp=False)[0]
+    min_3_a = optimize.fmin(model_neg, max_2_a + 0.01, disp=False)[0]
+    max_4_a = optimize.fmin(model_f, min_3_a + 0.01, disp=False)[0]
+
+# TODO !!! is this wrong? seems like it should be a minus
+    out_dict['phi1_phi2'] = (min_3_a - max_2_a) / (max_4_a / min_3_a)
+    out_dict['min_delta_mags'] = abs(model_f(min_1_a) - model_f(min_3_a))
+    out_dict['max_delta_mags'] = abs(model_f(max_2_a) - model_f(max_4_a))
+    return out_dict
+
+
+def get_max_delta_mags(model):
+    """Largest value minus second largest value of fitted Lomb Scargle model."""
+    return model['max_delta_mags']
+
+
+def get_min_delta_mags(model):
+    """Second smallest value minus smallest value of fitted Lomb Scargle model."""
+    return model['min_delta_mags']
+
+
+def get_model_phi1_phi2(model):
+    """
+    Ratio of distances between the second minimum and first maximum, and the
+    second minimum and second maximum, of the fitted Lomb-Scargle model.
+    """
+    return model['phi1_phi2']
```

### Comparing `cesium-0.9.7/cesium/features/_lomb_scargle.c` & `cesium-0.9.9/cesium/features/_lomb_scargle.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,36 +1,37 @@
-/* Generated by Cython 0.27.3 */
+/* Generated by Cython 0.29.1 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
-            "cesium/features/_lomb_scargle.h"
-        ],
+            "cesium\\features\\_lomb_scargle.h"
+        ], 
         "include_dirs": [
-            "cesium/features",
-            "./cesium/features"
-        ],
-        "name": "cesium.features._lomb_scargle",
+            "cesium\\features", 
+            ".\\cesium\\features"
+        ], 
+        "name": "cesium.features._lomb_scargle", 
         "sources": [
-            "/home/arien/projects/cesium/cesium/features/_lomb_scargle.pyx"
+            "C:\\Users\\guitr\\Documents\\cesium\\cesium\\features\\_lomb_scargle.pyx"
         ]
-    },
+    }, 
     "module_name": "cesium.features._lomb_scargle"
 }
 END: Cython Metadata */
 
 #define PY_SSIZE_T_CLEAN
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_27_3"
+#define CYTHON_ABI "0_29_1"
+#define CYTHON_HEX_VERSION 0x001D01F0
 #define CYTHON_FUTURE_DIVISION 0
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -93,14 +94,18 @@
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
   #undef CYTHON_PEP489_MULTI_PHASE_INIT
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
+  #undef CYTHON_USE_DICT_VERSIONS
+  #define CYTHON_USE_DICT_VERSIONS 0
+  #undef CYTHON_USE_EXC_INFO_STACK
+  #define CYTHON_USE_EXC_INFO_STACK 0
 #elif defined(PYSTON_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_PYSTON 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
@@ -130,14 +135,18 @@
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
   #undef CYTHON_PEP489_MULTI_PHASE_INIT
   #define CYTHON_PEP489_MULTI_PHASE_INIT 0
   #undef CYTHON_USE_TP_FINALIZE
   #define CYTHON_USE_TP_FINALIZE 0
+  #undef CYTHON_USE_DICT_VERSIONS
+  #define CYTHON_USE_DICT_VERSIONS 0
+  #undef CYTHON_USE_EXC_INFO_STACK
+  #define CYTHON_USE_EXC_INFO_STACK 0
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_PYSTON 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
@@ -183,29 +192,135 @@
   #ifndef CYTHON_FAST_THREAD_STATE
     #define CYTHON_FAST_THREAD_STATE 1
   #endif
   #ifndef CYTHON_FAST_PYCALL
     #define CYTHON_FAST_PYCALL 1
   #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
-    #define CYTHON_PEP489_MULTI_PHASE_INIT (0 && PY_VERSION_HEX >= 0x03050000)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
+  #ifndef CYTHON_USE_DICT_VERSIONS
+    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+  #endif
+  #ifndef CYTHON_USE_EXC_INFO_STACK
+    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if CYTHON_USE_PYLONG_INTERNALS
   #include "longintrepr.h"
   #undef SHIFT
   #undef BASE
   #undef MASK
+  #ifdef SIZEOF_VOID_P
+    enum { __pyx_check_sizeof_voidp = 1/(SIZEOF_VOID_P == sizeof(void*)) };
+  #endif
+#endif
+#ifndef __has_attribute
+  #define __has_attribute(x) 0
+#endif
+#ifndef __has_cpp_attribute
+  #define __has_cpp_attribute(x) 0
+#endif
+#ifndef CYTHON_RESTRICT
+  #if defined(__GNUC__)
+    #define CYTHON_RESTRICT __restrict__
+  #elif defined(_MSC_VER) && _MSC_VER >= 1400
+    #define CYTHON_RESTRICT __restrict
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_RESTRICT restrict
+  #else
+    #define CYTHON_RESTRICT
+  #endif
+#endif
+#ifndef CYTHON_UNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
+#     define CYTHON_UNUSED __attribute__ ((__unused__))
+#   else
+#     define CYTHON_UNUSED
+#   endif
+# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
+#   define CYTHON_UNUSED __attribute__ ((__unused__))
+# else
+#   define CYTHON_UNUSED
+# endif
+#endif
+#ifndef CYTHON_MAYBE_UNUSED_VAR
+#  if defined(__cplusplus)
+     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
+#  else
+#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
+#  endif
+#endif
+#ifndef CYTHON_NCP_UNUSED
+# if CYTHON_COMPILING_IN_CPYTHON
+#  define CYTHON_NCP_UNUSED
+# else
+#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
+# endif
+#endif
+#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
+#ifdef _MSC_VER
+    #ifndef _MSC_STDINT_H_
+        #if _MSC_VER < 1300
+           typedef unsigned char     uint8_t;
+           typedef unsigned int      uint32_t;
+        #else
+           typedef unsigned __int8   uint8_t;
+           typedef unsigned __int32  uint32_t;
+        #endif
+    #endif
+#else
+   #include <stdint.h>
+#endif
+#ifndef CYTHON_FALLTHROUGH
+  #if defined(__cplusplus) && __cplusplus >= 201103L
+    #if __has_cpp_attribute(fallthrough)
+      #define CYTHON_FALLTHROUGH [[fallthrough]]
+    #elif __has_cpp_attribute(clang::fallthrough)
+      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
+    #elif __has_cpp_attribute(gnu::fallthrough)
+      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
+    #endif
+  #endif
+  #ifndef CYTHON_FALLTHROUGH
+    #if __has_attribute(fallthrough)
+      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
+    #else
+      #define CYTHON_FALLTHROUGH
+    #endif
+  #endif
+  #if defined(__clang__ ) && defined(__apple_build_version__)
+    #if __apple_build_version__ < 7000000
+      #undef  CYTHON_FALLTHROUGH
+      #define CYTHON_FALLTHROUGH
+    #endif
+  #endif
+#endif
+
+#ifndef CYTHON_INLINE
+  #if defined(__clang__)
+    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
+  #elif defined(__GNUC__)
+    #define CYTHON_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define CYTHON_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define CYTHON_INLINE inline
+  #else
+    #define CYTHON_INLINE
+  #endif
 #endif
+
 #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
   #define Py_OptimizeFlag 0
 #endif
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
@@ -226,52 +341,127 @@
 #endif
 #ifndef Py_TPFLAGS_HAVE_NEWBUFFER
   #define Py_TPFLAGS_HAVE_NEWBUFFER 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_FINALIZE
   #define Py_TPFLAGS_HAVE_FINALIZE 0
 #endif
-#if PY_VERSION_HEX < 0x030700A0 || !defined(METH_FASTCALL)
+#ifndef METH_STACKLESS
+  #define METH_STACKLESS 0
+#endif
+#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
-  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject **args, Py_ssize_t nargs);
-  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject **args,
+  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
+  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
   #define __Pyx_PyCFunctionFast _PyCFunctionFast
   #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
 #endif
 #if CYTHON_FAST_PYCCALL
 #define __Pyx_PyFastCFunction_Check(func)\
-    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS)))))
+    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
 #else
 #define __Pyx_PyFastCFunction_Check(func) 0
 #endif
+#if CYTHON_USE_DICT_VERSIONS
+#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
+#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
+    (version_var) = __PYX_GET_DICT_VERSION(dict);\
+    (cache_var) = (value);
+#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
+        static PY_UINT64_T __pyx_dict_version = 0;\
+        static PyObject *__pyx_dict_cached_value = NULL;\
+        if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
+            (VAR) = __pyx_dict_cached_value;\
+        } else {\
+            (VAR) = __pyx_dict_cached_value = (LOOKUP);\
+            __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
+        }\
+    }
+#else
+#define __PYX_GET_DICT_VERSION(dict)  (0)
+#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
+#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
+#endif
+#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
+  #define PyObject_Malloc(s)   PyMem_Malloc(s)
+  #define PyObject_Free(p)     PyMem_Free(p)
+  #define PyObject_Realloc(p)  PyMem_Realloc(p)
+#endif
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
+  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
+  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
+  #define PyMem_RawFree(p)             PyMem_Free(p)
+#endif
+#if CYTHON_COMPILING_IN_PYSTON
+  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
+  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
+#else
+  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
+  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
+#endif
 #if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
 #elif PY_VERSION_HEX >= 0x03060000
   #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
 #elif PY_VERSION_HEX >= 0x03000000
   #define __Pyx_PyThreadState_Current PyThreadState_GET()
 #else
   #define __Pyx_PyThreadState_Current _PyThreadState_Current
 #endif
+#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
+#include "pythread.h"
+#define Py_tss_NEEDS_INIT 0
+typedef int Py_tss_t;
+static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
+  *key = PyThread_create_key();
+  return 0; // PyThread_create_key reports success always
+}
+static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
+  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
+  *key = Py_tss_NEEDS_INIT;
+  return key;
+}
+static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
+  PyObject_Free(key);
+}
+static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
+  return *key != Py_tss_NEEDS_INIT;
+}
+static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
+  PyThread_delete_key(*key);
+  *key = Py_tss_NEEDS_INIT;
+}
+static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
+  return PyThread_set_key_value(*key, value);
+}
+static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
+  return PyThread_get_key_value(*key);
+}
+#endif // TSS (Thread Specific Storage) API
 #if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
 #define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
 #else
 #define __Pyx_PyDict_NewPresized(n)  PyDict_New()
 #endif
 #if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
 #else
   #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
   #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
 #endif
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
+#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
+#else
+#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
+#endif
 #if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
   #define CYTHON_PEP393_ENABLED 1
   #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                               0 : _PyUnicode_Ready((PyObject *)(op)))
   #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
   #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
   #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
@@ -308,54 +498,47 @@
 #endif
 #if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
   #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
 #endif
 #if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
   #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
 #endif
-#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
-  #define PyObject_Malloc(s)   PyMem_Malloc(s)
-  #define PyObject_Free(p)     PyMem_Free(p)
-  #define PyObject_Realloc(p)  PyMem_Realloc(p)
-#endif
-#if CYTHON_COMPILING_IN_PYSTON
-  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
-  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
-#else
-  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
-  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
-#endif
-#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
-#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
+#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
+#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
 #else
   #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
 #endif
 #if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
   #define PyObject_ASCII(o)            PyObject_Repr(o)
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define PyBaseString_Type            PyUnicode_Type
   #define PyStringObject               PyUnicodeObject
   #define PyString_Type                PyUnicode_Type
   #define PyString_Check               PyUnicode_Check
   #define PyString_CheckExact          PyUnicode_CheckExact
+  #define PyObject_Unicode             PyObject_Str
 #endif
 #if PY_MAJOR_VERSION >= 3
   #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
   #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
 #else
   #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
   #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
 #endif
 #ifndef PySet_CheckExact
   #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
 #endif
-#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
+#if CYTHON_ASSUME_SAFE_MACROS
+  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
+#else
+  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
+#endif
 #if PY_MAJOR_VERSION >= 3
   #define PyIntObject                  PyLongObject
   #define PyInt_Type                   PyLong_Type
   #define PyInt_Check(op)              PyLong_Check(op)
   #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
   #define PyInt_FromString             PyLong_FromString
   #define PyInt_FromUnicode            PyLong_FromUnicode
@@ -382,24 +565,18 @@
   #define __Pyx_PyInt_FromHash_t PyInt_FromLong
   #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
 #else
   #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
   #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
 #endif
 #if PY_MAJOR_VERSION >= 3
-  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
+  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : (Py_INCREF(func), func))
 #else
   #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
 #endif
-#ifndef __has_attribute
-  #define __has_attribute(x) 0
-#endif
-#ifndef __has_cpp_attribute
-  #define __has_cpp_attribute(x) 0
-#endif
 #if CYTHON_USE_ASYNC_SLOTS
   #if PY_VERSION_HEX >= 0x030500B1
     #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
     #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
   #else
     #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
   #endif
@@ -409,104 +586,14 @@
 #ifndef __Pyx_PyAsyncMethodsStruct
     typedef struct {
         unaryfunc am_await;
         unaryfunc am_aiter;
         unaryfunc am_anext;
     } __Pyx_PyAsyncMethodsStruct;
 #endif
-#ifndef CYTHON_RESTRICT
-  #if defined(__GNUC__)
-    #define CYTHON_RESTRICT __restrict__
-  #elif defined(_MSC_VER) && _MSC_VER >= 1400
-    #define CYTHON_RESTRICT __restrict
-  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define CYTHON_RESTRICT restrict
-  #else
-    #define CYTHON_RESTRICT
-  #endif
-#endif
-#ifndef CYTHON_UNUSED
-# if defined(__GNUC__)
-#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
-#     define CYTHON_UNUSED __attribute__ ((__unused__))
-#   else
-#     define CYTHON_UNUSED
-#   endif
-# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
-#   define CYTHON_UNUSED __attribute__ ((__unused__))
-# else
-#   define CYTHON_UNUSED
-# endif
-#endif
-#ifndef CYTHON_MAYBE_UNUSED_VAR
-#  if defined(__cplusplus)
-     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
-#  else
-#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
-#  endif
-#endif
-#ifndef CYTHON_NCP_UNUSED
-# if CYTHON_COMPILING_IN_CPYTHON
-#  define CYTHON_NCP_UNUSED
-# else
-#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
-# endif
-#endif
-#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
-#ifdef _MSC_VER
-    #ifndef _MSC_STDINT_H_
-        #if _MSC_VER < 1300
-           typedef unsigned char     uint8_t;
-           typedef unsigned int      uint32_t;
-        #else
-           typedef unsigned __int8   uint8_t;
-           typedef unsigned __int32  uint32_t;
-        #endif
-    #endif
-#else
-   #include <stdint.h>
-#endif
-#ifndef CYTHON_FALLTHROUGH
-  #if defined(__cplusplus) && __cplusplus >= 201103L
-    #if __has_cpp_attribute(fallthrough)
-      #define CYTHON_FALLTHROUGH [[fallthrough]]
-    #elif __has_cpp_attribute(clang::fallthrough)
-      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
-    #elif __has_cpp_attribute(gnu::fallthrough)
-      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
-    #endif
-  #endif
-  #ifndef CYTHON_FALLTHROUGH
-    #if __has_attribute(fallthrough)
-      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
-    #else
-      #define CYTHON_FALLTHROUGH
-    #endif
-  #endif
-  #if defined(__clang__ ) && defined(__apple_build_version__)
-    #if __apple_build_version__ < 7000000
-      #undef  CYTHON_FALLTHROUGH
-      #define CYTHON_FALLTHROUGH
-    #endif
-  #endif
-#endif
-
-#ifndef CYTHON_INLINE
-  #if defined(__clang__)
-    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
-  #elif defined(__GNUC__)
-    #define CYTHON_INLINE __inline__
-  #elif defined(_MSC_VER)
-    #define CYTHON_INLINE __inline
-  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-    #define CYTHON_INLINE inline
-  #else
-    #define CYTHON_INLINE
-  #endif
-#endif
 
 #if defined(WIN32) || defined(MS_WINDOWS)
   #define _USE_MATH_DEFINES
 #endif
 #include <math.h>
 #ifdef NAN
 #define __PYX_NAN() ((float) NAN)
@@ -535,14 +622,15 @@
   #else
     #define __PYX_EXTERN_C extern
   #endif
 #endif
 
 #define __PYX_HAVE__cesium__features___lomb_scargle
 #define __PYX_HAVE_API__cesium__features___lomb_scargle
+/* Early includes */
 #include "_lomb_scargle.h"
 #include <string.h>
 #include <stdio.h>
 #include "numpy/arrayobject.h"
 #include "numpy/ufuncobject.h"
 #include "pythread.h"
 #include <stdlib.h>
@@ -571,14 +659,17 @@
           likely(v < (type)PY_SSIZE_T_MAX ||\
                  v == (type)PY_SSIZE_T_MAX)  &&\
           (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                 v == (type)PY_SSIZE_T_MIN)))  ||\
     (sizeof(type) == sizeof(Py_ssize_t) &&\
           (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                                v == (type)PY_SSIZE_T_MAX)))  )
+static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
+    return (size_t) i < (size_t) limit;
+}
 #if defined (__cplusplus) && __cplusplus >= 201103L
     #include <cstdlib>
     #define __Pyx_sst_abs(value) std::abs(value)
 #elif SIZEOF_INT >= SIZEOF_SIZE_T
     #define __Pyx_sst_abs(value) abs(value)
 #elif SIZEOF_LONG >= SIZEOF_SIZE_T
     #define __Pyx_sst_abs(value) labs(value)
@@ -627,16 +718,17 @@
     return (size_t)(u_end - u - 1);
 }
 #define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
 #define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
-#define __Pyx_PyBool_FromLong(b) ((b) ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False))
+static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
 #define __Pyx_PySequence_Tuple(obj)\
     (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
 static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
 #if CYTHON_ASSUME_SAFE_MACROS
 #define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
@@ -709,15 +801,15 @@
     sys = PyImport_ImportModule("sys");
     if (!sys) goto bad;
     default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
     Py_DECREF(sys);
     if (!default_encoding) goto bad;
     default_encoding_c = PyBytes_AsString(default_encoding);
     if (!default_encoding_c) goto bad;
-    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
+    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
     if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
     strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
     Py_DECREF(default_encoding);
     return 0;
 bad:
     Py_XDECREF(default_encoding);
     return -1;
@@ -735,15 +827,15 @@
   #define unlikely(x) (x)
 #endif /* __GNUC__ */
 static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }
 
 static PyObject *__pyx_m = NULL;
 static PyObject *__pyx_d;
 static PyObject *__pyx_b;
-static PyObject *__pyx_cython_runtime;
+static PyObject *__pyx_cython_runtime = NULL;
 static PyObject *__pyx_empty_tuple;
 static PyObject *__pyx_empty_bytes;
 static PyObject *__pyx_empty_unicode;
 static int __pyx_lineno;
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm= __FILE__;
 static const char *__pyx_filename;
@@ -768,18 +860,18 @@
 #if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
   #undef _Complex_I
   #define _Complex_I 1.0fj
 #endif
 
 
 static const char *__pyx_f[] = {
-  "cesium/features/_lomb_scargle.pyx",
-  ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd",
+  "cesium\\features\\_lomb_scargle.pyx",
+  "__init__.pxd",
   "stringsource",
-  ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/cpython/type.pxd",
+  "type.pxd",
 };
 /* BufferFormatStructs.proto */
 #define IS_UNSIGNED(type) (((type) -1) > 0)
 struct __Pyx_StructField_;
 #define __PYX_BUF_FLAGS_PACKED_STRUCT (1 << 0)
 typedef struct {
   const char* name;
@@ -882,195 +974,195 @@
 #define __Pyx_PyGILState_Ensure PyGILState_Ensure
 #define __Pyx_PyGILState_Release PyGILState_Release
 #define __Pyx_FastGIL_Remember()
 #define __Pyx_FastGIL_Forget()
 #define __Pyx_FastGilFuncInit()
 
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":743
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":776
  * # in Cython to enable them only on the right systems.
  * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":744
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":777
  * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":745
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":778
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":746
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":779
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":750
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":783
  * #ctypedef npy_int128     int128_t
  * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":751
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":784
  * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":752
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":785
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":753
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":786
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":757
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":790
  * #ctypedef npy_uint128    uint128_t
  * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":758
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":791
  * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":767
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":800
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":768
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":801
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   longlong_t
  * 
  */
 typedef npy_longlong __pyx_t_5numpy_long_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":769
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":802
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":771
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":804
  * ctypedef npy_longlong   longlong_t
  * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":772
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":805
  * 
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":773
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":806
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":775
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":808
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
  * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":776
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":809
  * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":778
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":811
  * ctypedef npy_uintp      uintp_t
  * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":779
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":812
  * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
  * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":780
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":813
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
@@ -1101,51 +1193,51 @@
 
 /*--- Type declarations ---*/
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":782
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":815
  * ctypedef npy_longdouble longdouble_t
  * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":783
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":816
  * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
  * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":784
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":817
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":786
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":819
  * ctypedef npy_clongdouble clongdouble_t
  * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
 
-/* "View.MemoryView":103
+/* "View.MemoryView":105
  * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 struct __pyx_array_obj {
@@ -1162,28 +1254,28 @@
   PyObject *_format;
   void (*callback_free_data)(void *);
   int free_data;
   int dtype_is_object;
 };
 
 
-/* "View.MemoryView":277
+/* "View.MemoryView":279
  * 
  * @cname('__pyx_MemviewEnum')
  * cdef class Enum(object):             # <<<<<<<<<<<<<<
  *     cdef object name
  *     def __init__(self, name):
  */
 struct __pyx_MemviewEnum_obj {
   PyObject_HEAD
   PyObject *name;
 };
 
 
-/* "View.MemoryView":328
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
  * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 struct __pyx_memoryview_obj {
@@ -1198,15 +1290,15 @@
   Py_buffer view;
   int flags;
   int dtype_is_object;
   __Pyx_TypeInfo *typeinfo;
 };
 
 
-/* "View.MemoryView":953
+/* "View.MemoryView":961
  * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 struct __pyx_memoryviewslice_obj {
@@ -1215,29 +1307,29 @@
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
-/* "View.MemoryView":103
+/* "View.MemoryView":105
  * 
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
 
 struct __pyx_vtabstruct_array {
   PyObject *(*get_memview)(struct __pyx_array_obj *);
 };
 static struct __pyx_vtabstruct_array *__pyx_vtabptr_array;
 
 
-/* "View.MemoryView":328
+/* "View.MemoryView":330
  * 
  * @cname('__pyx_memoryview')
  * cdef class memoryview(object):             # <<<<<<<<<<<<<<
  * 
  *     cdef object obj
  */
 
@@ -1249,15 +1341,15 @@
   PyObject *(*setitem_indexed)(struct __pyx_memoryview_obj *, PyObject *, PyObject *);
   PyObject *(*convert_item_to_object)(struct __pyx_memoryview_obj *, char *);
   PyObject *(*assign_item_from_object)(struct __pyx_memoryview_obj *, char *, PyObject *);
 };
 static struct __pyx_vtabstruct_memoryview *__pyx_vtabptr_memoryview;
 
 
-/* "View.MemoryView":953
+/* "View.MemoryView":961
  * 
  * @cname('__pyx_memoryviewslice')
  * cdef class _memoryviewslice(memoryview):             # <<<<<<<<<<<<<<
  *     "Internal class for passing memoryview slices to Python"
  * 
  */
 
@@ -1367,33 +1459,42 @@
 static void __Pyx_ZeroBuffer(Py_buffer* buf);
 static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
 static Py_ssize_t __Pyx_minusones[] = { -1, -1, -1, -1, -1, -1, -1, -1 };
 static Py_ssize_t __Pyx_zeros[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
 /* PyObjectGetAttrStr.proto */
 #if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_getattro))
-        return tp->tp_getattro(obj, attr_name);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_getattr))
-        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
-#endif
-    return PyObject_GetAttr(obj, attr_name);
-}
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
 #endif
 
 /* GetBuiltinName.proto */
 static PyObject *__Pyx_GetBuiltinName(PyObject *name);
 
 /* GetModuleGlobalName.proto */
-static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);
+#if CYTHON_USE_DICT_VERSIONS
+#define __Pyx_GetModuleGlobalName(var, name)  {\
+    static PY_UINT64_T __pyx_dict_version = 0;\
+    static PyObject *__pyx_dict_cached_value = NULL;\
+    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
+        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
+        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
+}
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
+    PY_UINT64_T __pyx_dict_version;\
+    PyObject *__pyx_dict_cached_value;\
+    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
+}
+static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
+#else
+#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
+static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
+#endif
 
 /* BufferIndexError.proto */
 static void __Pyx_RaiseBufferIndexError(int axis);
 
 /* PyThreadStateGet.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
@@ -1462,47 +1563,80 @@
 #else
 #define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
 #endif
 
 /* RaiseException.proto */
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);
 
+/* PyCFunctionFastCall.proto */
+#if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
+#else
+#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
+#endif
+
+/* PyFunctionFastCall.proto */
+#if CYTHON_FAST_PYCALL
+#define __Pyx_PyFunction_FastCall(func, args, nargs)\
+    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
+#if 1 || PY_VERSION_HEX < 0x030600B1
+static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs);
+#else
+#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
+#endif
+#define __Pyx_BUILD_ASSERT_EXPR(cond)\
+    (sizeof(char [1 - 2*!(cond)]) - 1)
+#ifndef Py_MEMBER_SIZE
+#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
+#endif
+  static size_t __pyx_pyframe_localsplus_offset = 0;
+  #include "frameobject.h"
+  #define __Pxy_PyFrame_Initialize_Offsets()\
+    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
+     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
+  #define __Pyx_PyFrame_GetLocalsplus(frame)\
+    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
+#endif
+
+/* PyObjectCallMethO.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
+#endif
+
+/* PyObjectCallOneArg.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
+
 /* DictGetItem.proto */
 #if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
-static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
-    PyObject *value;
-    value = PyDict_GetItemWithError(d, key);
-    if (unlikely(!value)) {
-        if (!PyErr_Occurred()) {
-            PyObject* args = PyTuple_Pack(1, key);
-            if (likely(args))
-                PyErr_SetObject(PyExc_KeyError, args);
-            Py_XDECREF(args);
-        }
-        return NULL;
-    }
-    Py_INCREF(value);
-    return value;
-}
+static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key);
+#define __Pyx_PyObject_Dict_GetItem(obj, name)\
+    (likely(PyDict_CheckExact(obj)) ?\
+     __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
 #else
-    #define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
+#define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
+#define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
 #endif
 
 /* RaiseTooManyValuesToUnpack.proto */
 static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);
 
 /* RaiseNeedMoreValuesToUnpack.proto */
 static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
 
 /* RaiseNoneIterError.proto */
 static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
 
 /* ExtTypeTest.proto */
 static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
 
+/* GetTopmostException.proto */
+#if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
+#endif
+
 /* SaveResetException.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
 #else
@@ -1522,14 +1656,17 @@
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
 static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #else
 static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
 #endif
 
+/* PyObjectCall2Args.proto */
+static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
+
 /* IncludeStringH.proto */
 #include <string.h>
 
 /* BytesEquals.proto */
 static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);
 
 /* UnicodeEquals.proto */
@@ -1550,14 +1687,43 @@
         (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
 
 static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *); /*proto*/
 /* GetAttr.proto */
 static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);
 
+/* GetItemInt.proto */
+#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
+    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
+               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
+#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
+    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
+    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
+    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
+    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              int wraparound, int boundscheck);
+static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
+                                                     int is_list, int wraparound, int boundscheck);
+
+/* ObjectGetItem.proto */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
+#else
+#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
+#endif
+
 /* decode_c_string_utf16.proto */
 static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors) {
     int byteorder = 0;
     return PyUnicode_DecodeUTF16(s, size, errors, &byteorder);
 }
 static CYTHON_INLINE PyObject *__Pyx_PyUnicode_DecodeUTF16LE(const char *s, Py_ssize_t size, const char *errors) {
     int byteorder = -1;
@@ -1584,53 +1750,26 @@
 #else
 static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
 #endif
 
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
-/* PyFunctionFastCall.proto */
-#if CYTHON_FAST_PYCALL
-#define __Pyx_PyFunction_FastCall(func, args, nargs)\
-    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
-#if 1 || PY_VERSION_HEX < 0x030600B1
-static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs);
-#else
-#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
-#endif
-#endif
-
-/* PyCFunctionFastCall.proto */
-#if CYTHON_FAST_PYCCALL
-static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
+/* FastTypeChecks.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
+static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
+static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
+static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
 #else
-#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
+#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
+#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
+#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
 #endif
-
-/* GetItemInt.proto */
-#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
-    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
-               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
-#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
-    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck);
-#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
-    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
-    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
-    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              int wraparound, int boundscheck);
-static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
-                                                     int is_list, int wraparound, int boundscheck);
+#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
 
 static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 /* ListCompAppend.proto */
 #if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
 static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
     PyListObject* L = (PyListObject*) list;
     Py_ssize_t len = Py_SIZE(list);
@@ -1691,34 +1830,51 @@
 static CYTHON_INLINE long __Pyx_div_long(long, long);
 
 /* WriteUnraisableException.proto */
 static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                   int lineno, const char *filename,
                                   int full_traceback, int nogil);
 
-/* PyObjectCallMethO.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
-#endif
-
-/* PyObjectCallOneArg.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
-
 /* ImportFrom.proto */
 static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
 
 /* HasAttr.proto */
 static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 
+/* PyObject_GenericGetAttrNoDict.proto */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
+#else
+#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
+#endif
+
+/* PyObject_GenericGetAttr.proto */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
+#else
+#define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
+#endif
+
 /* SetVTable.proto */
 static int __Pyx_SetVtable(PyObject *dict, void *vtable);
 
 /* SetupReduce.proto */
 static int __Pyx_setup_reduce(PyObject* type_obj);
 
+/* TypeImport.proto */
+#ifndef __PYX_HAVE_RT_ImportType_proto
+#define __PYX_HAVE_RT_ImportType_proto
+enum __Pyx_ImportType_CheckSize {
+   __Pyx_ImportType_CheckSize_Error = 0,
+   __Pyx_ImportType_CheckSize_Warn = 1,
+   __Pyx_ImportType_CheckSize_Ignore = 2
+};
+static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
+#endif
+
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
 #endif
 
@@ -1786,18 +1942,18 @@
                 int ndim,
                 __Pyx_TypeInfo *dtype,
                 __Pyx_BufFmt_StackElem stack[],
                 __Pyx_memviewslice *memviewslice,
                 PyObject *original_obj);
 
 /* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_double(PyObject *);
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_double(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dsds_double(PyObject *);
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dsds_double(PyObject *, int writable_flag);
 
 /* RealImag.proto */
 #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     #define __Pyx_CREAL(z) ((z).real())
     #define __Pyx_CIMAG(z) ((z).imag())
   #else
@@ -1914,44 +2070,17 @@
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *);
 
-/* FastTypeChecks.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
-static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
-static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
-static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
-#else
-#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
-#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
-#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
-#endif
-
 /* CheckBinaryVersion.proto */
 static int __Pyx_check_binary_version(void);
 
-/* PyIdentifierFromString.proto */
-#if !defined(__Pyx_PyIdentifier_FromString)
-#if PY_MAJOR_VERSION < 3
-  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
-#else
-  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
-#endif
-#endif
-
-/* ModuleImport.proto */
-static PyObject *__Pyx_ImportModule(const char *name);
-
-/* TypeImport.proto */
-static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);
-
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *__pyx_v_self); /* proto*/
 static char *__pyx_memoryview_get_item_pointer(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index); /* proto*/
 static PyObject *__pyx_memoryview_is_slice(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_obj); /* proto*/
 static PyObject *__pyx_memoryview_setitem_slice_assignment(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_dst, PyObject *__pyx_v_src); /* proto*/
@@ -2158,14 +2287,16 @@
 static const char __pyx_k_ndarray_is_not_C_contiguous[] = "ndarray is not C contiguous";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
 static const char __pyx_k_numpy_core_multiarray_failed_to[] = "numpy.core.multiarray failed to import";
 static const char __pyx_k_unknown_dtype_code_in_numpy_pxd[] = "unknown dtype code in numpy.pxd (%d)";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
+static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
+static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
 static const char __pyx_k_Format_string_allocated_too_shor[] = "Format string allocated too short, see comment in numpy.pxd";
 static const char __pyx_k_Incompatible_checksums_s_vs_0xb0[] = "Incompatible checksums (%s vs 0xb068931 = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
 static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got %s";
 static const char __pyx_k_Non_native_byte_order_not_suppor[] = "Non-native byte order not supported";
 static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis %d)";
@@ -2175,14 +2306,16 @@
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static const char __pyx_k_numpy_core_umath_failed_to_impor[] = "numpy.core.umath failed to import";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
 static const char __pyx_k_Format_string_allocated_too_shor_2[] = "Format string allocated too short.";
 static PyObject *__pyx_n_s_ASCII;
 static PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
 static PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
+static PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
+static PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
 static PyObject *__pyx_kp_s_Cannot_index_with_type_s;
 static PyObject *__pyx_n_s_Ellipsis;
 static PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
 static PyObject *__pyx_kp_u_Format_string_allocated_too_shor;
 static PyObject *__pyx_kp_u_Format_string_allocated_too_shor_2;
 static PyObject *__pyx_n_s_ImportError;
 static PyObject *__pyx_kp_s_Incompatible_checksums_s_vs_0xb0;
@@ -2359,40 +2492,38 @@
 static PyObject *__pyx_tuple__3;
 static PyObject *__pyx_tuple__4;
 static PyObject *__pyx_tuple__5;
 static PyObject *__pyx_tuple__6;
 static PyObject *__pyx_tuple__7;
 static PyObject *__pyx_tuple__8;
 static PyObject *__pyx_tuple__9;
-static PyObject *__pyx_slice__23;
-static PyObject *__pyx_slice__24;
-static PyObject *__pyx_slice__25;
+static PyObject *__pyx_slice__22;
 static PyObject *__pyx_tuple__10;
 static PyObject *__pyx_tuple__11;
 static PyObject *__pyx_tuple__12;
 static PyObject *__pyx_tuple__13;
 static PyObject *__pyx_tuple__14;
 static PyObject *__pyx_tuple__15;
 static PyObject *__pyx_tuple__16;
 static PyObject *__pyx_tuple__17;
 static PyObject *__pyx_tuple__18;
 static PyObject *__pyx_tuple__19;
 static PyObject *__pyx_tuple__20;
 static PyObject *__pyx_tuple__21;
-static PyObject *__pyx_tuple__22;
+static PyObject *__pyx_tuple__23;
+static PyObject *__pyx_tuple__24;
+static PyObject *__pyx_tuple__25;
 static PyObject *__pyx_tuple__26;
 static PyObject *__pyx_tuple__27;
 static PyObject *__pyx_tuple__28;
 static PyObject *__pyx_tuple__29;
 static PyObject *__pyx_tuple__30;
 static PyObject *__pyx_tuple__31;
-static PyObject *__pyx_tuple__32;
-static PyObject *__pyx_tuple__33;
-static PyObject *__pyx_tuple__34;
-static PyObject *__pyx_codeobj__35;
+static PyObject *__pyx_codeobj__32;
+/* Late includes */
 
 /* "cesium/features/_lomb_scargle.pyx":6
  * import numpy as np
  * 
  * def lomb_scargle(int numt, int numf, int nharm, int detrend_order,             # <<<<<<<<<<<<<<
  *                  double[:] psd, double[:] cn, cnp.ndarray wth,
  *                  double[:] sinx, double[:] cosx, double[:] sinx_step,
@@ -2494,169 +2625,169 @@
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_numt)) != 0)) kw_args--;
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_numt)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_numf)) != 0)) kw_args--;
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_numf)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 1); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_nharm)) != 0)) kw_args--;
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nharm)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 2); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
-        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_detrend_order)) != 0)) kw_args--;
+        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_detrend_order)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 3); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
-        if (likely((values[4] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_psd)) != 0)) kw_args--;
+        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_psd)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 4); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  5:
-        if (likely((values[5] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cn)) != 0)) kw_args--;
+        if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cn)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 5); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  6:
-        if (likely((values[6] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_wth)) != 0)) kw_args--;
+        if (likely((values[6] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_wth)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 6); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  7:
-        if (likely((values[7] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sinx)) != 0)) kw_args--;
+        if (likely((values[7] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sinx)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 7); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  8:
-        if (likely((values[8] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cosx)) != 0)) kw_args--;
+        if (likely((values[8] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cosx)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 8); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  9:
-        if (likely((values[9] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sinx_step)) != 0)) kw_args--;
+        if (likely((values[9] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sinx_step)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 9); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 10:
-        if (likely((values[10] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cosx_step)) != 0)) kw_args--;
+        if (likely((values[10] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cosx_step)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 10); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 11:
-        if (likely((values[11] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sinx_back)) != 0)) kw_args--;
+        if (likely((values[11] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sinx_back)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 11); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 12:
-        if (likely((values[12] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cosx_back)) != 0)) kw_args--;
+        if (likely((values[12] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cosx_back)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 12); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 13:
-        if (likely((values[13] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_sinx_smallstep)) != 0)) kw_args--;
+        if (likely((values[13] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sinx_smallstep)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 13); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 14:
-        if (likely((values[14] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cosx_smallstep)) != 0)) kw_args--;
+        if (likely((values[14] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cosx_smallstep)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 14); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 15:
-        if (likely((values[15] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_hat_matr)) != 0)) kw_args--;
+        if (likely((values[15] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_hat_matr)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 15); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 16:
-        if (likely((values[16] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_hat_hat)) != 0)) kw_args--;
+        if (likely((values[16] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_hat_hat)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 16); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 17:
-        if (likely((values[17] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_hat0)) != 0)) kw_args--;
+        if (likely((values[17] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_hat0)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 17); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 18:
-        if (likely((values[18] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_soln)) != 0)) kw_args--;
+        if (likely((values[18] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_soln)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 18); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 19:
-        if (likely((values[19] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_chi0)) != 0)) kw_args--;
+        if (likely((values[19] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chi0)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 19); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 20:
-        if (likely((values[20] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_freq_zoom)) != 0)) kw_args--;
+        if (likely((values[20] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_freq_zoom)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 20); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 21:
-        if (likely((values[21] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_psdmin)) != 0)) kw_args--;
+        if (likely((values[21] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_psdmin)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 21); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 22:
-        if (likely((values[22] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_tone_control)) != 0)) kw_args--;
+        if (likely((values[22] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_tone_control)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 22); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 23:
-        if (likely((values[23] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lambda0)) != 0)) kw_args--;
+        if (likely((values[23] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lambda0)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 23); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 24:
-        if (likely((values[24] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lambda0_range)) != 0)) kw_args--;
+        if (likely((values[24] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lambda0_range)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 24); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 25:
-        if (likely((values[25] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_Tr)) != 0)) kw_args--;
+        if (likely((values[25] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_Tr)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 25); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case 26:
-        if (likely((values[26] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifreq)) != 0)) kw_args--;
+        if (likely((values[26] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ifreq)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, 26); __PYX_ERR(0, 6, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lomb_scargle") < 0)) __PYX_ERR(0, 6, __pyx_L3_error)
       }
@@ -2691,35 +2822,35 @@
       values[25] = PyTuple_GET_ITEM(__pyx_args, 25);
       values[26] = PyTuple_GET_ITEM(__pyx_args, 26);
     }
     __pyx_v_numt = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_numt == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
     __pyx_v_numf = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_numf == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
     __pyx_v_nharm = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_nharm == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
     __pyx_v_detrend_order = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_detrend_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
-    __pyx_v_psd = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[4]); if (unlikely(!__pyx_v_psd.memview)) __PYX_ERR(0, 7, __pyx_L3_error)
-    __pyx_v_cn = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[5]); if (unlikely(!__pyx_v_cn.memview)) __PYX_ERR(0, 7, __pyx_L3_error)
+    __pyx_v_psd = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[4], PyBUF_WRITABLE); if (unlikely(!__pyx_v_psd.memview)) __PYX_ERR(0, 7, __pyx_L3_error)
+    __pyx_v_cn = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[5], PyBUF_WRITABLE); if (unlikely(!__pyx_v_cn.memview)) __PYX_ERR(0, 7, __pyx_L3_error)
     __pyx_v_wth = ((PyArrayObject *)values[6]);
-    __pyx_v_sinx = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[7]); if (unlikely(!__pyx_v_sinx.memview)) __PYX_ERR(0, 8, __pyx_L3_error)
-    __pyx_v_cosx = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[8]); if (unlikely(!__pyx_v_cosx.memview)) __PYX_ERR(0, 8, __pyx_L3_error)
-    __pyx_v_sinx_step = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[9]); if (unlikely(!__pyx_v_sinx_step.memview)) __PYX_ERR(0, 8, __pyx_L3_error)
-    __pyx_v_cosx_step = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[10]); if (unlikely(!__pyx_v_cosx_step.memview)) __PYX_ERR(0, 9, __pyx_L3_error)
-    __pyx_v_sinx_back = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[11]); if (unlikely(!__pyx_v_sinx_back.memview)) __PYX_ERR(0, 9, __pyx_L3_error)
-    __pyx_v_cosx_back = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[12]); if (unlikely(!__pyx_v_cosx_back.memview)) __PYX_ERR(0, 10, __pyx_L3_error)
-    __pyx_v_sinx_smallstep = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[13]); if (unlikely(!__pyx_v_sinx_smallstep.memview)) __PYX_ERR(0, 10, __pyx_L3_error)
-    __pyx_v_cosx_smallstep = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[14]); if (unlikely(!__pyx_v_cosx_smallstep.memview)) __PYX_ERR(0, 11, __pyx_L3_error)
-    __pyx_v_hat_matr = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(values[15]); if (unlikely(!__pyx_v_hat_matr.memview)) __PYX_ERR(0, 11, __pyx_L3_error)
-    __pyx_v_hat_hat = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(values[16]); if (unlikely(!__pyx_v_hat_hat.memview)) __PYX_ERR(0, 12, __pyx_L3_error)
-    __pyx_v_hat0 = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(values[17]); if (unlikely(!__pyx_v_hat0.memview)) __PYX_ERR(0, 12, __pyx_L3_error)
-    __pyx_v_soln = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[18]); if (unlikely(!__pyx_v_soln.memview)) __PYX_ERR(0, 13, __pyx_L3_error)
+    __pyx_v_sinx = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[7], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sinx.memview)) __PYX_ERR(0, 8, __pyx_L3_error)
+    __pyx_v_cosx = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[8], PyBUF_WRITABLE); if (unlikely(!__pyx_v_cosx.memview)) __PYX_ERR(0, 8, __pyx_L3_error)
+    __pyx_v_sinx_step = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[9], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sinx_step.memview)) __PYX_ERR(0, 8, __pyx_L3_error)
+    __pyx_v_cosx_step = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[10], PyBUF_WRITABLE); if (unlikely(!__pyx_v_cosx_step.memview)) __PYX_ERR(0, 9, __pyx_L3_error)
+    __pyx_v_sinx_back = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[11], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sinx_back.memview)) __PYX_ERR(0, 9, __pyx_L3_error)
+    __pyx_v_cosx_back = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[12], PyBUF_WRITABLE); if (unlikely(!__pyx_v_cosx_back.memview)) __PYX_ERR(0, 10, __pyx_L3_error)
+    __pyx_v_sinx_smallstep = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[13], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sinx_smallstep.memview)) __PYX_ERR(0, 10, __pyx_L3_error)
+    __pyx_v_cosx_smallstep = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[14], PyBUF_WRITABLE); if (unlikely(!__pyx_v_cosx_smallstep.memview)) __PYX_ERR(0, 11, __pyx_L3_error)
+    __pyx_v_hat_matr = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(values[15], PyBUF_WRITABLE); if (unlikely(!__pyx_v_hat_matr.memview)) __PYX_ERR(0, 11, __pyx_L3_error)
+    __pyx_v_hat_hat = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(values[16], PyBUF_WRITABLE); if (unlikely(!__pyx_v_hat_hat.memview)) __PYX_ERR(0, 12, __pyx_L3_error)
+    __pyx_v_hat0 = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(values[17], PyBUF_WRITABLE); if (unlikely(!__pyx_v_hat0.memview)) __PYX_ERR(0, 12, __pyx_L3_error)
+    __pyx_v_soln = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[18], PyBUF_WRITABLE); if (unlikely(!__pyx_v_soln.memview)) __PYX_ERR(0, 13, __pyx_L3_error)
     __pyx_v_chi0 = __pyx_PyFloat_AsDouble(values[19]); if (unlikely((__pyx_v_chi0 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 13, __pyx_L3_error)
     __pyx_v_freq_zoom = __pyx_PyFloat_AsDouble(values[20]); if (unlikely((__pyx_v_freq_zoom == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 13, __pyx_L3_error)
     __pyx_v_psdmin = __pyx_PyFloat_AsDouble(values[21]); if (unlikely((__pyx_v_psdmin == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 14, __pyx_L3_error)
     __pyx_v_tone_control = __pyx_PyFloat_AsDouble(values[22]); if (unlikely((__pyx_v_tone_control == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 14, __pyx_L3_error)
     __pyx_v_lambda0 = ((PyArrayObject *)values[23]);
-    __pyx_v_lambda0_range = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[24]); if (unlikely(!__pyx_v_lambda0_range.memview)) __PYX_ERR(0, 16, __pyx_L3_error)
+    __pyx_v_lambda0_range = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[24], PyBUF_WRITABLE); if (unlikely(!__pyx_v_lambda0_range.memview)) __PYX_ERR(0, 16, __pyx_L3_error)
     __pyx_v_Tr = ((PyArrayObject *)values[25]);
     __pyx_v_ifreq = ((PyArrayObject *)values[26]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
   __Pyx_RaiseArgtupleInvalid("lomb_scargle", 1, 27, 27, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 6, __pyx_L3_error)
   __pyx_L3_error:;
@@ -2810,15 +2941,15 @@
  * 
  *     _lomb_scargle(numt, numf, nharm, detrend_order, &psd[0], &cn[0],
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_wth), __pyx_n_s_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 20, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_double); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 20, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_t_2 = PyObject_RichCompare(__pyx_t_1, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
@@ -3107,20 +3238,20 @@
   __PYX_XDEC_MEMVIEW(&__pyx_v_soln, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_lambda0_range, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":214
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":258
  *         # experimental exception made for __getbuffer__ and __releasebuffer__
  *         # -- the details of this may change.
  *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
  *             # This implementation of getbuffer is geared towards Cython
- *             # requirements, and does not yet fullfill the PEP.
+ *             # requirements, and does not yet fulfill the PEP.
  */
 
 /* Python wrapper */
 static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 static CYTHON_UNUSED int __pyx_pw_5numpy_7ndarray_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
@@ -3129,865 +3260,757 @@
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
-  int __pyx_v_copy_shape;
   int __pyx_v_i;
   int __pyx_v_ndim;
   int __pyx_v_endian_detector;
   int __pyx_v_little_endian;
   int __pyx_v_t;
   char *__pyx_v_f;
   PyArray_Descr *__pyx_v_descr = 0;
   int __pyx_v_offset;
-  int __pyx_v_hasfields;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   int __pyx_t_5;
-  PyObject *__pyx_t_6 = NULL;
-  char *__pyx_t_7;
-  __Pyx_RefNannySetupContext("__getbuffer__", 0);
-  if (__pyx_v_info != NULL) {
-    __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
-    __Pyx_GIVEREF(__pyx_v_info->obj);
-  }
-
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":220
- *             # of flags
- * 
- *             if info == NULL: return             # <<<<<<<<<<<<<<
- * 
- *             cdef int copy_shape, i, ndim
- */
-  __pyx_t_1 = ((__pyx_v_info == NULL) != 0);
-  if (__pyx_t_1) {
-    __pyx_r = 0;
-    goto __pyx_L0;
+  int __pyx_t_6;
+  PyArray_Descr *__pyx_t_7;
+  PyObject *__pyx_t_8 = NULL;
+  char *__pyx_t_9;
+  if (__pyx_v_info == NULL) {
+    PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
+    return -1;
   }
+  __Pyx_RefNannySetupContext("__getbuffer__", 0);
+  __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":223
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":265
  * 
- *             cdef int copy_shape, i, ndim
+ *             cdef int i, ndim
  *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  * 
  */
   __pyx_v_endian_detector = 1;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":224
- *             cdef int copy_shape, i, ndim
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":266
+ *             cdef int i, ndim
  *             cdef int endian_detector = 1
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
  * 
  *             ndim = PyArray_NDIM(self)
  */
   __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":226
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":268
  *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  * 
  *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<
  * 
- *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
+ *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
  */
   __pyx_v_ndim = PyArray_NDIM(__pyx_v_self);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":228
- *             ndim = PyArray_NDIM(self)
- * 
- *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
- *                 copy_shape = 1
- *             else:
- */
-  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
-  if (__pyx_t_1) {
-
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":229
- * 
- *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
- *                 copy_shape = 1             # <<<<<<<<<<<<<<
- *             else:
- *                 copy_shape = 0
- */
-    __pyx_v_copy_shape = 1;
-
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":228
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":270
  *             ndim = PyArray_NDIM(self)
  * 
- *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
- *                 copy_shape = 1
- *             else:
- */
-    goto __pyx_L4;
-  }
-
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":231
- *                 copy_shape = 1
- *             else:
- *                 copy_shape = 0             # <<<<<<<<<<<<<<
- * 
- *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
- */
-  /*else*/ {
-    __pyx_v_copy_shape = 0;
-  }
-  __pyx_L4:;
-
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":233
- *                 copy_shape = 0
- * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
- *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")
  */
   __pyx_t_2 = (((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS) != 0);
   if (__pyx_t_2) {
   } else {
     __pyx_t_1 = __pyx_t_2;
-    goto __pyx_L6_bool_binop_done;
+    goto __pyx_L4_bool_binop_done;
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":234
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":271
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
- *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
  *                 raise ValueError(u"ndarray is not C contiguous")
  * 
  */
-  __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_C_CONTIGUOUS) != 0)) != 0);
+  __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_ARRAY_C_CONTIGUOUS) != 0)) != 0);
   __pyx_t_1 = __pyx_t_2;
-  __pyx_L6_bool_binop_done:;
+  __pyx_L4_bool_binop_done:;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":233
- *                 copy_shape = 0
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":270
+ *             ndim = PyArray_NDIM(self)
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
- *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")
  */
-  if (__pyx_t_1) {
+  if (unlikely(__pyx_t_1)) {
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":235
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":272
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
- *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 235, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 272, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 235, __pyx_L1_error)
+    __PYX_ERR(1, 272, __pyx_L1_error)
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":233
- *                 copy_shape = 0
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":270
+ *             ndim = PyArray_NDIM(self)
  * 
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
- *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")
  */
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":237
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":274
  *                 raise ValueError(u"ndarray is not C contiguous")
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
- *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  */
   __pyx_t_2 = (((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS) != 0);
   if (__pyx_t_2) {
   } else {
     __pyx_t_1 = __pyx_t_2;
-    goto __pyx_L9_bool_binop_done;
+    goto __pyx_L7_bool_binop_done;
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":238
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":275
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
- *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  * 
  */
-  __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_F_CONTIGUOUS) != 0)) != 0);
+  __pyx_t_2 = ((!(PyArray_CHKFLAGS(__pyx_v_self, NPY_ARRAY_F_CONTIGUOUS) != 0)) != 0);
   __pyx_t_1 = __pyx_t_2;
-  __pyx_L9_bool_binop_done:;
+  __pyx_L7_bool_binop_done:;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":237
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":274
  *                 raise ValueError(u"ndarray is not C contiguous")
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
- *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  */
-  if (__pyx_t_1) {
+  if (unlikely(__pyx_t_1)) {
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":239
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":276
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
- *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
  * 
  *             info.buf = PyArray_DATA(self)
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 239, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 276, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(1, 239, __pyx_L1_error)
+    __PYX_ERR(1, 276, __pyx_L1_error)
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":237
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":274
  *                 raise ValueError(u"ndarray is not C contiguous")
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
- *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  */
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":241
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":278
  *                 raise ValueError(u"ndarray is not Fortran contiguous")
  * 
  *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<
  *             info.ndim = ndim
- *             if copy_shape:
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  */
   __pyx_v_info->buf = PyArray_DATA(__pyx_v_self);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":242
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":279
  * 
  *             info.buf = PyArray_DATA(self)
  *             info.ndim = ndim             # <<<<<<<<<<<<<<
- *             if copy_shape:
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 # Allocate new buffer for strides and shape info.
  */
   __pyx_v_info->ndim = __pyx_v_ndim;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":243
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":280
  *             info.buf = PyArray_DATA(self)
  *             info.ndim = ndim
- *             if copy_shape:             # <<<<<<<<<<<<<<
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
  *                 # Allocate new buffer for strides and shape info.
  *                 # This is allocated as one block, strides first.
  */
-  __pyx_t_1 = (__pyx_v_copy_shape != 0);
+  __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
   if (__pyx_t_1) {
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":246
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":283
  *                 # Allocate new buffer for strides and shape info.
  *                 # This is allocated as one block, strides first.
  *                 info.strides = <Py_ssize_t*>PyObject_Malloc(sizeof(Py_ssize_t) * 2 * <size_t>ndim)             # <<<<<<<<<<<<<<
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):
  */
     __pyx_v_info->strides = ((Py_ssize_t *)PyObject_Malloc((((sizeof(Py_ssize_t)) * 2) * ((size_t)__pyx_v_ndim))));
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":247
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":284
  *                 # This is allocated as one block, strides first.
  *                 info.strides = <Py_ssize_t*>PyObject_Malloc(sizeof(Py_ssize_t) * 2 * <size_t>ndim)
  *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  */
     __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":248
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":285
  *                 info.strides = <Py_ssize_t*>PyObject_Malloc(sizeof(Py_ssize_t) * 2 * <size_t>ndim)
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):             # <<<<<<<<<<<<<<
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  */
     __pyx_t_4 = __pyx_v_ndim;
-    for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
-      __pyx_v_i = __pyx_t_5;
+    __pyx_t_5 = __pyx_t_4;
+    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+      __pyx_v_i = __pyx_t_6;
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":249
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":286
  *                 info.shape = info.strides + ndim
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  *             else:
  */
       (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(__pyx_v_self)[__pyx_v_i]);
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":250
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":287
  *                 for i in range(ndim):
  *                     info.strides[i] = PyArray_STRIDES(self)[i]
  *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  */
       (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(__pyx_v_self)[__pyx_v_i]);
     }
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":243
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":280
  *             info.buf = PyArray_DATA(self)
  *             info.ndim = ndim
- *             if copy_shape:             # <<<<<<<<<<<<<<
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
  *                 # Allocate new buffer for strides and shape info.
  *                 # This is allocated as one block, strides first.
  */
-    goto __pyx_L11;
+    goto __pyx_L9;
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":252
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":289
  *                     info.shape[i] = PyArray_DIMS(self)[i]
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL
  */
   /*else*/ {
     __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(__pyx_v_self));
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":253
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":290
  *             else:
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)
  */
     __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(__pyx_v_self));
   }
-  __pyx_L11:;
+  __pyx_L9:;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":254
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":291
  *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
  *             info.itemsize = PyArray_ITEMSIZE(self)
  *             info.readonly = not PyArray_ISWRITEABLE(self)
  */
   __pyx_v_info->suboffsets = NULL;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":255
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":292
  *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<
  *             info.readonly = not PyArray_ISWRITEABLE(self)
  * 
  */
   __pyx_v_info->itemsize = PyArray_ITEMSIZE(__pyx_v_self);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":256
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":293
  *             info.suboffsets = NULL
  *             info.itemsize = PyArray_ITEMSIZE(self)
  *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<
  * 
  *             cdef int t
  */
   __pyx_v_info->readonly = (!(PyArray_ISWRITEABLE(__pyx_v_self) != 0));
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":259
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":296
  * 
  *             cdef int t
  *             cdef char* f = NULL             # <<<<<<<<<<<<<<
- *             cdef dtype descr = self.descr
+ *             cdef dtype descr = <dtype>PyArray_DESCR(self)
  *             cdef int offset
  */
   __pyx_v_f = NULL;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":260
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":297
  *             cdef int t
  *             cdef char* f = NULL
- *             cdef dtype descr = self.descr             # <<<<<<<<<<<<<<
+ *             cdef dtype descr = <dtype>PyArray_DESCR(self)             # <<<<<<<<<<<<<<
  *             cdef int offset
  * 
  */
-  __pyx_t_3 = ((PyObject *)__pyx_v_self->descr);
+  __pyx_t_7 = PyArray_DESCR(__pyx_v_self);
+  __pyx_t_3 = ((PyObject *)__pyx_t_7);
   __Pyx_INCREF(__pyx_t_3);
   __pyx_v_descr = ((PyArray_Descr *)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":263
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":300
  *             cdef int offset
  * 
- *             cdef bint hasfields = PyDataType_HASFIELDS(descr)             # <<<<<<<<<<<<<<
- * 
- *             if not hasfields and not copy_shape:
- */
-  __pyx_v_hasfields = PyDataType_HASFIELDS(__pyx_v_descr);
-
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":265
- *             cdef bint hasfields = PyDataType_HASFIELDS(descr)
- * 
- *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<
- *                 # do not call releasebuffer
- *                 info.obj = None
- */
-  __pyx_t_2 = ((!(__pyx_v_hasfields != 0)) != 0);
-  if (__pyx_t_2) {
-  } else {
-    __pyx_t_1 = __pyx_t_2;
-    goto __pyx_L15_bool_binop_done;
-  }
-  __pyx_t_2 = ((!(__pyx_v_copy_shape != 0)) != 0);
-  __pyx_t_1 = __pyx_t_2;
-  __pyx_L15_bool_binop_done:;
-  if (__pyx_t_1) {
-
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":267
- *             if not hasfields and not copy_shape:
- *                 # do not call releasebuffer
- *                 info.obj = None             # <<<<<<<<<<<<<<
- *             else:
- *                 # need to call releasebuffer
- */
-    __Pyx_INCREF(Py_None);
-    __Pyx_GIVEREF(Py_None);
-    __Pyx_GOTREF(__pyx_v_info->obj);
-    __Pyx_DECREF(__pyx_v_info->obj);
-    __pyx_v_info->obj = Py_None;
-
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":265
- *             cdef bint hasfields = PyDataType_HASFIELDS(descr)
- * 
- *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<
- *                 # do not call releasebuffer
- *                 info.obj = None
- */
-    goto __pyx_L14;
-  }
-
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":270
- *             else:
- *                 # need to call releasebuffer
- *                 info.obj = self             # <<<<<<<<<<<<<<
+ *             info.obj = self             # <<<<<<<<<<<<<<
  * 
- *             if not hasfields:
+ *             if not PyDataType_HASFIELDS(descr):
  */
-  /*else*/ {
-    __Pyx_INCREF(((PyObject *)__pyx_v_self));
-    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
-    __Pyx_GOTREF(__pyx_v_info->obj);
-    __Pyx_DECREF(__pyx_v_info->obj);
-    __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
-  }
-  __pyx_L14:;
+  __Pyx_INCREF(((PyObject *)__pyx_v_self));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
+  __Pyx_GOTREF(__pyx_v_info->obj);
+  __Pyx_DECREF(__pyx_v_info->obj);
+  __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":272
- *                 info.obj = self
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":302
+ *             info.obj = self
  * 
- *             if not hasfields:             # <<<<<<<<<<<<<<
+ *             if not PyDataType_HASFIELDS(descr):             # <<<<<<<<<<<<<<
  *                 t = descr.type_num
  *                 if ((descr.byteorder == c'>' and little_endian) or
  */
-  __pyx_t_1 = ((!(__pyx_v_hasfields != 0)) != 0);
+  __pyx_t_1 = ((!(PyDataType_HASFIELDS(__pyx_v_descr) != 0)) != 0);
   if (__pyx_t_1) {
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":273
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":303
  * 
- *             if not hasfields:
+ *             if not PyDataType_HASFIELDS(descr):
  *                 t = descr.type_num             # <<<<<<<<<<<<<<
  *                 if ((descr.byteorder == c'>' and little_endian) or
  *                     (descr.byteorder == c'<' and not little_endian)):
  */
     __pyx_t_4 = __pyx_v_descr->type_num;
     __pyx_v_t = __pyx_t_4;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":274
- *             if not hasfields:
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":304
+ *             if not PyDataType_HASFIELDS(descr):
  *                 t = descr.type_num
  *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
  *                     (descr.byteorder == c'<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")
  */
     __pyx_t_2 = ((__pyx_v_descr->byteorder == '>') != 0);
     if (!__pyx_t_2) {
-      goto __pyx_L20_next_or;
+      goto __pyx_L15_next_or;
     } else {
     }
     __pyx_t_2 = (__pyx_v_little_endian != 0);
     if (!__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
-      goto __pyx_L19_bool_binop_done;
+      goto __pyx_L14_bool_binop_done;
     }
-    __pyx_L20_next_or:;
+    __pyx_L15_next_or:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":275
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":305
  *                 t = descr.type_num
  *                 if ((descr.byteorder == c'>' and little_endian) or
  *                     (descr.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"
  */
     __pyx_t_2 = ((__pyx_v_descr->byteorder == '<') != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
-      goto __pyx_L19_bool_binop_done;
+      goto __pyx_L14_bool_binop_done;
     }
     __pyx_t_2 = ((!(__pyx_v_little_endian != 0)) != 0);
     __pyx_t_1 = __pyx_t_2;
-    __pyx_L19_bool_binop_done:;
+    __pyx_L14_bool_binop_done:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":274
- *             if not hasfields:
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":304
+ *             if not PyDataType_HASFIELDS(descr):
  *                 t = descr.type_num
  *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
  *                     (descr.byteorder == c'<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")
  */
-    if (__pyx_t_1) {
+    if (unlikely(__pyx_t_1)) {
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":276
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":306
  *                 if ((descr.byteorder == c'>' and little_endian) or
  *                     (descr.byteorder == c'<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  */
-      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 276, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 306, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(1, 276, __pyx_L1_error)
+      __PYX_ERR(1, 306, __pyx_L1_error)
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":274
- *             if not hasfields:
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":304
+ *             if not PyDataType_HASFIELDS(descr):
  *                 t = descr.type_num
  *                 if ((descr.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
  *                     (descr.byteorder == c'<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")
  */
     }
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":277
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":307
  *                     (descr.byteorder == c'<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"
  */
     switch (__pyx_v_t) {
       case NPY_BYTE:
       __pyx_v_f = ((char *)"b");
       break;
+      case NPY_UBYTE:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":278
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":308
  *                     raise ValueError(u"Non-native byte order not supported")
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"
  */
-      case NPY_UBYTE:
       __pyx_v_f = ((char *)"B");
       break;
+      case NPY_SHORT:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":279
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":309
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"
  */
-      case NPY_SHORT:
       __pyx_v_f = ((char *)"h");
       break;
+      case NPY_USHORT:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":280
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":310
  *                 elif t == NPY_UBYTE:       f = "B"
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"
  */
-      case NPY_USHORT:
       __pyx_v_f = ((char *)"H");
       break;
+      case NPY_INT:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":281
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":311
  *                 elif t == NPY_SHORT:       f = "h"
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"
  */
-      case NPY_INT:
       __pyx_v_f = ((char *)"i");
       break;
+      case NPY_UINT:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":282
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":312
  *                 elif t == NPY_USHORT:      f = "H"
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"
  */
-      case NPY_UINT:
       __pyx_v_f = ((char *)"I");
       break;
+      case NPY_LONG:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":283
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":313
  *                 elif t == NPY_INT:         f = "i"
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"
  */
-      case NPY_LONG:
       __pyx_v_f = ((char *)"l");
       break;
+      case NPY_ULONG:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":284
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":314
  *                 elif t == NPY_UINT:        f = "I"
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  */
-      case NPY_ULONG:
       __pyx_v_f = ((char *)"L");
       break;
+      case NPY_LONGLONG:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":285
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":315
  *                 elif t == NPY_LONG:        f = "l"
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"
  */
-      case NPY_LONGLONG:
       __pyx_v_f = ((char *)"q");
       break;
+      case NPY_ULONGLONG:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":286
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":316
  *                 elif t == NPY_ULONG:       f = "L"
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"
  */
-      case NPY_ULONGLONG:
       __pyx_v_f = ((char *)"Q");
       break;
+      case NPY_FLOAT:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":287
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":317
  *                 elif t == NPY_LONGLONG:    f = "q"
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  */
-      case NPY_FLOAT:
       __pyx_v_f = ((char *)"f");
       break;
+      case NPY_DOUBLE:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":288
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":318
  *                 elif t == NPY_ULONGLONG:   f = "Q"
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  */
-      case NPY_DOUBLE:
       __pyx_v_f = ((char *)"d");
       break;
+      case NPY_LONGDOUBLE:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":289
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":319
  *                 elif t == NPY_FLOAT:       f = "f"
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  */
-      case NPY_LONGDOUBLE:
       __pyx_v_f = ((char *)"g");
       break;
+      case NPY_CFLOAT:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":290
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":320
  *                 elif t == NPY_DOUBLE:      f = "d"
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  */
-      case NPY_CFLOAT:
       __pyx_v_f = ((char *)"Zf");
       break;
+      case NPY_CDOUBLE:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":291
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":321
  *                 elif t == NPY_LONGDOUBLE:  f = "g"
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  *                 elif t == NPY_OBJECT:      f = "O"
  */
-      case NPY_CDOUBLE:
       __pyx_v_f = ((char *)"Zd");
       break;
+      case NPY_CLONGDOUBLE:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":292
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":322
  *                 elif t == NPY_CFLOAT:      f = "Zf"
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"             # <<<<<<<<<<<<<<
  *                 elif t == NPY_OBJECT:      f = "O"
  *                 else:
  */
-      case NPY_CLONGDOUBLE:
       __pyx_v_f = ((char *)"Zg");
       break;
+      case NPY_OBJECT:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":293
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":323
  *                 elif t == NPY_CDOUBLE:     f = "Zd"
  *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
  *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  */
-      case NPY_OBJECT:
       __pyx_v_f = ((char *)"O");
       break;
       default:
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":295
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":325
  *                 elif t == NPY_OBJECT:      f = "O"
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
  *                 info.format = f
  *                 return
  */
-      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_t); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 295, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_t); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 325, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_6 = PyUnicode_Format(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 295, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
+      __pyx_t_8 = PyUnicode_Format(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 325, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 295, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 325, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_GIVEREF(__pyx_t_6);
-      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_6);
-      __pyx_t_6 = 0;
-      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 295, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __PYX_ERR(1, 295, __pyx_L1_error)
+      __PYX_ERR(1, 325, __pyx_L1_error)
       break;
     }
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":296
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":326
  *                 else:
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *                 info.format = f             # <<<<<<<<<<<<<<
  *                 return
  *             else:
  */
     __pyx_v_info->format = __pyx_v_f;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":297
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":327
  *                     raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *                 info.format = f
  *                 return             # <<<<<<<<<<<<<<
  *             else:
  *                 info.format = <char*>PyObject_Malloc(_buffer_format_string_len)
  */
     __pyx_r = 0;
     goto __pyx_L0;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":272
- *                 info.obj = self
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":302
+ *             info.obj = self
  * 
- *             if not hasfields:             # <<<<<<<<<<<<<<
+ *             if not PyDataType_HASFIELDS(descr):             # <<<<<<<<<<<<<<
  *                 t = descr.type_num
  *                 if ((descr.byteorder == c'>' and little_endian) or
  */
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":299
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":329
  *                 return
  *             else:
  *                 info.format = <char*>PyObject_Malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<
  *                 info.format[0] = c'^' # Native data types, manual alignment
  *                 offset = 0
  */
   /*else*/ {
     __pyx_v_info->format = ((char *)PyObject_Malloc(0xFF));
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":300
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":330
  *             else:
  *                 info.format = <char*>PyObject_Malloc(_buffer_format_string_len)
  *                 info.format[0] = c'^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
  *                 offset = 0
  *                 f = _util_dtypestring(descr, info.format + 1,
  */
     (__pyx_v_info->format[0]) = '^';
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":301
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":331
  *                 info.format = <char*>PyObject_Malloc(_buffer_format_string_len)
  *                 info.format[0] = c'^' # Native data types, manual alignment
  *                 offset = 0             # <<<<<<<<<<<<<<
  *                 f = _util_dtypestring(descr, info.format + 1,
  *                                       info.format + _buffer_format_string_len,
  */
     __pyx_v_offset = 0;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":302
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":332
  *                 info.format[0] = c'^' # Native data types, manual alignment
  *                 offset = 0
  *                 f = _util_dtypestring(descr, info.format + 1,             # <<<<<<<<<<<<<<
  *                                       info.format + _buffer_format_string_len,
  *                                       &offset)
  */
-    __pyx_t_7 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 0xFF), (&__pyx_v_offset)); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(1, 302, __pyx_L1_error)
-    __pyx_v_f = __pyx_t_7;
+    __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 0xFF), (&__pyx_v_offset)); if (unlikely(__pyx_t_9 == ((char *)NULL))) __PYX_ERR(1, 332, __pyx_L1_error)
+    __pyx_v_f = __pyx_t_9;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":305
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":335
  *                                       info.format + _buffer_format_string_len,
  *                                       &offset)
  *                 f[0] = c'\0' # Terminate format string             # <<<<<<<<<<<<<<
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  */
     (__pyx_v_f[0]) = '\x00';
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":214
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":258
  *         # experimental exception made for __getbuffer__ and __releasebuffer__
  *         # -- the details of this may change.
  *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
  *             # This implementation of getbuffer is geared towards Cython
- *             # requirements, and does not yet fullfill the PEP.
+ *             # requirements, and does not yet fulfill the PEP.
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_XDECREF(__pyx_t_8);
   __Pyx_AddTraceback("numpy.ndarray.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
-  if (__pyx_v_info != NULL && __pyx_v_info->obj != NULL) {
+  if (__pyx_v_info->obj != NULL) {
     __Pyx_GOTREF(__pyx_v_info->obj);
-    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;
+    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   goto __pyx_L2;
   __pyx_L0:;
-  if (__pyx_v_info != NULL && __pyx_v_info->obj == Py_None) {
-    __Pyx_GOTREF(Py_None);
-    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
+  if (__pyx_v_info->obj == Py_None) {
+    __Pyx_GOTREF(__pyx_v_info->obj);
+    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_XDECREF((PyObject *)__pyx_v_descr);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":307
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":337
  *                 f[0] = c'\0' # Terminate format string
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
  *             if PyArray_HASFIELDS(self):
  *                 PyObject_Free(info.format)
  */
 
@@ -4003,111 +4026,111 @@
 }
 
 static void __pyx_pf_5numpy_7ndarray_2__releasebuffer__(PyArrayObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__releasebuffer__", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":308
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":338
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
  *                 PyObject_Free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  */
   __pyx_t_1 = (PyArray_HASFIELDS(__pyx_v_self) != 0);
   if (__pyx_t_1) {
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":309
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":339
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  *             if PyArray_HASFIELDS(self):
  *                 PyObject_Free(info.format)             # <<<<<<<<<<<<<<
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 PyObject_Free(info.strides)
  */
     PyObject_Free(__pyx_v_info->format);
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":308
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":338
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):
  *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
  *                 PyObject_Free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  */
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":310
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":340
  *             if PyArray_HASFIELDS(self):
  *                 PyObject_Free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
  *                 PyObject_Free(info.strides)
  *                 # info.shape was stored after info.strides in the same block
  */
   __pyx_t_1 = (((sizeof(npy_intp)) != (sizeof(Py_ssize_t))) != 0);
   if (__pyx_t_1) {
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":311
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":341
  *                 PyObject_Free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
  *                 PyObject_Free(info.strides)             # <<<<<<<<<<<<<<
  *                 # info.shape was stored after info.strides in the same block
  * 
  */
     PyObject_Free(__pyx_v_info->strides);
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":310
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":340
  *             if PyArray_HASFIELDS(self):
  *                 PyObject_Free(info.format)
  *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
  *                 PyObject_Free(info.strides)
  *                 # info.shape was stored after info.strides in the same block
  */
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":307
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":337
  *                 f[0] = c'\0' # Terminate format string
  * 
  *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
  *             if PyArray_HASFIELDS(self):
  *                 PyObject_Free(info.format)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":788
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":821
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew1(PyObject *__pyx_v_a) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":789
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":822
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 789, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 822, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":788
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":821
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -4118,43 +4141,43 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":791
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":824
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew2(PyObject *__pyx_v_a, PyObject *__pyx_v_b) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":792
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":825
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 792, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 825, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":791
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":824
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -4165,43 +4188,43 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":794
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":827
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew3(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":795
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":828
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 795, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 828, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":794
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":827
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -4212,43 +4235,43 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":797
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":830
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew4(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":798
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":831
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 798, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 831, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":797
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":830
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -4259,43 +4282,43 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":800
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":833
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyArray_MultiIterNew5(PyObject *__pyx_v_a, PyObject *__pyx_v_b, PyObject *__pyx_v_c, PyObject *__pyx_v_d, PyObject *__pyx_v_e) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":801
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":834
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 801, __pyx_L1_error)
+  __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 834, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":800
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":833
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -4306,89 +4329,89 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":803
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":836
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("PyDataType_SHAPE", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":804
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":837
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   __pyx_t_1 = (PyDataType_HASSUBARRAY(__pyx_v_d) != 0);
   if (__pyx_t_1) {
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":805
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":838
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<
  *     else:
  *         return ()
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));
     __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);
     goto __pyx_L0;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":804
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":837
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":807
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":840
  *         return <tuple>d.subarray.shape
  *     else:
  *         return ()             # <<<<<<<<<<<<<<
  * 
  * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_empty_tuple);
     __pyx_r = __pyx_empty_tuple;
     goto __pyx_L0;
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":803
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":836
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":809
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":842
  *         return ()
  * 
  * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
  *     # Recursive utility function used in __getbuffer__ to get format
  *     # string. The new location in the format string is returned.
  */
 
@@ -4409,151 +4432,147 @@
   int __pyx_t_5;
   int __pyx_t_6;
   int __pyx_t_7;
   long __pyx_t_8;
   char *__pyx_t_9;
   __Pyx_RefNannySetupContext("_util_dtypestring", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":814
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":847
  * 
  *     cdef dtype child
  *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<
  *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
  *     cdef tuple fields
  */
   __pyx_v_endian_detector = 1;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":815
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":848
  *     cdef dtype child
  *     cdef int endian_detector = 1
  *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
  *     cdef tuple fields
  * 
  */
   __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":818
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":851
  *     cdef tuple fields
  * 
  *     for childname in descr.names:             # <<<<<<<<<<<<<<
  *         fields = descr.fields[childname]
  *         child, new_offset = fields
  */
   if (unlikely(__pyx_v_descr->names == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-    __PYX_ERR(1, 818, __pyx_L1_error)
+    __PYX_ERR(1, 851, __pyx_L1_error)
   }
   __pyx_t_1 = __pyx_v_descr->names; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
   for (;;) {
     if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 818, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 851, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 818, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 851, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     __Pyx_XDECREF_SET(__pyx_v_childname, __pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":819
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":852
  * 
  *     for childname in descr.names:
  *         fields = descr.fields[childname]             # <<<<<<<<<<<<<<
  *         child, new_offset = fields
  * 
  */
     if (unlikely(__pyx_v_descr->fields == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-      __PYX_ERR(1, 819, __pyx_L1_error)
+      __PYX_ERR(1, 852, __pyx_L1_error)
     }
-    __pyx_t_3 = __Pyx_PyDict_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 819, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyDict_GetItem(__pyx_v_descr->fields, __pyx_v_childname); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 852, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_t_3)->tp_name), 0))) __PYX_ERR(1, 819, __pyx_L1_error)
+    if (!(likely(PyTuple_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_t_3)->tp_name), 0))) __PYX_ERR(1, 852, __pyx_L1_error)
     __Pyx_XDECREF_SET(__pyx_v_fields, ((PyObject*)__pyx_t_3));
     __pyx_t_3 = 0;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":820
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":853
  *     for childname in descr.names:
  *         fields = descr.fields[childname]
  *         child, new_offset = fields             # <<<<<<<<<<<<<<
  * 
  *         if (end - f) - <int>(new_offset - offset[0]) < 15:
  */
     if (likely(__pyx_v_fields != Py_None)) {
       PyObject* sequence = __pyx_v_fields;
-      #if !CYTHON_COMPILING_IN_PYPY
-      Py_ssize_t size = Py_SIZE(sequence);
-      #else
-      Py_ssize_t size = PySequence_Size(sequence);
-      #endif
+      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 2)) {
         if (size > 2) __Pyx_RaiseTooManyValuesError(2);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(1, 820, __pyx_L1_error)
+        __PYX_ERR(1, 853, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_4);
       #else
-      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 820, __pyx_L1_error)
+      __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 853, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 820, __pyx_L1_error)
+      __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 853, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       #endif
     } else {
-      __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 820, __pyx_L1_error)
+      __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(1, 853, __pyx_L1_error)
     }
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) __PYX_ERR(1, 820, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5numpy_dtype))))) __PYX_ERR(1, 853, __pyx_L1_error)
     __Pyx_XDECREF_SET(__pyx_v_child, ((PyArray_Descr *)__pyx_t_3));
     __pyx_t_3 = 0;
     __Pyx_XDECREF_SET(__pyx_v_new_offset, __pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":822
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":855
  *         child, new_offset = fields
  * 
  *         if (end - f) - <int>(new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
  */
-    __pyx_t_4 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 822, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 855, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 822, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 855, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 822, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(1, 855, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_6 = ((((__pyx_v_end - __pyx_v_f) - ((int)__pyx_t_5)) < 15) != 0);
-    if (__pyx_t_6) {
+    if (unlikely(__pyx_t_6)) {
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":823
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":856
  * 
  *         if (end - f) - <int>(new_offset - offset[0]) < 15:
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
  * 
  *         if ((child.byteorder == c'>' and little_endian) or
  */
-      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 823, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 856, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(1, 823, __pyx_L1_error)
+      __PYX_ERR(1, 856, __pyx_L1_error)
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":822
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":855
  *         child, new_offset = fields
  * 
  *         if (end - f) - <int>(new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
  */
     }
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":825
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":858
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
  *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
  *             (child.byteorder == c'<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")
  */
     __pyx_t_7 = ((__pyx_v_child->byteorder == '>') != 0);
@@ -4565,15 +4584,15 @@
     if (!__pyx_t_7) {
     } else {
       __pyx_t_6 = __pyx_t_7;
       goto __pyx_L7_bool_binop_done;
     }
     __pyx_L8_next_or:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":826
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":859
  * 
  *         if ((child.byteorder == c'>' and little_endian) or
  *             (child.byteorder == c'<' and not little_endian)):             # <<<<<<<<<<<<<<
  *             raise ValueError(u"Non-native byte order not supported")
  *             # One could encode it in the format string and have Cython
  */
     __pyx_t_7 = ((__pyx_v_child->byteorder == '<') != 0);
@@ -4582,543 +4601,538 @@
       __pyx_t_6 = __pyx_t_7;
       goto __pyx_L7_bool_binop_done;
     }
     __pyx_t_7 = ((!(__pyx_v_little_endian != 0)) != 0);
     __pyx_t_6 = __pyx_t_7;
     __pyx_L7_bool_binop_done:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":825
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":858
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
  *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
  *             (child.byteorder == c'<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")
  */
-    if (__pyx_t_6) {
+    if (unlikely(__pyx_t_6)) {
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":827
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":860
  *         if ((child.byteorder == c'>' and little_endian) or
  *             (child.byteorder == c'<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *             # One could encode it in the format string and have Cython
  *             # complain instead, BUT: < and > in format strings also imply
  */
-      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 827, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 860, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
       __Pyx_Raise(__pyx_t_3, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(1, 827, __pyx_L1_error)
+      __PYX_ERR(1, 860, __pyx_L1_error)
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":825
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":858
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")
  * 
  *         if ((child.byteorder == c'>' and little_endian) or             # <<<<<<<<<<<<<<
  *             (child.byteorder == c'<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")
  */
     }
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":837
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":870
  * 
  *         # Output padding bytes
  *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<
  *             f[0] = 120 # "x"; pad byte
  *             f += 1
  */
     while (1) {
-      __pyx_t_3 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 837, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_int((__pyx_v_offset[0])); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 870, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_v_new_offset, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 837, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_v_new_offset, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 870, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 837, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 870, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (!__pyx_t_6) break;
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":838
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":871
  *         # Output padding bytes
  *         while offset[0] < new_offset:
  *             f[0] = 120 # "x"; pad byte             # <<<<<<<<<<<<<<
  *             f += 1
  *             offset[0] += 1
  */
       (__pyx_v_f[0]) = 0x78;
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":839
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":872
  *         while offset[0] < new_offset:
  *             f[0] = 120 # "x"; pad byte
  *             f += 1             # <<<<<<<<<<<<<<
  *             offset[0] += 1
  * 
  */
       __pyx_v_f = (__pyx_v_f + 1);
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":840
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":873
  *             f[0] = 120 # "x"; pad byte
  *             f += 1
  *             offset[0] += 1             # <<<<<<<<<<<<<<
  * 
  *         offset[0] += child.itemsize
  */
       __pyx_t_8 = 0;
       (__pyx_v_offset[__pyx_t_8]) = ((__pyx_v_offset[__pyx_t_8]) + 1);
     }
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":842
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":875
  *             offset[0] += 1
  * 
  *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<
  * 
  *         if not PyDataType_HASFIELDS(child):
  */
     __pyx_t_8 = 0;
     (__pyx_v_offset[__pyx_t_8]) = ((__pyx_v_offset[__pyx_t_8]) + __pyx_v_child->elsize);
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":844
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":877
  *         offset[0] += child.itemsize
  * 
  *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
  *             t = child.type_num
  *             if end - f < 5:
  */
     __pyx_t_6 = ((!(PyDataType_HASFIELDS(__pyx_v_child) != 0)) != 0);
     if (__pyx_t_6) {
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":845
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":878
  * 
  *         if not PyDataType_HASFIELDS(child):
  *             t = child.type_num             # <<<<<<<<<<<<<<
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")
  */
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_child->type_num); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 845, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_child->type_num); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 878, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_XDECREF_SET(__pyx_v_t, __pyx_t_4);
       __pyx_t_4 = 0;
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":846
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":879
  *         if not PyDataType_HASFIELDS(child):
  *             t = child.type_num
  *             if end - f < 5:             # <<<<<<<<<<<<<<
  *                 raise RuntimeError(u"Format string allocated too short.")
  * 
  */
       __pyx_t_6 = (((__pyx_v_end - __pyx_v_f) < 5) != 0);
-      if (__pyx_t_6) {
+      if (unlikely(__pyx_t_6)) {
 
-        /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":847
+        /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":880
  *             t = child.type_num
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  */
-        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 847, __pyx_L1_error)
+        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 880, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         __Pyx_Raise(__pyx_t_4, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __PYX_ERR(1, 847, __pyx_L1_error)
+        __PYX_ERR(1, 880, __pyx_L1_error)
 
-        /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":846
+        /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":879
  *         if not PyDataType_HASFIELDS(child):
  *             t = child.type_num
  *             if end - f < 5:             # <<<<<<<<<<<<<<
  *                 raise RuntimeError(u"Format string allocated too short.")
  * 
  */
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":850
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":883
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"             # <<<<<<<<<<<<<<
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_BYTE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 850, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_BYTE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 883, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 850, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 883, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 850, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 883, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 98;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":851
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":884
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"             # <<<<<<<<<<<<<<
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  */
-      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_UBYTE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 851, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_UBYTE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 884, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 851, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 884, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 851, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 884, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 66;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":852
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":885
  *             if   t == NPY_BYTE:        f[0] =  98 #"b"
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"             # <<<<<<<<<<<<<<
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_SHORT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 852, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_SHORT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 885, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 852, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 885, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 852, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 885, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 0x68;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":853
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":886
  *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"             # <<<<<<<<<<<<<<
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  */
-      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_USHORT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 853, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_USHORT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 886, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 853, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 886, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 853, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 886, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 72;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":854
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":887
  *             elif t == NPY_SHORT:       f[0] = 104 #"h"
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"             # <<<<<<<<<<<<<<
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_INT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 854, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_INT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 887, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 854, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 887, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 854, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 887, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 0x69;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":855
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":888
  *             elif t == NPY_USHORT:      f[0] =  72 #"H"
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  */
-      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_UINT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 855, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_UINT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 888, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 855, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 888, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 855, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 888, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 73;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":856
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":889
  *             elif t == NPY_INT:         f[0] = 105 #"i"
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"             # <<<<<<<<<<<<<<
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONG); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 856, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONG); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 889, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 856, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 889, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 856, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 889, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 0x6C;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":857
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":890
  *             elif t == NPY_UINT:        f[0] =  73 #"I"
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  */
-      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_ULONG); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 857, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_ULONG); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 890, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 857, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 890, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 857, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 890, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 76;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":858
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":891
  *             elif t == NPY_LONG:        f[0] = 108 #"l"
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"             # <<<<<<<<<<<<<<
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONGLONG); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 858, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONGLONG); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 891, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 858, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 891, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 858, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 891, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 0x71;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":859
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":892
  *             elif t == NPY_ULONG:       f[0] = 76  #"L"
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"             # <<<<<<<<<<<<<<
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  */
-      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_ULONGLONG); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 859, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_ULONGLONG); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 892, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 859, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 892, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 859, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 892, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 81;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":860
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":893
  *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"             # <<<<<<<<<<<<<<
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_FLOAT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 860, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_FLOAT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 893, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 860, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 893, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 860, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 893, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 0x66;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":861
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":894
  *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"             # <<<<<<<<<<<<<<
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  */
-      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_DOUBLE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 861, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_DOUBLE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 894, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 861, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 894, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 861, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 894, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 0x64;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":862
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":895
  *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"             # <<<<<<<<<<<<<<
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 862, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 895, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 862, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 895, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 862, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 895, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 0x67;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":863
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":896
  *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  */
-      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CFLOAT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 863, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CFLOAT); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 896, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 863, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 896, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 863, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 896, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 0x66;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":864
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":897
  *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CDOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 864, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CDOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 897, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 864, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 897, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 864, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 897, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 0x64;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":865
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":898
  *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  *             else:
  */
-      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 865, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 898, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 865, __pyx_L1_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 898, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 865, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 898, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
         (__pyx_v_f[0]) = 90;
         (__pyx_v_f[1]) = 0x67;
         __pyx_v_f = (__pyx_v_f + 1);
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":866
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":899
  *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
  *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"             # <<<<<<<<<<<<<<
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  */
-      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_OBJECT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 866, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_enum__NPY_TYPES(NPY_OBJECT); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 899, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 866, __pyx_L1_error)
+      __pyx_t_3 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 899, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 866, __pyx_L1_error)
+      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(1, 899, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      if (__pyx_t_6) {
+      if (likely(__pyx_t_6)) {
         (__pyx_v_f[0]) = 79;
         goto __pyx_L15;
       }
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":868
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":901
  *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
  *             f += 1
  *         else:
  */
       /*else*/ {
-        __pyx_t_3 = PyUnicode_Format(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_v_t); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 868, __pyx_L1_error)
+        __pyx_t_3 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_v_t); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 901, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 868, __pyx_L1_error)
+        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 901, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_GIVEREF(__pyx_t_3);
-        PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
-        __pyx_t_3 = 0;
-        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 868, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-        __PYX_ERR(1, 868, __pyx_L1_error)
+        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __PYX_ERR(1, 901, __pyx_L1_error)
       }
       __pyx_L15:;
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":869
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":902
  *             else:
  *                 raise ValueError(u"unknown dtype code in numpy.pxd (%d)" % t)
  *             f += 1             # <<<<<<<<<<<<<<
  *         else:
  *             # Cython ignores struct boundary information ("T{...}"),
  */
       __pyx_v_f = (__pyx_v_f + 1);
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":844
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":877
  *         offset[0] += child.itemsize
  * 
  *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
  *             t = child.type_num
  *             if end - f < 5:
  */
       goto __pyx_L13;
     }
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":873
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":906
  *             # Cython ignores struct boundary information ("T{...}"),
  *             # so don't output it
  *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<
  *     return f
  * 
  */
     /*else*/ {
-      __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_9 == ((char *)NULL))) __PYX_ERR(1, 873, __pyx_L1_error)
+      __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_9 == ((char *)NULL))) __PYX_ERR(1, 906, __pyx_L1_error)
       __pyx_v_f = __pyx_t_9;
     }
     __pyx_L13:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":818
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":851
  *     cdef tuple fields
  * 
  *     for childname in descr.names:             # <<<<<<<<<<<<<<
  *         fields = descr.fields[childname]
  *         child, new_offset = fields
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":874
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":907
  *             # so don't output it
  *             f = _util_dtypestring(child, f, end, offset)
  *     return f             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_f;
   goto __pyx_L0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":809
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":842
  *         return ()
  * 
  * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
  *     # Recursive utility function used in __getbuffer__ to get format
  *     # string. The new location in the format string is returned.
  */
 
@@ -5135,185 +5149,138 @@
   __Pyx_XDECREF(__pyx_v_childname);
   __Pyx_XDECREF(__pyx_v_new_offset);
   __Pyx_XDECREF(__pyx_v_t);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":990
- * 
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1022
+ *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
- *      cdef PyObject* baseptr
- *      if base is None:
+ *     Py_INCREF(base) # important to do this before stealing the reference below!
+ *     PyArray_SetBaseObject(arr, base)
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
-  PyObject *__pyx_v_baseptr;
   __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  int __pyx_t_2;
   __Pyx_RefNannySetupContext("set_array_base", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":992
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1023
+ * 
  * cdef inline void set_array_base(ndarray arr, object base):
- *      cdef PyObject* baseptr
- *      if base is None:             # <<<<<<<<<<<<<<
- *          baseptr = NULL
- *      else:
- */
-  __pyx_t_1 = (__pyx_v_base == Py_None);
-  __pyx_t_2 = (__pyx_t_1 != 0);
-  if (__pyx_t_2) {
-
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":993
- *      cdef PyObject* baseptr
- *      if base is None:
- *          baseptr = NULL             # <<<<<<<<<<<<<<
- *      else:
- *          Py_INCREF(base) # important to do this before decref below!
+ *     Py_INCREF(base) # important to do this before stealing the reference below!             # <<<<<<<<<<<<<<
+ *     PyArray_SetBaseObject(arr, base)
+ * 
  */
-    __pyx_v_baseptr = NULL;
+  Py_INCREF(__pyx_v_base);
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":992
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1024
  * cdef inline void set_array_base(ndarray arr, object base):
- *      cdef PyObject* baseptr
- *      if base is None:             # <<<<<<<<<<<<<<
- *          baseptr = NULL
- *      else:
- */
-    goto __pyx_L3;
-  }
-
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":995
- *          baseptr = NULL
- *      else:
- *          Py_INCREF(base) # important to do this before decref below!             # <<<<<<<<<<<<<<
- *          baseptr = <PyObject*>base
- *      Py_XDECREF(arr.base)
- */
-  /*else*/ {
-    Py_INCREF(__pyx_v_base);
-
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":996
- *      else:
- *          Py_INCREF(base) # important to do this before decref below!
- *          baseptr = <PyObject*>base             # <<<<<<<<<<<<<<
- *      Py_XDECREF(arr.base)
- *      arr.base = baseptr
- */
-    __pyx_v_baseptr = ((PyObject *)__pyx_v_base);
-  }
-  __pyx_L3:;
-
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":997
- *          Py_INCREF(base) # important to do this before decref below!
- *          baseptr = <PyObject*>base
- *      Py_XDECREF(arr.base)             # <<<<<<<<<<<<<<
- *      arr.base = baseptr
- * 
- */
-  Py_XDECREF(__pyx_v_arr->base);
-
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":998
- *          baseptr = <PyObject*>base
- *      Py_XDECREF(arr.base)
- *      arr.base = baseptr             # <<<<<<<<<<<<<<
+ *     Py_INCREF(base) # important to do this before stealing the reference below!
+ *     PyArray_SetBaseObject(arr, base)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object get_array_base(ndarray arr):
  */
-  __pyx_v_arr->base = __pyx_v_baseptr;
+  (void)(PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base));
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":990
- * 
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1022
+ *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
- *      cdef PyObject* baseptr
- *      if base is None:
+ *     Py_INCREF(base) # important to do this before stealing the reference below!
+ *     PyArray_SetBaseObject(arr, base)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1000
- *      arr.base = baseptr
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1026
+ *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
- *     if arr.base is NULL:
- *         return None
+ *     base = PyArray_BASE(arr)
+ *     if base is NULL:
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
+  PyObject *__pyx_v_base;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("get_array_base", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1001
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1027
  * 
  * cdef inline object get_array_base(ndarray arr):
- *     if arr.base is NULL:             # <<<<<<<<<<<<<<
+ *     base = PyArray_BASE(arr)             # <<<<<<<<<<<<<<
+ *     if base is NULL:
  *         return None
- *     else:
  */
-  __pyx_t_1 = ((__pyx_v_arr->base == NULL) != 0);
-  if (__pyx_t_1) {
+  __pyx_v_base = PyArray_BASE(__pyx_v_arr);
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1002
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1028
  * cdef inline object get_array_base(ndarray arr):
- *     if arr.base is NULL:
+ *     base = PyArray_BASE(arr)
+ *     if base is NULL:             # <<<<<<<<<<<<<<
+ *         return None
+ *     return <object>base
+ */
+  __pyx_t_1 = ((__pyx_v_base == NULL) != 0);
+  if (__pyx_t_1) {
+
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1029
+ *     base = PyArray_BASE(arr)
+ *     if base is NULL:
  *         return None             # <<<<<<<<<<<<<<
- *     else:
- *         return <object>arr.base
+ *     return <object>base
+ * 
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF(Py_None);
-    __pyx_r = Py_None;
+    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1001
- * 
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1028
  * cdef inline object get_array_base(ndarray arr):
- *     if arr.base is NULL:             # <<<<<<<<<<<<<<
+ *     base = PyArray_BASE(arr)
+ *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
- *     else:
+ *     return <object>base
  */
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1004
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1030
+ *     if base is NULL:
  *         return None
- *     else:
- *         return <object>arr.base             # <<<<<<<<<<<<<<
- * 
+ *     return <object>base             # <<<<<<<<<<<<<<
  * 
+ * # Versions of the import_* functions which are more suitable for
  */
-  /*else*/ {
-    __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF(((PyObject *)__pyx_v_arr->base));
-    __pyx_r = ((PyObject *)__pyx_v_arr->base);
-    goto __pyx_L0;
-  }
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_base));
+  __pyx_r = ((PyObject *)__pyx_v_base);
+  goto __pyx_L0;
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1000
- *      arr.base = baseptr
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1026
+ *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
- *     if arr.base is NULL:
- *         return None
+ *     base = PyArray_BASE(arr)
+ *     if base is NULL:
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1009
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1034
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_array()
  */
 
@@ -5326,15 +5293,15 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   __Pyx_RefNannySetupContext("import_array", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1010
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1035
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_array()
  *     except Exception:
  */
   {
@@ -5342,84 +5309,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1011
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1036
  * cdef inline int import_array() except -1:
  *     try:
  *         _import_array()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")
  */
-      __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1011, __pyx_L3_error)
+      __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1036, __pyx_L3_error)
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1010
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1035
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_array()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1012
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1037
  *     try:
  *         _import_array()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1012, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1037, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1013
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1038
  *         _import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1013, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1038, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(1, 1013, __pyx_L5_except_error)
+      __PYX_ERR(1, 1038, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1010
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1035
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_array()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1009
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1034
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_array()
  */
 
@@ -5434,15 +5401,15 @@
   __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1015
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1040
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -5455,15 +5422,15 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   __Pyx_RefNannySetupContext("import_umath", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1016
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1041
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -5471,84 +5438,84 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1017
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1042
  * cdef inline int import_umath() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
-      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1017, __pyx_L3_error)
+      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1042, __pyx_L3_error)
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1016
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1041
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1018
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1043
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1018, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1043, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1019
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1044
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1019, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1044, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(1, 1019, __pyx_L5_except_error)
+      __PYX_ERR(1, 1044, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1016
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1041
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1015
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1040
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -5563,15 +5530,15 @@
   __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1021
+/* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1046
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -5584,15 +5551,15 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   __Pyx_RefNannySetupContext("import_ufunc", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1022
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1047
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -5600,81 +5567,81 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1023
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1048
  * cdef inline int import_ufunc() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
-      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1023, __pyx_L3_error)
+      __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 1048, __pyx_L3_error)
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1022
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1047
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1024
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1049
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1024, __pyx_L5_except_error)
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 1049, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1025
+      /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1050
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  */
-      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1025, __pyx_L5_except_error)
+      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 1050, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __PYX_ERR(1, 1025, __pyx_L5_except_error)
+      __PYX_ERR(1, 1050, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1022
+    /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1047
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1021
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1046
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -5689,15 +5656,15 @@
   __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":120
+/* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -5732,43 +5699,43 @@
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_shape)) != 0)) kw_args--;
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_shape)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_itemsize)) != 0)) kw_args--;
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_itemsize)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(2, 120, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 1); __PYX_ERR(2, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_format)) != 0)) kw_args--;
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_format)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(2, 120, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, 2); __PYX_ERR(2, 122, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mode);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
           if (value) { values[3] = value; kw_args--; }
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_allocate_buffer);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allocate_buffer);
           if (value) { values[4] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(2, 120, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(2, 122, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
         case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
         CYTHON_FALLTHROUGH;
@@ -5776,46 +5743,46 @@
         values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_shape = ((PyObject*)values[0]);
-    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 120, __pyx_L3_error)
+    __pyx_v_itemsize = __Pyx_PyIndex_AsSsize_t(values[1]); if (unlikely((__pyx_v_itemsize == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 122, __pyx_L3_error)
     __pyx_v_format = values[2];
     __pyx_v_mode = values[3];
     if (values[4]) {
-      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 121, __pyx_L3_error)
+      __pyx_v_allocate_buffer = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_allocate_buffer == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 123, __pyx_L3_error)
     } else {
 
-      /* "View.MemoryView":121
+      /* "View.MemoryView":123
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,
  *                   mode="c", bint allocate_buffer=True):             # <<<<<<<<<<<<<<
  * 
  *         cdef int idx
  */
       __pyx_v_allocate_buffer = ((int)1);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(2, 120, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(2, 122, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(2, 120, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_shape), (&PyTuple_Type), 1, "shape", 1))) __PYX_ERR(2, 122, __pyx_L1_error)
   if (unlikely(((PyObject *)__pyx_v_format) == Py_None)) {
-    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(2, 120, __pyx_L1_error)
+    PyErr_Format(PyExc_TypeError, "Argument '%.200s' must not be None", "format"); __PYX_ERR(2, 122, __pyx_L1_error)
   }
   __pyx_r = __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(((struct __pyx_array_obj *)__pyx_v_self), __pyx_v_shape, __pyx_v_itemsize, __pyx_v_format, __pyx_v_mode, __pyx_v_allocate_buffer);
 
-  /* "View.MemoryView":120
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
@@ -5837,608 +5804,612 @@
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
-  char *__pyx_t_6;
-  int __pyx_t_7;
-  Py_ssize_t __pyx_t_8;
-  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  char *__pyx_t_7;
+  int __pyx_t_8;
+  Py_ssize_t __pyx_t_9;
   PyObject *__pyx_t_10 = NULL;
+  Py_ssize_t __pyx_t_11;
   __Pyx_RefNannySetupContext("__cinit__", 0);
   __Pyx_INCREF(__pyx_v_format);
 
-  /* "View.MemoryView":127
+  /* "View.MemoryView":129
  *         cdef PyObject **p
  * 
  *         self.ndim = <int> len(shape)             # <<<<<<<<<<<<<<
  *         self.itemsize = itemsize
  * 
  */
   if (unlikely(__pyx_v_shape == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-    __PYX_ERR(2, 127, __pyx_L1_error)
+    __PYX_ERR(2, 129, __pyx_L1_error)
   }
-  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(2, 127, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_shape); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(2, 129, __pyx_L1_error)
   __pyx_v_self->ndim = ((int)__pyx_t_1);
 
-  /* "View.MemoryView":128
+  /* "View.MemoryView":130
  * 
  *         self.ndim = <int> len(shape)
  *         self.itemsize = itemsize             # <<<<<<<<<<<<<<
  * 
  *         if not self.ndim:
  */
   __pyx_v_self->itemsize = __pyx_v_itemsize;
 
-  /* "View.MemoryView":130
+  /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_self->ndim != 0)) != 0);
-  if (__pyx_t_2) {
+  if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":131
+    /* "View.MemoryView":133
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 131, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 133, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(2, 131, __pyx_L1_error)
+    __PYX_ERR(2, 133, __pyx_L1_error)
 
-    /* "View.MemoryView":130
+    /* "View.MemoryView":132
  *         self.itemsize = itemsize
  * 
  *         if not self.ndim:             # <<<<<<<<<<<<<<
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":133
+  /* "View.MemoryView":135
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
   __pyx_t_2 = ((__pyx_v_itemsize <= 0) != 0);
-  if (__pyx_t_2) {
+  if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":134
+    /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 134, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 136, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(2, 134, __pyx_L1_error)
+    __PYX_ERR(2, 136, __pyx_L1_error)
 
-    /* "View.MemoryView":133
+    /* "View.MemoryView":135
  *             raise ValueError("Empty shape tuple for cython.array")
  * 
  *         if itemsize <= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  */
   }
 
-  /* "View.MemoryView":136
+  /* "View.MemoryView":138
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   __pyx_t_2 = PyBytes_Check(__pyx_v_format); 
   __pyx_t_4 = ((!(__pyx_t_2 != 0)) != 0);
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":137
+    /* "View.MemoryView":139
  * 
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')             # <<<<<<<<<<<<<<
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format
  */
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 137, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 137, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_format, __pyx_n_s_encode); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 139, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_5);
-    __pyx_t_5 = 0;
+    __pyx_t_6 = NULL;
+    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
+      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
+      if (likely(__pyx_t_6)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+        __Pyx_INCREF(__pyx_t_6);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_5, function);
+      }
+    }
+    __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_n_s_ASCII) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_n_s_ASCII);
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 139, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF_SET(__pyx_v_format, __pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "View.MemoryView":136
+    /* "View.MemoryView":138
  *             raise ValueError("itemsize <= 0 for cython.array")
  * 
  *         if not isinstance(format, bytes):             # <<<<<<<<<<<<<<
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  */
   }
 
-  /* "View.MemoryView":138
+  /* "View.MemoryView":140
  *         if not isinstance(format, bytes):
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string             # <<<<<<<<<<<<<<
  *         self.format = self._format
  * 
  */
-  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(2, 138, __pyx_L1_error)
-  __pyx_t_5 = __pyx_v_format;
-  __Pyx_INCREF(__pyx_t_5);
-  __Pyx_GIVEREF(__pyx_t_5);
+  if (!(likely(PyBytes_CheckExact(__pyx_v_format))||((__pyx_v_format) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_format)->tp_name), 0))) __PYX_ERR(2, 140, __pyx_L1_error)
+  __pyx_t_3 = __pyx_v_format;
+  __Pyx_INCREF(__pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
   __Pyx_GOTREF(__pyx_v_self->_format);
   __Pyx_DECREF(__pyx_v_self->_format);
-  __pyx_v_self->_format = ((PyObject*)__pyx_t_5);
-  __pyx_t_5 = 0;
+  __pyx_v_self->_format = ((PyObject*)__pyx_t_3);
+  __pyx_t_3 = 0;
 
-  /* "View.MemoryView":139
+  /* "View.MemoryView":141
  *             format = format.encode('ASCII')
  *         self._format = format  # keep a reference to the byte string
  *         self.format = self._format             # <<<<<<<<<<<<<<
  * 
  * 
  */
   if (unlikely(__pyx_v_self->_format == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
-    __PYX_ERR(2, 139, __pyx_L1_error)
+    __PYX_ERR(2, 141, __pyx_L1_error)
   }
-  __pyx_t_6 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(2, 139, __pyx_L1_error)
-  __pyx_v_self->format = __pyx_t_6;
+  __pyx_t_7 = __Pyx_PyBytes_AsWritableString(__pyx_v_self->_format); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(2, 141, __pyx_L1_error)
+  __pyx_v_self->format = __pyx_t_7;
 
-  /* "View.MemoryView":142
+  /* "View.MemoryView":144
  * 
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)             # <<<<<<<<<<<<<<
  *         self._strides = self._shape + self.ndim
  * 
  */
   __pyx_v_self->_shape = ((Py_ssize_t *)PyObject_Malloc((((sizeof(Py_ssize_t)) * __pyx_v_self->ndim) * 2)));
 
-  /* "View.MemoryView":143
+  /* "View.MemoryView":145
  * 
  *         self._shape = <Py_ssize_t *> PyObject_Malloc(sizeof(Py_ssize_t)*self.ndim*2)
  *         self._strides = self._shape + self.ndim             # <<<<<<<<<<<<<<
  * 
  *         if not self._shape:
  */
   __pyx_v_self->_strides = (__pyx_v_self->_shape + __pyx_v_self->ndim);
 
-  /* "View.MemoryView":145
+  /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
   __pyx_t_4 = ((!(__pyx_v_self->_shape != 0)) != 0);
-  if (__pyx_t_4) {
+  if (unlikely(__pyx_t_4)) {
 
-    /* "View.MemoryView":146
+    /* "View.MemoryView":148
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 146, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __PYX_ERR(2, 146, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 148, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(2, 148, __pyx_L1_error)
 
-    /* "View.MemoryView":145
+    /* "View.MemoryView":147
  *         self._strides = self._shape + self.ndim
  * 
  *         if not self._shape:             # <<<<<<<<<<<<<<
  *             raise MemoryError("unable to allocate shape and strides.")
  * 
  */
   }
 
-  /* "View.MemoryView":149
+  /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
-  __pyx_t_7 = 0;
-  __pyx_t_5 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_5); __pyx_t_1 = 0;
+  __pyx_t_8 = 0;
+  __pyx_t_3 = __pyx_v_shape; __Pyx_INCREF(__pyx_t_3); __pyx_t_1 = 0;
   for (;;) {
-    if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_5)) break;
+    if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_1); __Pyx_INCREF(__pyx_t_3); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(2, 149, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_5); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(2, 151, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_5, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 149, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 151, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
     #endif
-    __pyx_t_8 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_8 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 149, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_v_dim = __pyx_t_8;
-    __pyx_v_idx = __pyx_t_7;
-    __pyx_t_7 = (__pyx_t_7 + 1);
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_5); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 151, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_v_dim = __pyx_t_9;
+    __pyx_v_idx = __pyx_t_8;
+    __pyx_t_8 = (__pyx_t_8 + 1);
 
-    /* "View.MemoryView":150
+    /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     __pyx_t_4 = ((__pyx_v_dim <= 0) != 0);
-    if (__pyx_t_4) {
+    if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":151
+      /* "View.MemoryView":153
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))             # <<<<<<<<<<<<<<
  *             self._shape[idx] = dim
  * 
  */
-      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 151, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_9 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 151, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 151, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 153, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 153, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
+      __pyx_t_10 = PyTuple_New(2); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
-      __Pyx_GIVEREF(__pyx_t_3);
-      PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_3);
-      __Pyx_GIVEREF(__pyx_t_9);
-      PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_9);
-      __pyx_t_3 = 0;
-      __pyx_t_9 = 0;
-      __pyx_t_9 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 151, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_GIVEREF(__pyx_t_5);
+      PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5);
+      __Pyx_GIVEREF(__pyx_t_6);
+      PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_6);
+      __pyx_t_5 = 0;
+      __pyx_t_6 = 0;
+      __pyx_t_6 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 153, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __pyx_t_10 = PyTuple_New(1); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 151, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 153, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_10);
-      __Pyx_GIVEREF(__pyx_t_9);
-      PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_9);
-      __pyx_t_9 = 0;
-      __pyx_t_9 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_10, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 151, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+      __Pyx_Raise(__pyx_t_10, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      __Pyx_Raise(__pyx_t_9, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-      __PYX_ERR(2, 151, __pyx_L1_error)
+      __PYX_ERR(2, 153, __pyx_L1_error)
 
-      /* "View.MemoryView":150
+      /* "View.MemoryView":152
  * 
  *         for idx, dim in enumerate(shape):
  *             if dim <= 0:             # <<<<<<<<<<<<<<
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim
  */
     }
 
-    /* "View.MemoryView":152
+    /* "View.MemoryView":154
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  *             self._shape[idx] = dim             # <<<<<<<<<<<<<<
  * 
  *         cdef char order
  */
     (__pyx_v_self->_shape[__pyx_v_idx]) = __pyx_v_dim;
 
-    /* "View.MemoryView":149
+    /* "View.MemoryView":151
  * 
  * 
  *         for idx, dim in enumerate(shape):             # <<<<<<<<<<<<<<
  *             if dim <= 0:
  *                 raise ValueError("Invalid shape in axis %d: %d." % (idx, dim))
  */
   }
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":155
+  /* "View.MemoryView":157
  * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
-  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(2, 155, __pyx_L1_error)
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_fortran, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(2, 157, __pyx_L1_error)
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":156
+    /* "View.MemoryView":158
  *         cdef char order
  *         if mode == 'fortran':
  *             order = b'F'             # <<<<<<<<<<<<<<
  *             self.mode = u'fortran'
  *         elif mode == 'c':
  */
     __pyx_v_order = 'F';
 
-    /* "View.MemoryView":157
+    /* "View.MemoryView":159
  *         if mode == 'fortran':
  *             order = b'F'
  *             self.mode = u'fortran'             # <<<<<<<<<<<<<<
  *         elif mode == 'c':
  *             order = b'C'
  */
     __Pyx_INCREF(__pyx_n_u_fortran);
     __Pyx_GIVEREF(__pyx_n_u_fortran);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
     __pyx_v_self->mode = __pyx_n_u_fortran;
 
-    /* "View.MemoryView":155
+    /* "View.MemoryView":157
  * 
  *         cdef char order
  *         if mode == 'fortran':             # <<<<<<<<<<<<<<
  *             order = b'F'
  *             self.mode = u'fortran'
  */
     goto __pyx_L10;
   }
 
-  /* "View.MemoryView":158
+  /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
  *         elif mode == 'c':             # <<<<<<<<<<<<<<
  *             order = b'C'
  *             self.mode = u'c'
  */
-  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(2, 158, __pyx_L1_error)
-  if (__pyx_t_4) {
+  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_c, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(2, 160, __pyx_L1_error)
+  if (likely(__pyx_t_4)) {
 
-    /* "View.MemoryView":159
+    /* "View.MemoryView":161
  *             self.mode = u'fortran'
  *         elif mode == 'c':
  *             order = b'C'             # <<<<<<<<<<<<<<
  *             self.mode = u'c'
  *         else:
  */
     __pyx_v_order = 'C';
 
-    /* "View.MemoryView":160
+    /* "View.MemoryView":162
  *         elif mode == 'c':
  *             order = b'C'
  *             self.mode = u'c'             # <<<<<<<<<<<<<<
  *         else:
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  */
     __Pyx_INCREF(__pyx_n_u_c);
     __Pyx_GIVEREF(__pyx_n_u_c);
     __Pyx_GOTREF(__pyx_v_self->mode);
     __Pyx_DECREF(__pyx_v_self->mode);
     __pyx_v_self->mode = __pyx_n_u_c;
 
-    /* "View.MemoryView":158
+    /* "View.MemoryView":160
  *             order = b'F'
  *             self.mode = u'fortran'
  *         elif mode == 'c':             # <<<<<<<<<<<<<<
  *             order = b'C'
  *             self.mode = u'c'
  */
     goto __pyx_L10;
   }
 
-  /* "View.MemoryView":162
+  /* "View.MemoryView":164
  *             self.mode = u'c'
  *         else:
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)             # <<<<<<<<<<<<<<
  * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,
  */
   /*else*/ {
-    __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_9 = PyTuple_New(1); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_9);
-    __Pyx_GIVEREF(__pyx_t_5);
-    PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_5);
-    __pyx_t_5 = 0;
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_9, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 162, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __PYX_ERR(2, 162, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 164, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 164, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_10);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_10, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+    __PYX_ERR(2, 164, __pyx_L1_error)
   }
   __pyx_L10:;
 
-  /* "View.MemoryView":164
+  /* "View.MemoryView":166
  *             raise ValueError("Invalid mode, expected 'c' or 'fortran', got %s" % mode)
  * 
  *         self.len = fill_contig_strides_array(self._shape, self._strides,             # <<<<<<<<<<<<<<
  *                                              itemsize, self.ndim, order)
  * 
  */
   __pyx_v_self->len = __pyx_fill_contig_strides_array(__pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_itemsize, __pyx_v_self->ndim, __pyx_v_order);
 
-  /* "View.MemoryView":167
+  /* "View.MemoryView":169
  *                                              itemsize, self.ndim, order)
  * 
  *         self.free_data = allocate_buffer             # <<<<<<<<<<<<<<
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:
  */
   __pyx_v_self->free_data = __pyx_v_allocate_buffer;
 
-  /* "View.MemoryView":168
+  /* "View.MemoryView":170
  * 
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'             # <<<<<<<<<<<<<<
  *         if allocate_buffer:
  * 
  */
-  __pyx_t_5 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 168, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 168, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_10 = PyObject_RichCompare(__pyx_v_format, __pyx_n_b_O, Py_EQ); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 170, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 170, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
   __pyx_v_self->dtype_is_object = __pyx_t_4;
 
-  /* "View.MemoryView":169
+  /* "View.MemoryView":171
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_4 = (__pyx_v_allocate_buffer != 0);
   if (__pyx_t_4) {
 
-    /* "View.MemoryView":172
+    /* "View.MemoryView":174
  * 
  * 
  *             self.data = <char *>malloc(self.len)             # <<<<<<<<<<<<<<
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")
  */
     __pyx_v_self->data = ((char *)malloc(__pyx_v_self->len));
 
-    /* "View.MemoryView":173
+    /* "View.MemoryView":175
  * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
  * 
  */
     __pyx_t_4 = ((!(__pyx_v_self->data != 0)) != 0);
-    if (__pyx_t_4) {
+    if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":174
+      /* "View.MemoryView":176
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 174, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(2, 174, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_MemoryError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(2, 176, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_10);
+      __Pyx_Raise(__pyx_t_10, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+      __PYX_ERR(2, 176, __pyx_L1_error)
 
-      /* "View.MemoryView":173
+      /* "View.MemoryView":175
  * 
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:             # <<<<<<<<<<<<<<
  *                 raise MemoryError("unable to allocate array data.")
  * 
  */
     }
 
-    /* "View.MemoryView":176
+    /* "View.MemoryView":178
  *                 raise MemoryError("unable to allocate array data.")
  * 
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  */
     __pyx_t_4 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_4) {
 
-      /* "View.MemoryView":177
+      /* "View.MemoryView":179
  * 
  *             if self.dtype_is_object:
  *                 p = <PyObject **> self.data             # <<<<<<<<<<<<<<
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None
  */
       __pyx_v_p = ((PyObject **)__pyx_v_self->data);
 
-      /* "View.MemoryView":178
+      /* "View.MemoryView":180
  *             if self.dtype_is_object:
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):             # <<<<<<<<<<<<<<
  *                     p[i] = Py_None
  *                     Py_INCREF(Py_None)
  */
       if (unlikely(__pyx_v_itemsize == 0)) {
         PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-        __PYX_ERR(2, 178, __pyx_L1_error)
+        __PYX_ERR(2, 180, __pyx_L1_error)
       }
       else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_self->len))) {
         PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-        __PYX_ERR(2, 178, __pyx_L1_error)
+        __PYX_ERR(2, 180, __pyx_L1_error)
       }
       __pyx_t_1 = __Pyx_div_Py_ssize_t(__pyx_v_self->len, __pyx_v_itemsize);
-      for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_1; __pyx_t_8+=1) {
-        __pyx_v_i = __pyx_t_8;
+      __pyx_t_9 = __pyx_t_1;
+      for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_9; __pyx_t_11+=1) {
+        __pyx_v_i = __pyx_t_11;
 
-        /* "View.MemoryView":179
+        /* "View.MemoryView":181
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None             # <<<<<<<<<<<<<<
  *                     Py_INCREF(Py_None)
  * 
  */
         (__pyx_v_p[__pyx_v_i]) = Py_None;
 
-        /* "View.MemoryView":180
+        /* "View.MemoryView":182
  *                 for i in range(self.len / itemsize):
  *                     p[i] = Py_None
  *                     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
         Py_INCREF(Py_None);
       }
 
-      /* "View.MemoryView":176
+      /* "View.MemoryView":178
  *                 raise MemoryError("unable to allocate array data.")
  * 
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 p = <PyObject **> self.data
  *                 for i in range(self.len / itemsize):
  */
     }
 
-    /* "View.MemoryView":169
+    /* "View.MemoryView":171
  *         self.free_data = allocate_buffer
  *         self.dtype_is_object = format == b'O'
  *         if allocate_buffer:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":120
+  /* "View.MemoryView":122
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_9);
+  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_10);
   __Pyx_AddTraceback("View.MemoryView.array.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_format);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":183
+/* "View.MemoryView":185
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  */
 
@@ -6462,285 +6433,287 @@
   int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   char *__pyx_t_4;
   Py_ssize_t __pyx_t_5;
   int __pyx_t_6;
   Py_ssize_t *__pyx_t_7;
-  __Pyx_RefNannySetupContext("__getbuffer__", 0);
-  if (__pyx_v_info != NULL) {
-    __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
-    __Pyx_GIVEREF(__pyx_v_info->obj);
+  if (__pyx_v_info == NULL) {
+    PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
+    return -1;
   }
+  __Pyx_RefNannySetupContext("__getbuffer__", 0);
+  __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(__pyx_v_info->obj);
 
-  /* "View.MemoryView":184
+  /* "View.MemoryView":186
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1             # <<<<<<<<<<<<<<
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
   __pyx_v_bufmode = -1;
 
-  /* "View.MemoryView":185
+  /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
  *         if self.mode == u"c":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  */
-  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 185, __pyx_L1_error)
+  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 187, __pyx_L1_error)
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":186
+    /* "View.MemoryView":188
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  */
     __pyx_v_bufmode = (PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
 
-    /* "View.MemoryView":185
+    /* "View.MemoryView":187
  *     def __getbuffer__(self, Py_buffer *info, int flags):
  *         cdef int bufmode = -1
  *         if self.mode == u"c":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":187
+  /* "View.MemoryView":189
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  */
-  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(2, 187, __pyx_L1_error)
+  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_self->mode, __pyx_n_u_fortran, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(2, 189, __pyx_L1_error)
   __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":188
+    /* "View.MemoryView":190
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS             # <<<<<<<<<<<<<<
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  */
     __pyx_v_bufmode = (PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS);
 
-    /* "View.MemoryView":187
+    /* "View.MemoryView":189
  *         if self.mode == u"c":
  *             bufmode = PyBUF_C_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         elif self.mode == u"fortran":             # <<<<<<<<<<<<<<
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":189
+  /* "View.MemoryView":191
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
   __pyx_t_1 = ((!((__pyx_v_flags & __pyx_v_bufmode) != 0)) != 0);
-  if (__pyx_t_1) {
+  if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":190
+    /* "View.MemoryView":192
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 190, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 192, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(2, 190, __pyx_L1_error)
+    __PYX_ERR(2, 192, __pyx_L1_error)
 
-    /* "View.MemoryView":189
+    /* "View.MemoryView":191
  *         elif self.mode == u"fortran":
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):             # <<<<<<<<<<<<<<
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  */
   }
 
-  /* "View.MemoryView":191
+  /* "View.MemoryView":193
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data             # <<<<<<<<<<<<<<
  *         info.len = self.len
  *         info.ndim = self.ndim
  */
   __pyx_t_4 = __pyx_v_self->data;
   __pyx_v_info->buf = __pyx_t_4;
 
-  /* "View.MemoryView":192
+  /* "View.MemoryView":194
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")
  *         info.buf = self.data
  *         info.len = self.len             # <<<<<<<<<<<<<<
  *         info.ndim = self.ndim
  *         info.shape = self._shape
  */
   __pyx_t_5 = __pyx_v_self->len;
   __pyx_v_info->len = __pyx_t_5;
 
-  /* "View.MemoryView":193
+  /* "View.MemoryView":195
  *         info.buf = self.data
  *         info.len = self.len
  *         info.ndim = self.ndim             # <<<<<<<<<<<<<<
  *         info.shape = self._shape
  *         info.strides = self._strides
  */
   __pyx_t_6 = __pyx_v_self->ndim;
   __pyx_v_info->ndim = __pyx_t_6;
 
-  /* "View.MemoryView":194
+  /* "View.MemoryView":196
  *         info.len = self.len
  *         info.ndim = self.ndim
  *         info.shape = self._shape             # <<<<<<<<<<<<<<
  *         info.strides = self._strides
  *         info.suboffsets = NULL
  */
   __pyx_t_7 = __pyx_v_self->_shape;
   __pyx_v_info->shape = __pyx_t_7;
 
-  /* "View.MemoryView":195
+  /* "View.MemoryView":197
  *         info.ndim = self.ndim
  *         info.shape = self._shape
  *         info.strides = self._strides             # <<<<<<<<<<<<<<
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  */
   __pyx_t_7 = __pyx_v_self->_strides;
   __pyx_v_info->strides = __pyx_t_7;
 
-  /* "View.MemoryView":196
+  /* "View.MemoryView":198
  *         info.shape = self._shape
  *         info.strides = self._strides
  *         info.suboffsets = NULL             # <<<<<<<<<<<<<<
  *         info.itemsize = self.itemsize
  *         info.readonly = 0
  */
   __pyx_v_info->suboffsets = NULL;
 
-  /* "View.MemoryView":197
+  /* "View.MemoryView":199
  *         info.strides = self._strides
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize             # <<<<<<<<<<<<<<
  *         info.readonly = 0
  * 
  */
   __pyx_t_5 = __pyx_v_self->itemsize;
   __pyx_v_info->itemsize = __pyx_t_5;
 
-  /* "View.MemoryView":198
+  /* "View.MemoryView":200
  *         info.suboffsets = NULL
  *         info.itemsize = self.itemsize
  *         info.readonly = 0             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
   __pyx_v_info->readonly = 0;
 
-  /* "View.MemoryView":200
+  /* "View.MemoryView":202
  *         info.readonly = 0
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":201
+    /* "View.MemoryView":203
  * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
     __pyx_t_4 = __pyx_v_self->format;
     __pyx_v_info->format = __pyx_t_4;
 
-    /* "View.MemoryView":200
+    /* "View.MemoryView":202
  *         info.readonly = 0
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.format
  *         else:
  */
     goto __pyx_L5;
   }
 
-  /* "View.MemoryView":203
+  /* "View.MemoryView":205
  *             info.format = self.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
  * 
  *         info.obj = self
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
   __pyx_L5:;
 
-  /* "View.MemoryView":205
+  /* "View.MemoryView":207
  *             info.format = NULL
  * 
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":183
+  /* "View.MemoryView":185
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
  *         cdef int bufmode = -1
  *         if self.mode == u"c":
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_AddTraceback("View.MemoryView.array.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
-  if (__pyx_v_info != NULL && __pyx_v_info->obj != NULL) {
+  if (__pyx_v_info->obj != NULL) {
     __Pyx_GOTREF(__pyx_v_info->obj);
-    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;
+    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   goto __pyx_L2;
   __pyx_L0:;
-  if (__pyx_v_info != NULL && __pyx_v_info->obj == Py_None) {
-    __Pyx_GOTREF(Py_None);
-    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
+  if (__pyx_v_info->obj == Py_None) {
+    __Pyx_GOTREF(__pyx_v_info->obj);
+    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
   __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":209
+/* "View.MemoryView":211
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
@@ -6756,122 +6729,122 @@
 }
 
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":210
+  /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  */
   __pyx_t_1 = ((__pyx_v_self->callback_free_data != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":211
+    /* "View.MemoryView":213
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)             # <<<<<<<<<<<<<<
  *         elif self.free_data:
  *             if self.dtype_is_object:
  */
     __pyx_v_self->callback_free_data(__pyx_v_self->data);
 
-    /* "View.MemoryView":210
+    /* "View.MemoryView":212
  * 
  *     def __dealloc__(array self):
  *         if self.callback_free_data != NULL:             # <<<<<<<<<<<<<<
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":212
+  /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,
  */
   __pyx_t_1 = (__pyx_v_self->free_data != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":213
+    /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  */
     __pyx_t_1 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":214
+      /* "View.MemoryView":216
  *         elif self.free_data:
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,             # <<<<<<<<<<<<<<
  *                                           self._strides, self.ndim, False)
  *             free(self.data)
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_self->data, __pyx_v_self->_shape, __pyx_v_self->_strides, __pyx_v_self->ndim, 0);
 
-      /* "View.MemoryView":213
+      /* "View.MemoryView":215
  *             self.callback_free_data(self.data)
  *         elif self.free_data:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  */
     }
 
-    /* "View.MemoryView":216
+    /* "View.MemoryView":218
  *                 refcount_objects_in_slice(self.data, self._shape,
  *                                           self._strides, self.ndim, False)
  *             free(self.data)             # <<<<<<<<<<<<<<
  *         PyObject_Free(self._shape)
  * 
  */
     free(__pyx_v_self->data);
 
-    /* "View.MemoryView":212
+    /* "View.MemoryView":214
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  *         elif self.free_data:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 refcount_objects_in_slice(self.data, self._shape,
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":217
+  /* "View.MemoryView":219
  *                                           self._strides, self.ndim, False)
  *             free(self.data)
  *         PyObject_Free(self._shape)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   PyObject_Free(__pyx_v_self->_shape);
 
-  /* "View.MemoryView":209
+  /* "View.MemoryView":211
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")
  * 
  *     def __dealloc__(array self):             # <<<<<<<<<<<<<<
  *         if self.callback_free_data != NULL:
  *             self.callback_free_data(self.data)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":220
+/* "View.MemoryView":222
  * 
  *     @property
  *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
  * 
  */
 
@@ -6890,29 +6863,29 @@
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":221
+  /* "View.MemoryView":223
  *     @property
  *     def memview(self):
  *         return self.get_memview()             # <<<<<<<<<<<<<<
  * 
  *     @cname('get_memview')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 221, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_array *)__pyx_v_self->__pyx_vtab)->get_memview(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 223, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":220
+  /* "View.MemoryView":222
  * 
  *     @property
  *     def memview(self):             # <<<<<<<<<<<<<<
  *         return self.get_memview()
  * 
  */
 
@@ -6923,15 +6896,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":224
+/* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -6940,54 +6913,54 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   __Pyx_RefNannySetupContext("get_memview", 0);
 
-  /* "View.MemoryView":225
+  /* "View.MemoryView":227
  *     @cname('get_memview')
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE             # <<<<<<<<<<<<<<
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  */
   __pyx_v_flags = ((PyBUF_ANY_CONTIGUOUS | PyBUF_FORMAT) | PyBUF_WRITABLE);
 
-  /* "View.MemoryView":226
+  /* "View.MemoryView":228
  *     cdef get_memview(self):
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 226, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 226, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 226, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 226, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 228, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":224
+  /* "View.MemoryView":226
  * 
  *     @cname('get_memview')
  *     cdef get_memview(self):             # <<<<<<<<<<<<<<
  *         flags =  PyBUF_ANY_CONTIGUOUS|PyBUF_FORMAT|PyBUF_WRITABLE
  *         return  memoryview(self, flags, self.dtype_is_object)
  */
 
@@ -7000,15 +6973,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":228
+/* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
@@ -7026,39 +6999,39 @@
 }
 
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":229
+  /* "View.MemoryView":231
  * 
  *     def __len__(self):
  *         return self._shape[0]             # <<<<<<<<<<<<<<
  * 
  *     def __getattr__(self, attr):
  */
   __pyx_r = (__pyx_v_self->_shape[0]);
   goto __pyx_L0;
 
-  /* "View.MemoryView":228
+  /* "View.MemoryView":230
  *         return  memoryview(self, flags, self.dtype_is_object)
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         return self._shape[0]
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":231
+/* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
@@ -7078,32 +7051,32 @@
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_attr) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   __Pyx_RefNannySetupContext("__getattr__", 0);
 
-  /* "View.MemoryView":232
+  /* "View.MemoryView":234
  * 
  *     def __getattr__(self, attr):
  *         return getattr(self.memview, attr)             # <<<<<<<<<<<<<<
  * 
  *     def __getitem__(self, item):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 232, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 232, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetAttr(__pyx_t_1, __pyx_v_attr); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 234, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":231
+  /* "View.MemoryView":233
  *         return self._shape[0]
  * 
  *     def __getattr__(self, attr):             # <<<<<<<<<<<<<<
  *         return getattr(self.memview, attr)
  * 
  */
 
@@ -7115,15 +7088,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":234
+/* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
@@ -7143,32 +7116,32 @@
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_10__getitem__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_item) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":235
+  /* "View.MemoryView":237
  * 
  *     def __getitem__(self, item):
  *         return self.memview[item]             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(self, item, value):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 235, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 235, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":234
+  /* "View.MemoryView":236
  *         return getattr(self.memview, attr)
  * 
  *     def __getitem__(self, item):             # <<<<<<<<<<<<<<
  *         return self.memview[item]
  * 
  */
 
@@ -7180,15 +7153,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":237
+/* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
@@ -7207,27 +7180,27 @@
 
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_12__setitem__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_item, PyObject *__pyx_v_value) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("__setitem__", 0);
 
-  /* "View.MemoryView":238
+  /* "View.MemoryView":240
  * 
  *     def __setitem__(self, item, value):
  *         self.memview[item] = value             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 238, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_memview); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 240, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(2, 238, __pyx_L1_error)
+  if (unlikely(PyObject_SetItem(__pyx_t_1, __pyx_v_item, __pyx_v_value) < 0)) __PYX_ERR(2, 240, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "View.MemoryView":237
+  /* "View.MemoryView":239
  *         return self.memview[item]
  * 
  *     def __setitem__(self, item, value):             # <<<<<<<<<<<<<<
  *         self.memview[item] = value
  * 
  */
 
@@ -7270,15 +7243,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(2, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -7323,15 +7296,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(2, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -7346,15 +7319,15 @@
   __Pyx_AddTraceback("View.MemoryView.array.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":242
+/* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
  * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
  *                           char *mode, char *buf):
  *     cdef array result
  */
 
@@ -7365,145 +7338,145 @@
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   __Pyx_RefNannySetupContext("array_cwrapper", 0);
 
-  /* "View.MemoryView":246
+  /* "View.MemoryView":248
  *     cdef array result
  * 
  *     if buf == NULL:             # <<<<<<<<<<<<<<
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_buf == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":247
+    /* "View.MemoryView":249
  * 
  *     if buf == NULL:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))             # <<<<<<<<<<<<<<
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  */
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 247, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 247, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 247, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 247, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_4);
     __pyx_t_2 = 0;
     __pyx_t_3 = 0;
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 247, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 249, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "View.MemoryView":246
+    /* "View.MemoryView":248
  *     cdef array result
  * 
  *     if buf == NULL:             # <<<<<<<<<<<<<<
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":249
+  /* "View.MemoryView":251
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
  *                        allocate_buffer=False)
  *         result.data = buf
  */
   /*else*/ {
-    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 249, __pyx_L1_error)
+    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_itemsize); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 249, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyBytes_FromString(__pyx_v_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 249, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_mode, 0, strlen(__pyx_v_mode), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 249, __pyx_L1_error)
+    __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_v_shape);
     __Pyx_GIVEREF(__pyx_v_shape);
     PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_shape);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_t_3);
     __pyx_t_4 = 0;
     __pyx_t_5 = 0;
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":250
+    /* "View.MemoryView":252
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)             # <<<<<<<<<<<<<<
  *         result.data = buf
  * 
  */
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 250, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 252, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(2, 250, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allocate_buffer, Py_False) < 0) __PYX_ERR(2, 252, __pyx_L1_error)
 
-    /* "View.MemoryView":249
+    /* "View.MemoryView":251
  *         result = array(shape, itemsize, format, mode.decode('ASCII'))
  *     else:
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),             # <<<<<<<<<<<<<<
  *                        allocate_buffer=False)
  *         result.data = buf
  */
-    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 249, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_array_type), __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 251, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result = ((struct __pyx_array_obj *)__pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "View.MemoryView":251
+    /* "View.MemoryView":253
  *         result = array(shape, itemsize, format, mode.decode('ASCII'),
  *                        allocate_buffer=False)
  *         result.data = buf             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
     __pyx_v_result->data = __pyx_v_buf;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":253
+  /* "View.MemoryView":255
  *         result.data = buf
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(((PyObject *)__pyx_r));
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":242
+  /* "View.MemoryView":244
  * 
  * @cname("__pyx_array_new")
  * cdef array array_cwrapper(tuple shape, Py_ssize_t itemsize, char *format,             # <<<<<<<<<<<<<<
  *                           char *mode, char *buf):
  *     cdef array result
  */
 
@@ -7518,15 +7491,15 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":279
+/* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
@@ -7548,30 +7521,30 @@
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(2, 279, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(2, 281, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_name = values[0];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(2, 279, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(2, 281, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.Enum.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), __pyx_v_name);
 
@@ -7581,42 +7554,42 @@
 }
 
 static int __pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum___init__(struct __pyx_MemviewEnum_obj *__pyx_v_self, PyObject *__pyx_v_name) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "View.MemoryView":280
+  /* "View.MemoryView":282
  *     cdef object name
  *     def __init__(self, name):
  *         self.name = name             # <<<<<<<<<<<<<<
  *     def __repr__(self):
  *         return self.name
  */
   __Pyx_INCREF(__pyx_v_name);
   __Pyx_GIVEREF(__pyx_v_name);
   __Pyx_GOTREF(__pyx_v_self->name);
   __Pyx_DECREF(__pyx_v_self->name);
   __pyx_v_self->name = __pyx_v_name;
 
-  /* "View.MemoryView":279
+  /* "View.MemoryView":281
  * cdef class Enum(object):
  *     cdef object name
  *     def __init__(self, name):             # <<<<<<<<<<<<<<
  *         self.name = name
  *     def __repr__(self):
  */
 
   /* function exit code */
   __pyx_r = 0;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":281
+/* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
@@ -7634,27 +7607,27 @@
 }
 
 static PyObject *__pyx_MemviewEnum___pyx_pf_15View_dot_MemoryView_4Enum_2__repr__(struct __pyx_MemviewEnum_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":282
+  /* "View.MemoryView":284
  *         self.name = name
  *     def __repr__(self):
  *         return self.name             # <<<<<<<<<<<<<<
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->name);
   __pyx_r = __pyx_v_self->name;
   goto __pyx_L0;
 
-  /* "View.MemoryView":281
+  /* "View.MemoryView":283
  *     def __init__(self, name):
  *         self.name = name
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return self.name
  * 
  */
 
@@ -7663,16 +7636,16 @@
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     cdef bint use_setstate
- *     state = (self.name,)
+ *     cdef tuple state
+ *     cdef object _dict
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
 static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -7681,208 +7654,208 @@
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf___pyx_MemviewEnum___reduce_cython__(struct __pyx_MemviewEnum_obj *__pyx_v_self) {
+  PyObject *__pyx_v_state = 0;
+  PyObject *__pyx_v__dict = 0;
   int __pyx_v_use_setstate;
-  PyObject *__pyx_v_state = NULL;
-  PyObject *__pyx_v__dict = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_t_3;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
 
-  /* "(tree fragment)":3
- * def __reduce_cython__(self):
+  /* "(tree fragment)":5
+ *     cdef object _dict
  *     cdef bint use_setstate
  *     state = (self.name,)             # <<<<<<<<<<<<<<
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  */
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 3, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_self->name);
   __Pyx_GIVEREF(__pyx_v_self->name);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_self->name);
   __pyx_v_state = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "(tree fragment)":4
+  /* "(tree fragment)":6
  *     cdef bint use_setstate
  *     state = (self.name,)
  *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<
  *     if _dict is not None:
  *         state += (_dict,)
  */
-  __pyx_t_1 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 6, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v__dict = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "(tree fragment)":5
+  /* "(tree fragment)":7
  *     state = (self.name,)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
   __pyx_t_2 = (__pyx_v__dict != Py_None);
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
-    /* "(tree fragment)":6
+    /* "(tree fragment)":8
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:
  *         state += (_dict,)             # <<<<<<<<<<<<<<
  *         use_setstate = True
  *     else:
  */
-    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 6, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 8, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(__pyx_v__dict);
     __Pyx_GIVEREF(__pyx_v__dict);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v__dict);
-    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 6, __pyx_L1_error)
+    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 8, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_4));
     __pyx_t_4 = 0;
 
-    /* "(tree fragment)":7
+    /* "(tree fragment)":9
  *     if _dict is not None:
  *         state += (_dict,)
  *         use_setstate = True             # <<<<<<<<<<<<<<
  *     else:
  *         use_setstate = self.name is not None
  */
     __pyx_v_use_setstate = 1;
 
-    /* "(tree fragment)":5
+    /* "(tree fragment)":7
  *     state = (self.name,)
  *     _dict = getattr(self, '__dict__', None)
  *     if _dict is not None:             # <<<<<<<<<<<<<<
  *         state += (_dict,)
  *         use_setstate = True
  */
     goto __pyx_L3;
   }
 
-  /* "(tree fragment)":9
+  /* "(tree fragment)":11
  *         use_setstate = True
  *     else:
  *         use_setstate = self.name is not None             # <<<<<<<<<<<<<<
  *     if use_setstate:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  */
   /*else*/ {
     __pyx_t_3 = (__pyx_v_self->name != Py_None);
     __pyx_v_use_setstate = __pyx_t_3;
   }
   __pyx_L3:;
 
-  /* "(tree fragment)":10
+  /* "(tree fragment)":12
  *     else:
  *         use_setstate = self.name is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
  */
   __pyx_t_3 = (__pyx_v_use_setstate != 0);
   if (__pyx_t_3) {
 
-    /* "(tree fragment)":11
+    /* "(tree fragment)":13
  *         use_setstate = self.name is not None
  *     if use_setstate:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state             # <<<<<<<<<<<<<<
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 11, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 11, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_INCREF(__pyx_int_184977713);
     __Pyx_GIVEREF(__pyx_int_184977713);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_184977713);
     __Pyx_INCREF(Py_None);
     __Pyx_GIVEREF(Py_None);
     PyTuple_SET_ITEM(__pyx_t_1, 2, Py_None);
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 11, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 13, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
     PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_v_state);
     __pyx_t_4 = 0;
     __pyx_t_1 = 0;
     __pyx_r = __pyx_t_5;
     __pyx_t_5 = 0;
     goto __pyx_L0;
 
-    /* "(tree fragment)":10
+    /* "(tree fragment)":12
  *     else:
  *         use_setstate = self.name is not None
  *     if use_setstate:             # <<<<<<<<<<<<<<
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
  */
   }
 
-  /* "(tree fragment)":13
+  /* "(tree fragment)":15
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, None), state
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 13, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyx_unpickle_Enum); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 15, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 13, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 15, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
     __Pyx_INCREF(__pyx_int_184977713);
     __Pyx_GIVEREF(__pyx_int_184977713);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_184977713);
     __Pyx_INCREF(__pyx_v_state);
     __Pyx_GIVEREF(__pyx_v_state);
     PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);
-    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 13, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 15, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
     __pyx_t_5 = 0;
     __pyx_t_1 = 0;
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L0;
   }
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
- *     cdef bint use_setstate
- *     state = (self.name,)
+ *     cdef tuple state
+ *     cdef object _dict
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
@@ -7892,15 +7865,15 @@
   __Pyx_XDECREF(__pyx_v_state);
   __Pyx_XDECREF(__pyx_v__dict);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "(tree fragment)":14
+/* "(tree fragment)":16
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
 
 /* Python wrapper */
@@ -7918,25 +7891,25 @@
 
 static PyObject *__pyx_pf___pyx_MemviewEnum_2__setstate_cython__(struct __pyx_MemviewEnum_obj *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
-  /* "(tree fragment)":15
+  /* "(tree fragment)":17
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
  */
-  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(2, 15, __pyx_L1_error)
-  __pyx_t_1 = __pyx_unpickle_Enum__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 15, __pyx_L1_error)
+  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(2, 17, __pyx_L1_error)
+  __pyx_t_1 = __pyx_unpickle_Enum__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 17, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "(tree fragment)":14
+  /* "(tree fragment)":16
  *     else:
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
 
   /* function exit code */
@@ -7948,98 +7921,98 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":296
+/* "View.MemoryView":298
  * 
  * @cname('__pyx_align_pointer')
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
  */
 
 static void *__pyx_align_pointer(void *__pyx_v_memory, size_t __pyx_v_alignment) {
   Py_intptr_t __pyx_v_aligned_p;
   size_t __pyx_v_offset;
   void *__pyx_r;
   int __pyx_t_1;
 
-  /* "View.MemoryView":298
+  /* "View.MemoryView":300
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory             # <<<<<<<<<<<<<<
  *     cdef size_t offset
  * 
  */
   __pyx_v_aligned_p = ((Py_intptr_t)__pyx_v_memory);
 
-  /* "View.MemoryView":302
+  /* "View.MemoryView":304
  * 
  *     with cython.cdivision(True):
  *         offset = aligned_p % alignment             # <<<<<<<<<<<<<<
  * 
  *     if offset > 0:
  */
   __pyx_v_offset = (__pyx_v_aligned_p % __pyx_v_alignment);
 
-  /* "View.MemoryView":304
+  /* "View.MemoryView":306
  *         offset = aligned_p % alignment
  * 
  *     if offset > 0:             # <<<<<<<<<<<<<<
  *         aligned_p += alignment - offset
  * 
  */
   __pyx_t_1 = ((__pyx_v_offset > 0) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":305
+    /* "View.MemoryView":307
  * 
  *     if offset > 0:
  *         aligned_p += alignment - offset             # <<<<<<<<<<<<<<
  * 
  *     return <void *> aligned_p
  */
     __pyx_v_aligned_p = (__pyx_v_aligned_p + (__pyx_v_alignment - __pyx_v_offset));
 
-    /* "View.MemoryView":304
+    /* "View.MemoryView":306
  *         offset = aligned_p % alignment
  * 
  *     if offset > 0:             # <<<<<<<<<<<<<<
  *         aligned_p += alignment - offset
  * 
  */
   }
 
-  /* "View.MemoryView":307
+  /* "View.MemoryView":309
  *         aligned_p += alignment - offset
  * 
  *     return <void *> aligned_p             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((void *)__pyx_v_aligned_p);
   goto __pyx_L0;
 
-  /* "View.MemoryView":296
+  /* "View.MemoryView":298
  * 
  * @cname('__pyx_align_pointer')
  * cdef void *align_pointer(void *memory, size_t alignment) nogil:             # <<<<<<<<<<<<<<
  *     "Align pointer memory on a given boundary"
  *     cdef Py_intptr_t aligned_p = <Py_intptr_t> memory
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":343
+/* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
@@ -8067,53 +8040,53 @@
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_flags)) != 0)) kw_args--;
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_flags)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(2, 343, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, 1); __PYX_ERR(2, 345, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
-          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_dtype_is_object);
+          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype_is_object);
           if (value) { values[2] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(2, 343, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(2, 345, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
         case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
         values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_obj = values[0];
-    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 343, __pyx_L3_error)
+    __pyx_v_flags = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_flags == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 345, __pyx_L3_error)
     if (values[2]) {
-      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 343, __pyx_L3_error)
+      __pyx_v_dtype_is_object = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_dtype_is_object == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 345, __pyx_L3_error)
     } else {
       __pyx_v_dtype_is_object = ((int)0);
     }
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(2, 343, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(2, 345, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview___cinit__(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_obj, __pyx_v_flags, __pyx_v_dtype_is_object);
 
@@ -8127,37 +8100,37 @@
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   __Pyx_RefNannySetupContext("__cinit__", 0);
 
-  /* "View.MemoryView":344
+  /* "View.MemoryView":346
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj             # <<<<<<<<<<<<<<
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  */
   __Pyx_INCREF(__pyx_v_obj);
   __Pyx_GIVEREF(__pyx_v_obj);
   __Pyx_GOTREF(__pyx_v_self->obj);
   __Pyx_DECREF(__pyx_v_self->obj);
   __pyx_v_self->obj = __pyx_v_obj;
 
-  /* "View.MemoryView":345
+  /* "View.MemoryView":347
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):
  *         self.obj = obj
  *         self.flags = flags             # <<<<<<<<<<<<<<
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  */
   __pyx_v_self->flags = __pyx_v_flags;
 
-  /* "View.MemoryView":346
+  /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   __pyx_t_2 = (((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))) == ((PyObject *)__pyx_memoryview_type));
@@ -8169,173 +8142,173 @@
   }
   __pyx_t_3 = (__pyx_v_obj != Py_None);
   __pyx_t_2 = (__pyx_t_3 != 0);
   __pyx_t_1 = __pyx_t_2;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":347
+    /* "View.MemoryView":349
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)             # <<<<<<<<<<<<<<
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  */
-    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 347, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_GetBuffer(__pyx_v_obj, (&__pyx_v_self->view), __pyx_v_flags); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 349, __pyx_L1_error)
 
-    /* "View.MemoryView":348
+    /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
     __pyx_t_1 = ((((PyObject *)__pyx_v_self->view.obj) == NULL) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":349
+      /* "View.MemoryView":351
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None             # <<<<<<<<<<<<<<
  *                 Py_INCREF(Py_None)
  * 
  */
       ((Py_buffer *)(&__pyx_v_self->view))->obj = Py_None;
 
-      /* "View.MemoryView":350
+      /* "View.MemoryView":352
  *             if <PyObject *> self.view.obj == NULL:
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
  *         global __pyx_memoryview_thread_locks_used
  */
       Py_INCREF(Py_None);
 
-      /* "View.MemoryView":348
+      /* "View.MemoryView":350
  *         if type(self) is memoryview or obj is not None:
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:             # <<<<<<<<<<<<<<
  *                 (<__pyx_buffer *> &self.view).obj = Py_None
  *                 Py_INCREF(Py_None)
  */
     }
 
-    /* "View.MemoryView":346
+    /* "View.MemoryView":348
  *         self.obj = obj
  *         self.flags = flags
  *         if type(self) is memoryview or obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_GetBuffer(obj, &self.view, flags)
  *             if <PyObject *> self.view.obj == NULL:
  */
   }
 
-  /* "View.MemoryView":353
+  /* "View.MemoryView":355
  * 
  *         global __pyx_memoryview_thread_locks_used
  *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
  *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
  *             __pyx_memoryview_thread_locks_used += 1
  */
   __pyx_t_1 = ((__pyx_memoryview_thread_locks_used < 8) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":354
+    /* "View.MemoryView":356
  *         global __pyx_memoryview_thread_locks_used
  *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
  *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]             # <<<<<<<<<<<<<<
  *             __pyx_memoryview_thread_locks_used += 1
  *         if self.lock is NULL:
  */
     __pyx_v_self->lock = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
 
-    /* "View.MemoryView":355
+    /* "View.MemoryView":357
  *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:
  *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
  *             __pyx_memoryview_thread_locks_used += 1             # <<<<<<<<<<<<<<
  *         if self.lock is NULL:
  *             self.lock = PyThread_allocate_lock()
  */
     __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used + 1);
 
-    /* "View.MemoryView":353
+    /* "View.MemoryView":355
  * 
  *         global __pyx_memoryview_thread_locks_used
  *         if __pyx_memoryview_thread_locks_used < THREAD_LOCKS_PREALLOCATED:             # <<<<<<<<<<<<<<
  *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
  *             __pyx_memoryview_thread_locks_used += 1
  */
   }
 
-  /* "View.MemoryView":356
+  /* "View.MemoryView":358
  *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
  *             __pyx_memoryview_thread_locks_used += 1
  *         if self.lock is NULL:             # <<<<<<<<<<<<<<
  *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
  */
   __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":357
+    /* "View.MemoryView":359
  *             __pyx_memoryview_thread_locks_used += 1
  *         if self.lock is NULL:
  *             self.lock = PyThread_allocate_lock()             # <<<<<<<<<<<<<<
  *             if self.lock is NULL:
  *                 raise MemoryError
  */
     __pyx_v_self->lock = PyThread_allocate_lock();
 
-    /* "View.MemoryView":358
+    /* "View.MemoryView":360
  *         if self.lock is NULL:
  *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  * 
  */
     __pyx_t_1 = ((__pyx_v_self->lock == NULL) != 0);
-    if (__pyx_t_1) {
+    if (unlikely(__pyx_t_1)) {
 
-      /* "View.MemoryView":359
+      /* "View.MemoryView":361
  *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
-      PyErr_NoMemory(); __PYX_ERR(2, 359, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(2, 361, __pyx_L1_error)
 
-      /* "View.MemoryView":358
+      /* "View.MemoryView":360
  *         if self.lock is NULL:
  *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  * 
  */
     }
 
-    /* "View.MemoryView":356
+    /* "View.MemoryView":358
  *             self.lock = __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]
  *             __pyx_memoryview_thread_locks_used += 1
  *         if self.lock is NULL:             # <<<<<<<<<<<<<<
  *             self.lock = PyThread_allocate_lock()
  *             if self.lock is NULL:
  */
   }
 
-  /* "View.MemoryView":361
+  /* "View.MemoryView":363
  *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":362
+    /* "View.MemoryView":364
  * 
  *         if flags & PyBUF_FORMAT:
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')             # <<<<<<<<<<<<<<
  *         else:
  *             self.dtype_is_object = dtype_is_object
  */
     __pyx_t_2 = (((__pyx_v_self->view.format[0]) == 'O') != 0);
@@ -8345,55 +8318,55 @@
       goto __pyx_L11_bool_binop_done;
     }
     __pyx_t_2 = (((__pyx_v_self->view.format[1]) == '\x00') != 0);
     __pyx_t_1 = __pyx_t_2;
     __pyx_L11_bool_binop_done:;
     __pyx_v_self->dtype_is_object = __pyx_t_1;
 
-    /* "View.MemoryView":361
+    /* "View.MemoryView":363
  *                 raise MemoryError
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  */
     goto __pyx_L10;
   }
 
-  /* "View.MemoryView":364
+  /* "View.MemoryView":366
  *             self.dtype_is_object = (self.view.format[0] == b'O' and self.view.format[1] == b'\0')
  *         else:
  *             self.dtype_is_object = dtype_is_object             # <<<<<<<<<<<<<<
  * 
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  */
   /*else*/ {
     __pyx_v_self->dtype_is_object = __pyx_v_dtype_is_object;
   }
   __pyx_L10:;
 
-  /* "View.MemoryView":366
+  /* "View.MemoryView":368
  *             self.dtype_is_object = dtype_is_object
  * 
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(             # <<<<<<<<<<<<<<
  *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL
  */
   __pyx_v_self->acquisition_count_aligned_p = ((__pyx_atomic_int *)__pyx_align_pointer(((void *)(&(__pyx_v_self->acquisition_count[0]))), (sizeof(__pyx_atomic_int))));
 
-  /* "View.MemoryView":368
+  /* "View.MemoryView":370
  *         self.acquisition_count_aligned_p = <__pyx_atomic_int *> align_pointer(
  *                   <void *> &self.acquisition_count[0], sizeof(__pyx_atomic_int))
  *         self.typeinfo = NULL             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(memoryview self):
  */
   __pyx_v_self->typeinfo = NULL;
 
-  /* "View.MemoryView":343
+  /* "View.MemoryView":345
  *     cdef __Pyx_TypeInfo *typeinfo
  * 
  *     def __cinit__(memoryview self, object obj, int flags, bint dtype_is_object=False):             # <<<<<<<<<<<<<<
  *         self.obj = obj
  *         self.flags = flags
  */
 
@@ -8404,15 +8377,15 @@
   __Pyx_AddTraceback("View.MemoryView.memoryview.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":370
+/* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
@@ -8430,179 +8403,181 @@
 static void __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_2__dealloc__(struct __pyx_memoryview_obj *__pyx_v_self) {
   int __pyx_v_i;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
-  PyThread_type_lock __pyx_t_5;
+  int __pyx_t_5;
   PyThread_type_lock __pyx_t_6;
+  PyThread_type_lock __pyx_t_7;
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":371
+  /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  * 
  */
   __pyx_t_1 = (__pyx_v_self->obj != Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":372
+    /* "View.MemoryView":374
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)             # <<<<<<<<<<<<<<
  * 
  *         cdef int i
  */
     __Pyx_ReleaseBuffer((&__pyx_v_self->view));
 
-    /* "View.MemoryView":371
+    /* "View.MemoryView":373
  * 
  *     def __dealloc__(memoryview self):
  *         if self.obj is not None:             # <<<<<<<<<<<<<<
  *             __Pyx_ReleaseBuffer(&self.view)
  * 
  */
   }
 
-  /* "View.MemoryView":376
+  /* "View.MemoryView":378
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   __pyx_t_2 = ((__pyx_v_self->lock != NULL) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":377
+    /* "View.MemoryView":379
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):             # <<<<<<<<<<<<<<
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  */
     __pyx_t_3 = __pyx_memoryview_thread_locks_used;
-    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-      __pyx_v_i = __pyx_t_4;
+    __pyx_t_4 = __pyx_t_3;
+    for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
+      __pyx_v_i = __pyx_t_5;
 
-      /* "View.MemoryView":378
+      /* "View.MemoryView":380
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
       __pyx_t_2 = (((__pyx_memoryview_thread_locks[__pyx_v_i]) == __pyx_v_self->lock) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":379
+        /* "View.MemoryView":381
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1             # <<<<<<<<<<<<<<
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  */
         __pyx_memoryview_thread_locks_used = (__pyx_memoryview_thread_locks_used - 1);
 
-        /* "View.MemoryView":380
+        /* "View.MemoryView":382
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
         __pyx_t_2 = ((__pyx_v_i != __pyx_memoryview_thread_locks_used) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":382
+          /* "View.MemoryView":384
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])             # <<<<<<<<<<<<<<
  *                     break
  *             else:
  */
-          __pyx_t_5 = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
-          __pyx_t_6 = (__pyx_memoryview_thread_locks[__pyx_v_i]);
+          __pyx_t_6 = (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]);
+          __pyx_t_7 = (__pyx_memoryview_thread_locks[__pyx_v_i]);
 
-          /* "View.MemoryView":381
+          /* "View.MemoryView":383
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (             # <<<<<<<<<<<<<<
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break
  */
-          (__pyx_memoryview_thread_locks[__pyx_v_i]) = __pyx_t_5;
-          (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]) = __pyx_t_6;
+          (__pyx_memoryview_thread_locks[__pyx_v_i]) = __pyx_t_6;
+          (__pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used]) = __pyx_t_7;
 
-          /* "View.MemoryView":380
+          /* "View.MemoryView":382
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:             # <<<<<<<<<<<<<<
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  */
         }
 
-        /* "View.MemoryView":383
+        /* "View.MemoryView":385
  *                         __pyx_memoryview_thread_locks[i], __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used] = (
  *                             __pyx_memoryview_thread_locks[__pyx_memoryview_thread_locks_used], __pyx_memoryview_thread_locks[i])
  *                     break             # <<<<<<<<<<<<<<
  *             else:
  *                 PyThread_free_lock(self.lock)
  */
         goto __pyx_L6_break;
 
-        /* "View.MemoryView":378
+        /* "View.MemoryView":380
  *         if self.lock != NULL:
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:             # <<<<<<<<<<<<<<
  *                     __pyx_memoryview_thread_locks_used -= 1
  *                     if i != __pyx_memoryview_thread_locks_used:
  */
       }
     }
     /*else*/ {
 
-      /* "View.MemoryView":385
+      /* "View.MemoryView":387
  *                     break
  *             else:
  *                 PyThread_free_lock(self.lock)             # <<<<<<<<<<<<<<
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  */
       PyThread_free_lock(__pyx_v_self->lock);
     }
     __pyx_L6_break:;
 
-    /* "View.MemoryView":376
+    /* "View.MemoryView":378
  *         cdef int i
  *         global __pyx_memoryview_thread_locks_used
  *         if self.lock != NULL:             # <<<<<<<<<<<<<<
  *             for i in range(__pyx_memoryview_thread_locks_used):
  *                 if __pyx_memoryview_thread_locks[i] is self.lock:
  */
   }
 
-  /* "View.MemoryView":370
+  /* "View.MemoryView":372
  *         self.typeinfo = NULL
  * 
  *     def __dealloc__(memoryview self):             # <<<<<<<<<<<<<<
  *         if self.obj is not None:
  *             __Pyx_ReleaseBuffer(&self.view)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":387
+/* "View.MemoryView":389
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -8617,107 +8592,107 @@
   Py_ssize_t __pyx_t_3;
   PyObject *(*__pyx_t_4)(PyObject *);
   PyObject *__pyx_t_5 = NULL;
   Py_ssize_t __pyx_t_6;
   char *__pyx_t_7;
   __Pyx_RefNannySetupContext("get_item_pointer", 0);
 
-  /* "View.MemoryView":389
+  /* "View.MemoryView":391
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf             # <<<<<<<<<<<<<<
  * 
  *         for dim, idx in enumerate(index):
  */
   __pyx_v_itemp = ((char *)__pyx_v_self->view.buf);
 
-  /* "View.MemoryView":391
+  /* "View.MemoryView":393
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   __pyx_t_1 = 0;
   if (likely(PyList_CheckExact(__pyx_v_index)) || PyTuple_CheckExact(__pyx_v_index)) {
     __pyx_t_2 = __pyx_v_index; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
     __pyx_t_4 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 391, __pyx_L1_error)
+    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 393, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 391, __pyx_L1_error)
+    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 393, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_4)) {
       if (likely(PyList_CheckExact(__pyx_t_2))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(2, 391, __pyx_L1_error)
+        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(2, 393, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 391, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 393, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(2, 391, __pyx_L1_error)
+        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(2, 393, __pyx_L1_error)
         #else
-        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 391, __pyx_L1_error)
+        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 393, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         #endif
       }
     } else {
       __pyx_t_5 = __pyx_t_4(__pyx_t_2);
       if (unlikely(!__pyx_t_5)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(2, 391, __pyx_L1_error)
+          else __PYX_ERR(2, 393, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_5);
     }
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_5);
     __pyx_t_5 = 0;
     __pyx_v_dim = __pyx_t_1;
     __pyx_t_1 = (__pyx_t_1 + 1);
 
-    /* "View.MemoryView":392
+    /* "View.MemoryView":394
  * 
  *         for dim, idx in enumerate(index):
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)             # <<<<<<<<<<<<<<
  * 
  *         return itemp
  */
-    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 392, __pyx_L1_error)
-    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(2, 392, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_idx); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 394, __pyx_L1_error)
+    __pyx_t_7 = __pyx_pybuffer_index((&__pyx_v_self->view), __pyx_v_itemp, __pyx_t_6, __pyx_v_dim); if (unlikely(__pyx_t_7 == ((char *)NULL))) __PYX_ERR(2, 394, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_7;
 
-    /* "View.MemoryView":391
+    /* "View.MemoryView":393
  *         cdef char *itemp = <char *> self.view.buf
  * 
  *         for dim, idx in enumerate(index):             # <<<<<<<<<<<<<<
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  */
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":394
+  /* "View.MemoryView":396
  *             itemp = pybuffer_index(&self.view, itemp, idx, dim)
  * 
  *         return itemp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_itemp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":387
+  /* "View.MemoryView":389
  *                 PyThread_free_lock(self.lock)
  * 
  *     cdef char *get_item_pointer(memoryview self, object index) except NULL:             # <<<<<<<<<<<<<<
  *         cdef Py_ssize_t dim
  *         cdef char *itemp = <char *> self.view.buf
  */
 
@@ -8729,15 +8704,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":397
+/* "View.MemoryView":399
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
@@ -8764,147 +8739,143 @@
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   char *__pyx_t_6;
   __Pyx_RefNannySetupContext("__getitem__", 0);
 
-  /* "View.MemoryView":398
+  /* "View.MemoryView":400
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   __pyx_t_1 = (__pyx_v_index == __pyx_builtin_Ellipsis);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":399
+    /* "View.MemoryView":401
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:
  *             return self             # <<<<<<<<<<<<<<
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject *)__pyx_v_self));
     __pyx_r = ((PyObject *)__pyx_v_self);
     goto __pyx_L0;
 
-    /* "View.MemoryView":398
+    /* "View.MemoryView":400
  * 
  *     def __getitem__(memoryview self, object index):
  *         if index is Ellipsis:             # <<<<<<<<<<<<<<
  *             return self
  * 
  */
   }
 
-  /* "View.MemoryView":401
+  /* "View.MemoryView":403
  *             return self
  * 
  *         have_slices, indices = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         cdef char *itemp
  */
-  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 401, __pyx_L1_error)
+  __pyx_t_3 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 403, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   if (likely(__pyx_t_3 != Py_None)) {
     PyObject* sequence = __pyx_t_3;
-    #if !CYTHON_COMPILING_IN_PYPY
-    Py_ssize_t size = Py_SIZE(sequence);
-    #else
-    Py_ssize_t size = PySequence_Size(sequence);
-    #endif
+    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(2, 401, __pyx_L1_error)
+      __PYX_ERR(2, 403, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
     __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_t_5);
     #else
-    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 401, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 403, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 401, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 403, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     #endif
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(2, 401, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(2, 403, __pyx_L1_error)
   }
   __pyx_v_have_slices = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_v_indices = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "View.MemoryView":404
+  /* "View.MemoryView":406
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(2, 404, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(2, 406, __pyx_L1_error)
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":405
+    /* "View.MemoryView":407
  *         cdef char *itemp
  *         if have_slices:
  *             return memview_slice(self, indices)             # <<<<<<<<<<<<<<
  *         else:
  *             itemp = self.get_item_pointer(indices)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 405, __pyx_L1_error)
+    __pyx_t_3 = ((PyObject *)__pyx_memview_slice(__pyx_v_self, __pyx_v_indices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 407, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":404
+    /* "View.MemoryView":406
  * 
  *         cdef char *itemp
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             return memview_slice(self, indices)
  *         else:
  */
   }
 
-  /* "View.MemoryView":407
+  /* "View.MemoryView":409
  *             return memview_slice(self, indices)
  *         else:
  *             itemp = self.get_item_pointer(indices)             # <<<<<<<<<<<<<<
  *             return self.convert_item_to_object(itemp)
  * 
  */
   /*else*/ {
-    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(2, 407, __pyx_L1_error)
+    __pyx_t_6 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_indices); if (unlikely(__pyx_t_6 == ((char *)NULL))) __PYX_ERR(2, 409, __pyx_L1_error)
     __pyx_v_itemp = __pyx_t_6;
 
-    /* "View.MemoryView":408
+    /* "View.MemoryView":410
  *         else:
  *             itemp = self.get_item_pointer(indices)
  *             return self.convert_item_to_object(itemp)             # <<<<<<<<<<<<<<
  * 
  *     def __setitem__(memoryview self, object index, object value):
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 408, __pyx_L1_error)
+    __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->convert_item_to_object(__pyx_v_self, __pyx_v_itemp); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 410, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":397
+  /* "View.MemoryView":399
  * 
  * 
  *     def __getitem__(memoryview self, object index):             # <<<<<<<<<<<<<<
  *         if index is Ellipsis:
  *             return self
  */
 
@@ -8919,20 +8890,20 @@
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_indices);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":410
+/* "View.MemoryView":412
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
- *         have_slices, index = _unellipsify(index, self.view.ndim)
- * 
+ *         if self.view.readonly:
+ *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
 /* Python wrapper */
 static int __pyx_memoryview___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value); /*proto*/
 static int __pyx_memoryview___setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
@@ -8945,186 +8916,214 @@
 }
 
 static int __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_6__setitem__(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value) {
   PyObject *__pyx_v_have_slices = NULL;
   PyObject *__pyx_v_obj = NULL;
   int __pyx_r;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
+  PyObject *__pyx_t_4 = NULL;
   __Pyx_RefNannySetupContext("__setitem__", 0);
   __Pyx_INCREF(__pyx_v_index);
 
-  /* "View.MemoryView":411
+  /* "View.MemoryView":413
  * 
  *     def __setitem__(memoryview self, object index, object value):
+ *         if self.view.readonly:             # <<<<<<<<<<<<<<
+ *             raise TypeError("Cannot assign to read-only memoryview")
+ * 
+ */
+  __pyx_t_1 = (__pyx_v_self->view.readonly != 0);
+  if (unlikely(__pyx_t_1)) {
+
+    /* "View.MemoryView":414
+ *     def __setitem__(memoryview self, object index, object value):
+ *         if self.view.readonly:
+ *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
+ * 
+ *         have_slices, index = _unellipsify(index, self.view.ndim)
+ */
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 414, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_ERR(2, 414, __pyx_L1_error)
+
+    /* "View.MemoryView":413
+ * 
+ *     def __setitem__(memoryview self, object index, object value):
+ *         if self.view.readonly:             # <<<<<<<<<<<<<<
+ *             raise TypeError("Cannot assign to read-only memoryview")
+ * 
+ */
+  }
+
+  /* "View.MemoryView":416
+ *             raise TypeError("Cannot assign to read-only memoryview")
+ * 
  *         have_slices, index = _unellipsify(index, self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *         if have_slices:
  */
-  __pyx_t_1 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 411, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (likely(__pyx_t_1 != Py_None)) {
-    PyObject* sequence = __pyx_t_1;
-    #if !CYTHON_COMPILING_IN_PYPY
-    Py_ssize_t size = Py_SIZE(sequence);
-    #else
-    Py_ssize_t size = PySequence_Size(sequence);
-    #endif
+  __pyx_t_2 = _unellipsify(__pyx_v_index, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 416, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (likely(__pyx_t_2 != Py_None)) {
+    PyObject* sequence = __pyx_t_2;
+    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 2)) {
       if (size > 2) __Pyx_RaiseTooManyValuesError(2);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(2, 411, __pyx_L1_error)
+      __PYX_ERR(2, 416, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
-    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
-    __Pyx_INCREF(__pyx_t_2);
+    __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
+    __pyx_t_4 = PyTuple_GET_ITEM(sequence, 1); 
     __Pyx_INCREF(__pyx_t_3);
+    __Pyx_INCREF(__pyx_t_4);
     #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 411, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 411, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 416, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 416, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
     #endif
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else {
-    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(2, 411, __pyx_L1_error)
+    __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(2, 416, __pyx_L1_error)
   }
-  __pyx_v_have_slices = __pyx_t_2;
-  __pyx_t_2 = 0;
-  __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_3);
+  __pyx_v_have_slices = __pyx_t_3;
   __pyx_t_3 = 0;
+  __Pyx_DECREF_SET(__pyx_v_index, __pyx_t_4);
+  __pyx_t_4 = 0;
 
-  /* "View.MemoryView":413
+  /* "View.MemoryView":418
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(2, 413, __pyx_L1_error)
-  if (__pyx_t_4) {
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_have_slices); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 418, __pyx_L1_error)
+  if (__pyx_t_1) {
 
-    /* "View.MemoryView":414
+    /* "View.MemoryView":419
  * 
  *         if have_slices:
  *             obj = self.is_slice(value)             # <<<<<<<<<<<<<<
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)
  */
-    __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 414, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_v_obj = __pyx_t_1;
-    __pyx_t_1 = 0;
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->is_slice(__pyx_v_self, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 419, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_v_obj = __pyx_t_2;
+    __pyx_t_2 = 0;
 
-    /* "View.MemoryView":415
+    /* "View.MemoryView":420
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
-    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(2, 415, __pyx_L1_error)
-    if (__pyx_t_4) {
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_obj); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 420, __pyx_L1_error)
+    if (__pyx_t_1) {
 
-      /* "View.MemoryView":416
+      /* "View.MemoryView":421
  *             obj = self.is_slice(value)
  *             if obj:
  *                 self.setitem_slice_assignment(self[index], obj)             # <<<<<<<<<<<<<<
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)
  */
-      __pyx_t_1 = PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 416, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_1, __pyx_v_obj); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 416, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 421, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_4 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assignment(__pyx_v_self, __pyx_t_2, __pyx_v_obj); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 421, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-      /* "View.MemoryView":415
+      /* "View.MemoryView":420
  *         if have_slices:
  *             obj = self.is_slice(value)
  *             if obj:             # <<<<<<<<<<<<<<
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  */
-      goto __pyx_L4;
+      goto __pyx_L5;
     }
 
-    /* "View.MemoryView":418
+    /* "View.MemoryView":423
  *                 self.setitem_slice_assignment(self[index], obj)
  *             else:
  *                 self.setitem_slice_assign_scalar(self[index], value)             # <<<<<<<<<<<<<<
  *         else:
  *             self.setitem_indexed(index, value)
  */
     /*else*/ {
-      __pyx_t_3 = PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 418, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(2, 418, __pyx_L1_error)
-      __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_3), __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 418, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_4 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_self), __pyx_v_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 423, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      if (!(likely(((__pyx_t_4) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_4, __pyx_memoryview_type))))) __PYX_ERR(2, 423, __pyx_L1_error)
+      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_slice_assign_scalar(__pyx_v_self, ((struct __pyx_memoryview_obj *)__pyx_t_4), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 423, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
-    __pyx_L4:;
+    __pyx_L5:;
 
-    /* "View.MemoryView":413
+    /* "View.MemoryView":418
  *         have_slices, index = _unellipsify(index, self.view.ndim)
  * 
  *         if have_slices:             # <<<<<<<<<<<<<<
  *             obj = self.is_slice(value)
  *             if obj:
  */
-    goto __pyx_L3;
+    goto __pyx_L4;
   }
 
-  /* "View.MemoryView":420
+  /* "View.MemoryView":425
  *                 self.setitem_slice_assign_scalar(self[index], value)
  *         else:
  *             self.setitem_indexed(index, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef is_slice(self, obj):
  */
   /*else*/ {
-    __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 420, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->setitem_indexed(__pyx_v_self, __pyx_v_index, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 425, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
-  __pyx_L3:;
+  __pyx_L4:;
 
-  /* "View.MemoryView":410
+  /* "View.MemoryView":412
  *             return self.convert_item_to_object(itemp)
  * 
  *     def __setitem__(memoryview self, object index, object value):             # <<<<<<<<<<<<<<
- *         have_slices, index = _unellipsify(index, self.view.ndim)
- * 
+ *         if self.view.readonly:
+ *             raise TypeError("Cannot assign to read-only memoryview")
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
   __Pyx_AddTraceback("View.MemoryView.memoryview.__setitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_have_slices);
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":422
+/* "View.MemoryView":427
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -9139,140 +9138,139 @@
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_t_9;
   __Pyx_RefNannySetupContext("is_slice", 0);
   __Pyx_INCREF(__pyx_v_obj);
 
-  /* "View.MemoryView":423
+  /* "View.MemoryView":428
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_obj, __pyx_memoryview_type); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":424
+    /* "View.MemoryView":429
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
     {
       __Pyx_PyThreadState_declare
       __Pyx_PyThreadState_assign
       __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
       __Pyx_XGOTREF(__pyx_t_3);
       __Pyx_XGOTREF(__pyx_t_4);
       __Pyx_XGOTREF(__pyx_t_5);
       /*try:*/ {
 
-        /* "View.MemoryView":425
+        /* "View.MemoryView":430
  *         if not isinstance(obj, memoryview):
  *             try:
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_6 = __Pyx_PyInt_From_int((__pyx_v_self->flags | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 425, __pyx_L4_error)
+        __pyx_t_6 = __Pyx_PyInt_From_int(((__pyx_v_self->flags & (~PyBUF_WRITABLE)) | PyBUF_ANY_CONTIGUOUS)); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 430, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":426
+        /* "View.MemoryView":431
  *             try:
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)             # <<<<<<<<<<<<<<
  *             except TypeError:
  *                 return None
  */
-        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 426, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_v_self->dtype_is_object); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 431, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
 
-        /* "View.MemoryView":425
+        /* "View.MemoryView":430
  *         if not isinstance(obj, memoryview):
  *             try:
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,             # <<<<<<<<<<<<<<
  *                                  self.dtype_is_object)
  *             except TypeError:
  */
-        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 425, __pyx_L4_error)
+        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 430, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_INCREF(__pyx_v_obj);
         __Pyx_GIVEREF(__pyx_v_obj);
         PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_obj);
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_6);
         __Pyx_GIVEREF(__pyx_t_7);
         PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_t_7);
         __pyx_t_6 = 0;
         __pyx_t_7 = 0;
-        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 425, __pyx_L4_error)
+        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 430, __pyx_L4_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF_SET(__pyx_v_obj, __pyx_t_7);
         __pyx_t_7 = 0;
 
-        /* "View.MemoryView":424
+        /* "View.MemoryView":429
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
       }
       __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       goto __pyx_L9_try_end;
       __pyx_L4_error:;
       __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
       __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
       __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-      /* "View.MemoryView":427
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,
+      /* "View.MemoryView":432
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  *             except TypeError:             # <<<<<<<<<<<<<<
  *                 return None
  * 
  */
       __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
       if (__pyx_t_9) {
         __Pyx_AddTraceback("View.MemoryView.memoryview.is_slice", __pyx_clineno, __pyx_lineno, __pyx_filename);
-        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(2, 427, __pyx_L6_except_error)
+        if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_8, &__pyx_t_6) < 0) __PYX_ERR(2, 432, __pyx_L6_except_error)
         __Pyx_GOTREF(__pyx_t_7);
         __Pyx_GOTREF(__pyx_t_8);
         __Pyx_GOTREF(__pyx_t_6);
 
-        /* "View.MemoryView":428
+        /* "View.MemoryView":433
  *                                  self.dtype_is_object)
  *             except TypeError:
  *                 return None             # <<<<<<<<<<<<<<
  * 
  *         return obj
  */
         __Pyx_XDECREF(__pyx_r);
-        __Pyx_INCREF(Py_None);
-        __pyx_r = Py_None;
+        __pyx_r = Py_None; __Pyx_INCREF(Py_None);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         goto __pyx_L7_except_return;
       }
       goto __pyx_L6_except_error;
       __pyx_L6_except_error:;
 
-      /* "View.MemoryView":424
+      /* "View.MemoryView":429
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):
  *             try:             # <<<<<<<<<<<<<<
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  *                                  self.dtype_is_object)
  */
       __Pyx_XGIVEREF(__pyx_t_3);
       __Pyx_XGIVEREF(__pyx_t_4);
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L1_error;
@@ -9281,36 +9279,36 @@
       __Pyx_XGIVEREF(__pyx_t_4);
       __Pyx_XGIVEREF(__pyx_t_5);
       __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
       goto __pyx_L0;
       __pyx_L9_try_end:;
     }
 
-    /* "View.MemoryView":423
+    /* "View.MemoryView":428
  * 
  *     cdef is_slice(self, obj):
  *         if not isinstance(obj, memoryview):             # <<<<<<<<<<<<<<
  *             try:
- *                 obj = memoryview(obj, self.flags|PyBUF_ANY_CONTIGUOUS,
+ *                 obj = memoryview(obj, self.flags & ~PyBUF_WRITABLE | PyBUF_ANY_CONTIGUOUS,
  */
   }
 
-  /* "View.MemoryView":430
+  /* "View.MemoryView":435
  *                 return None
  * 
  *         return obj             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assignment(self, dst, src):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_obj);
   __pyx_r = __pyx_v_obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":422
+  /* "View.MemoryView":427
  *             self.setitem_indexed(index, value)
  * 
  *     cdef is_slice(self, obj):             # <<<<<<<<<<<<<<
  *         if not isinstance(obj, memoryview):
  *             try:
  */
 
@@ -9324,15 +9322,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_obj);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":432
+/* "View.MemoryView":437
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
@@ -9343,58 +9341,58 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   __Pyx_RefNannySetupContext("setitem_slice_assignment", 0);
 
-  /* "View.MemoryView":436
+  /* "View.MemoryView":441
  *         cdef __Pyx_memviewslice src_slice
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(2, 436, __pyx_L1_error)
+  if (!(likely(((__pyx_v_src) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_src, __pyx_memoryview_type))))) __PYX_ERR(2, 441, __pyx_L1_error)
 
-  /* "View.MemoryView":437
+  /* "View.MemoryView":442
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],             # <<<<<<<<<<<<<<
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  */
-  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(2, 437, __pyx_L1_error)
+  if (!(likely(((__pyx_v_dst) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_dst, __pyx_memoryview_type))))) __PYX_ERR(2, 442, __pyx_L1_error)
 
-  /* "View.MemoryView":438
+  /* "View.MemoryView":443
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 438, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_src, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 443, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 438, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 443, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 438, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_dst, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 443, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 438, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(2, 443, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "View.MemoryView":436
+  /* "View.MemoryView":441
  *         cdef __Pyx_memviewslice src_slice
  * 
  *         memoryview_copy_contents(get_slice_from_memview(src, &src_slice)[0],             # <<<<<<<<<<<<<<
  *                                  get_slice_from_memview(dst, &dst_slice)[0],
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  */
-  __pyx_t_4 = __pyx_memoryview_copy_contents((__pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice))[0]), (__pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice))[0]), __pyx_t_2, __pyx_t_3, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 436, __pyx_L1_error)
+  __pyx_t_4 = __pyx_memoryview_copy_contents((__pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_src), (&__pyx_v_src_slice))[0]), (__pyx_memoryview_get_slice_from_memoryview(((struct __pyx_memoryview_obj *)__pyx_v_dst), (&__pyx_v_dst_slice))[0]), __pyx_t_2, __pyx_t_3, __pyx_v_self->dtype_is_object); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 441, __pyx_L1_error)
 
-  /* "View.MemoryView":432
+  /* "View.MemoryView":437
  *         return obj
  * 
  *     cdef setitem_slice_assignment(self, dst, src):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice dst_slice
  *         cdef __Pyx_memviewslice src_slice
  */
 
@@ -9407,15 +9405,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":440
+/* "View.MemoryView":445
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
@@ -9436,203 +9434,203 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   PyObject *__pyx_t_9 = NULL;
   PyObject *__pyx_t_10 = NULL;
   PyObject *__pyx_t_11 = NULL;
   __Pyx_RefNannySetupContext("setitem_slice_assign_scalar", 0);
 
-  /* "View.MemoryView":442
+  /* "View.MemoryView":447
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):
  *         cdef int array[128]
  *         cdef void *tmp = NULL             # <<<<<<<<<<<<<<
  *         cdef void *item
  * 
  */
   __pyx_v_tmp = NULL;
 
-  /* "View.MemoryView":447
+  /* "View.MemoryView":452
  *         cdef __Pyx_memviewslice *dst_slice
  *         cdef __Pyx_memviewslice tmp_slice
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)             # <<<<<<<<<<<<<<
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  */
   __pyx_v_dst_slice = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_dst, (&__pyx_v_tmp_slice));
 
-  /* "View.MemoryView":449
+  /* "View.MemoryView":454
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
   __pyx_t_1 = ((((size_t)__pyx_v_self->view.itemsize) > (sizeof(__pyx_v_array))) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":450
+    /* "View.MemoryView":455
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)             # <<<<<<<<<<<<<<
  *             if tmp == NULL:
  *                 raise MemoryError
  */
     __pyx_v_tmp = PyMem_Malloc(__pyx_v_self->view.itemsize);
 
-    /* "View.MemoryView":451
+    /* "View.MemoryView":456
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
     __pyx_t_1 = ((__pyx_v_tmp == NULL) != 0);
-    if (__pyx_t_1) {
+    if (unlikely(__pyx_t_1)) {
 
-      /* "View.MemoryView":452
+      /* "View.MemoryView":457
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  *                 raise MemoryError             # <<<<<<<<<<<<<<
  *             item = tmp
  *         else:
  */
-      PyErr_NoMemory(); __PYX_ERR(2, 452, __pyx_L1_error)
+      PyErr_NoMemory(); __PYX_ERR(2, 457, __pyx_L1_error)
 
-      /* "View.MemoryView":451
+      /* "View.MemoryView":456
  *         if <size_t>self.view.itemsize > sizeof(array):
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:             # <<<<<<<<<<<<<<
  *                 raise MemoryError
  *             item = tmp
  */
     }
 
-    /* "View.MemoryView":453
+    /* "View.MemoryView":458
  *             if tmp == NULL:
  *                 raise MemoryError
  *             item = tmp             # <<<<<<<<<<<<<<
  *         else:
  *             item = <void *> array
  */
     __pyx_v_item = __pyx_v_tmp;
 
-    /* "View.MemoryView":449
+    /* "View.MemoryView":454
  *         dst_slice = get_slice_from_memview(dst, &tmp_slice)
  * 
  *         if <size_t>self.view.itemsize > sizeof(array):             # <<<<<<<<<<<<<<
  *             tmp = PyMem_Malloc(self.view.itemsize)
  *             if tmp == NULL:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":455
+  /* "View.MemoryView":460
  *             item = tmp
  *         else:
  *             item = <void *> array             # <<<<<<<<<<<<<<
  * 
  *         try:
  */
   /*else*/ {
     __pyx_v_item = ((void *)__pyx_v_array);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":457
+  /* "View.MemoryView":462
  *             item = <void *> array
  * 
  *         try:             # <<<<<<<<<<<<<<
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value
  */
   /*try:*/ {
 
-    /* "View.MemoryView":458
+    /* "View.MemoryView":463
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
     __pyx_t_1 = (__pyx_v_self->dtype_is_object != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":459
+      /* "View.MemoryView":464
  *         try:
  *             if self.dtype_is_object:
  *                 (<PyObject **> item)[0] = <PyObject *> value             # <<<<<<<<<<<<<<
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)
  */
       (((PyObject **)__pyx_v_item)[0]) = ((PyObject *)__pyx_v_value);
 
-      /* "View.MemoryView":458
+      /* "View.MemoryView":463
  * 
  *         try:
  *             if self.dtype_is_object:             # <<<<<<<<<<<<<<
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  */
       goto __pyx_L8;
     }
 
-    /* "View.MemoryView":461
+    /* "View.MemoryView":466
  *                 (<PyObject **> item)[0] = <PyObject *> value
  *             else:
  *                 self.assign_item_from_object(<char *> item, value)             # <<<<<<<<<<<<<<
  * 
  * 
  */
     /*else*/ {
-      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 461, __pyx_L6_error)
+      __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, ((char *)__pyx_v_item), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 466, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
     __pyx_L8:;
 
-    /* "View.MemoryView":465
+    /* "View.MemoryView":470
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     __pyx_t_1 = ((__pyx_v_self->view.suboffsets != NULL) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":466
+      /* "View.MemoryView":471
  * 
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)             # <<<<<<<<<<<<<<
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  *                                 item, self.dtype_is_object)
  */
-      __pyx_t_2 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 466, __pyx_L6_error)
+      __pyx_t_2 = assert_direct_dimensions(__pyx_v_self->view.suboffsets, __pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 471, __pyx_L6_error)
       __Pyx_GOTREF(__pyx_t_2);
       __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "View.MemoryView":465
+      /* "View.MemoryView":470
  * 
  * 
  *             if self.view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,
  */
     }
 
-    /* "View.MemoryView":467
+    /* "View.MemoryView":472
  *             if self.view.suboffsets != NULL:
  *                 assert_direct_dimensions(self.view.suboffsets, self.view.ndim)
  *             slice_assign_scalar(dst_slice, dst.view.ndim, self.view.itemsize,             # <<<<<<<<<<<<<<
  *                                 item, self.dtype_is_object)
  *         finally:
  */
     __pyx_memoryview_slice_assign_scalar(__pyx_v_dst_slice, __pyx_v_dst->view.ndim, __pyx_v_self->view.itemsize, __pyx_v_item, __pyx_v_self->dtype_is_object);
   }
 
-  /* "View.MemoryView":470
+  /* "View.MemoryView":475
  *                                 item, self.dtype_is_object)
  *         finally:
  *             PyMem_Free(tmp)             # <<<<<<<<<<<<<<
  * 
  *     cdef setitem_indexed(self, index, value):
  */
   /*finally:*/ {
@@ -9671,15 +9669,15 @@
       __pyx_t_6 = 0; __pyx_t_7 = 0; __pyx_t_8 = 0; __pyx_t_9 = 0; __pyx_t_10 = 0; __pyx_t_11 = 0;
       __pyx_lineno = __pyx_t_3; __pyx_clineno = __pyx_t_4; __pyx_filename = __pyx_t_5;
       goto __pyx_L1_error;
     }
     __pyx_L7:;
   }
 
-  /* "View.MemoryView":440
+  /* "View.MemoryView":445
  *                                  src.ndim, dst.ndim, self.dtype_is_object)
  * 
  *     cdef setitem_slice_assign_scalar(self, memoryview dst, value):             # <<<<<<<<<<<<<<
  *         cdef int array[128]
  *         cdef void *tmp = NULL
  */
 
@@ -9692,15 +9690,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":472
+/* "View.MemoryView":477
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -9708,36 +9706,36 @@
   char *__pyx_v_itemp;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   char *__pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   __Pyx_RefNannySetupContext("setitem_indexed", 0);
 
-  /* "View.MemoryView":473
+  /* "View.MemoryView":478
  * 
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)             # <<<<<<<<<<<<<<
  *         self.assign_item_from_object(itemp, value)
  * 
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(2, 473, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->get_item_pointer(__pyx_v_self, __pyx_v_index); if (unlikely(__pyx_t_1 == ((char *)NULL))) __PYX_ERR(2, 478, __pyx_L1_error)
   __pyx_v_itemp = __pyx_t_1;
 
-  /* "View.MemoryView":474
+  /* "View.MemoryView":479
  *     cdef setitem_indexed(self, index, value):
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
-  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 474, __pyx_L1_error)
+  __pyx_t_2 = ((struct __pyx_vtabstruct_memoryview *)__pyx_v_self->__pyx_vtab)->assign_item_from_object(__pyx_v_self, __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 479, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":472
+  /* "View.MemoryView":477
  *             PyMem_Free(tmp)
  * 
  *     cdef setitem_indexed(self, index, value):             # <<<<<<<<<<<<<<
  *         cdef char *itemp = self.get_item_pointer(index)
  *         self.assign_item_from_object(itemp, value)
  */
 
@@ -9750,15 +9748,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":476
+/* "View.MemoryView":481
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -9777,39 +9775,39 @@
   PyObject *__pyx_t_7 = NULL;
   int __pyx_t_8;
   PyObject *__pyx_t_9 = NULL;
   size_t __pyx_t_10;
   int __pyx_t_11;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":479
+  /* "View.MemoryView":484
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef bytes bytesitem
  * 
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 479, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 484, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":482
+  /* "View.MemoryView":487
  *         cdef bytes bytesitem
  * 
  *         bytesitem = itemp[:self.view.itemsize]             # <<<<<<<<<<<<<<
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  */
-  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 482, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_itemp + 0, __pyx_v_self->view.itemsize - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 487, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_bytesitem = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":483
+  /* "View.MemoryView":488
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
   {
@@ -9817,24 +9815,24 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_4);
     /*try:*/ {
 
-      /* "View.MemoryView":484
+      /* "View.MemoryView":489
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)             # <<<<<<<<<<<<<<
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 484, __pyx_L3_error)
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_unpack); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 489, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 484, __pyx_L3_error)
+      __pyx_t_6 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 489, __pyx_L3_error)
       __Pyx_GOTREF(__pyx_t_6);
       __pyx_t_7 = NULL;
       __pyx_t_8 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
         __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
         if (likely(__pyx_t_7)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -9843,94 +9841,94 @@
           __Pyx_DECREF_SET(__pyx_t_5, function);
           __pyx_t_8 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 484, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 489, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
         PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_6, __pyx_v_bytesitem};
-        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 484, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 489, __pyx_L3_error)
         __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       } else
       #endif
       {
-        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 484, __pyx_L3_error)
+        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 489, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_9);
         if (__pyx_t_7) {
           __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
         }
         __Pyx_GIVEREF(__pyx_t_6);
         PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_6);
         __Pyx_INCREF(__pyx_v_bytesitem);
         __Pyx_GIVEREF(__pyx_v_bytesitem);
         PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_bytesitem);
         __pyx_t_6 = 0;
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 484, __pyx_L3_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 489, __pyx_L3_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       }
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_v_result = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "View.MemoryView":483
+      /* "View.MemoryView":488
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     }
 
-    /* "View.MemoryView":488
+    /* "View.MemoryView":493
  *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
     /*else:*/ {
       __pyx_t_10 = strlen(__pyx_v_self->view.format); 
       __pyx_t_11 = ((__pyx_t_10 == 1) != 0);
       if (__pyx_t_11) {
 
-        /* "View.MemoryView":489
+        /* "View.MemoryView":494
  *         else:
  *             if len(self.view.format) == 1:
  *                 return result[0]             # <<<<<<<<<<<<<<
  *             return result
  * 
  */
         __Pyx_XDECREF(__pyx_r);
-        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 489, __pyx_L5_except_error)
+        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_result, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 494, __pyx_L5_except_error)
         __Pyx_GOTREF(__pyx_t_1);
         __pyx_r = __pyx_t_1;
         __pyx_t_1 = 0;
         goto __pyx_L6_except_return;
 
-        /* "View.MemoryView":488
+        /* "View.MemoryView":493
  *             raise ValueError("Unable to convert item to object")
  *         else:
  *             if len(self.view.format) == 1:             # <<<<<<<<<<<<<<
  *                 return result[0]
  *             return result
  */
       }
 
-      /* "View.MemoryView":490
+      /* "View.MemoryView":495
  *             if len(self.view.format) == 1:
  *                 return result[0]
  *             return result             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
       __Pyx_XDECREF(__pyx_r);
@@ -9941,49 +9939,52 @@
     __pyx_L3_error:;
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "View.MemoryView":485
+    /* "View.MemoryView":490
  *         try:
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:             # <<<<<<<<<<<<<<
  *             raise ValueError("Unable to convert item to object")
  *         else:
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 485, __pyx_L5_except_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_8 = __Pyx_PyErr_ExceptionMatches(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_ErrFetch(&__pyx_t_1, &__pyx_t_5, &__pyx_t_9);
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 490, __pyx_L5_except_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __pyx_t_8 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_1, __pyx_t_6);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_ErrRestore(__pyx_t_1, __pyx_t_5, __pyx_t_9);
+    __pyx_t_1 = 0; __pyx_t_5 = 0; __pyx_t_9 = 0;
     if (__pyx_t_8) {
       __Pyx_AddTraceback("View.MemoryView.memoryview.convert_item_to_object", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_5, &__pyx_t_9) < 0) __PYX_ERR(2, 485, __pyx_L5_except_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_GOTREF(__pyx_t_5);
+      if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_5, &__pyx_t_1) < 0) __PYX_ERR(2, 490, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_9);
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_GOTREF(__pyx_t_1);
 
-      /* "View.MemoryView":486
+      /* "View.MemoryView":491
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 486, __pyx_L5_except_error)
+      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 491, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_Raise(__pyx_t_6, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __PYX_ERR(2, 486, __pyx_L5_except_error)
+      __PYX_ERR(2, 491, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "View.MemoryView":483
+    /* "View.MemoryView":488
  * 
  *         bytesitem = itemp[:self.view.itemsize]
  *         try:             # <<<<<<<<<<<<<<
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  */
     __Pyx_XGIVEREF(__pyx_t_2);
@@ -9995,15 +9996,15 @@
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_XGIVEREF(__pyx_t_4);
     __Pyx_ExceptionReset(__pyx_t_2, __pyx_t_3, __pyx_t_4);
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":476
+  /* "View.MemoryView":481
  *         self.assign_item_from_object(itemp, value)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -10021,15 +10022,15 @@
   __Pyx_XDECREF(__pyx_v_bytesitem);
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":492
+/* "View.MemoryView":497
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -10052,88 +10053,88 @@
   PyObject *__pyx_t_10 = NULL;
   char *__pyx_t_11;
   char *__pyx_t_12;
   char *__pyx_t_13;
   char *__pyx_t_14;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":495
+  /* "View.MemoryView":500
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  *         import struct             # <<<<<<<<<<<<<<
  *         cdef char c
  *         cdef bytes bytesvalue
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 495, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_struct, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 500, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_struct = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":500
+  /* "View.MemoryView":505
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
   __pyx_t_2 = PyTuple_Check(__pyx_v_value); 
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
-    /* "View.MemoryView":501
+    /* "View.MemoryView":506
  * 
  *         if isinstance(value, tuple):
  *             bytesvalue = struct.pack(self.view.format, *value)             # <<<<<<<<<<<<<<
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 501, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 506, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 501, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 506, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 501, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 506, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 501, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PySequence_Tuple(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 506, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 501, __pyx_L1_error)
+    __pyx_t_6 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 506, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 501, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 506, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(2, 501, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(2, 506, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "View.MemoryView":500
+    /* "View.MemoryView":505
  *         cdef Py_ssize_t i
  * 
  *         if isinstance(value, tuple):             # <<<<<<<<<<<<<<
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":503
+  /* "View.MemoryView":508
  *             bytesvalue = struct.pack(self.view.format, *value)
  *         else:
  *             bytesvalue = struct.pack(self.view.format, value)             # <<<<<<<<<<<<<<
  * 
  *         for i, c in enumerate(bytesvalue):
  */
   /*else*/ {
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 503, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_struct, __pyx_n_s_pack); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 508, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 503, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->view.format); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 508, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_t_5 = NULL;
     __pyx_t_7 = 0;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
@@ -10142,102 +10143,102 @@
         __Pyx_DECREF_SET(__pyx_t_6, function);
         __pyx_t_7 = 1;
       }
     }
     #if CYTHON_FAST_PYCALL
     if (PyFunction_Check(__pyx_t_6)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
-      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 503, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 508, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else
     #endif
     #if CYTHON_FAST_PYCCALL
     if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
       PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_v_value};
-      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 503, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 508, __pyx_L1_error)
       __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     } else
     #endif
     {
-      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 503, __pyx_L1_error)
+      __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 508, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_8);
       if (__pyx_t_5) {
         __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __pyx_t_5 = NULL;
       }
       __Pyx_GIVEREF(__pyx_t_1);
       PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
       __Pyx_INCREF(__pyx_v_value);
       __Pyx_GIVEREF(__pyx_v_value);
       PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_value);
       __pyx_t_1 = 0;
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 503, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 508, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     }
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(2, 503, __pyx_L1_error)
+    if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(2, 508, __pyx_L1_error)
     __pyx_v_bytesvalue = ((PyObject*)__pyx_t_4);
     __pyx_t_4 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":505
+  /* "View.MemoryView":510
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
   __pyx_t_9 = 0;
   if (unlikely(__pyx_v_bytesvalue == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' is not iterable");
-    __PYX_ERR(2, 505, __pyx_L1_error)
+    __PYX_ERR(2, 510, __pyx_L1_error)
   }
   __Pyx_INCREF(__pyx_v_bytesvalue);
   __pyx_t_10 = __pyx_v_bytesvalue;
   __pyx_t_12 = PyBytes_AS_STRING(__pyx_t_10);
   __pyx_t_13 = (__pyx_t_12 + PyBytes_GET_SIZE(__pyx_t_10));
   for (__pyx_t_14 = __pyx_t_12; __pyx_t_14 < __pyx_t_13; __pyx_t_14++) {
     __pyx_t_11 = __pyx_t_14;
     __pyx_v_c = (__pyx_t_11[0]);
 
-    /* "View.MemoryView":506
+    /* "View.MemoryView":511
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
     __pyx_v_i = __pyx_t_9;
 
-    /* "View.MemoryView":505
+    /* "View.MemoryView":510
  *             bytesvalue = struct.pack(self.view.format, value)
  * 
  *         for i, c in enumerate(bytesvalue):             # <<<<<<<<<<<<<<
  *             itemp[i] = c
  * 
  */
     __pyx_t_9 = (__pyx_t_9 + 1);
 
-    /* "View.MemoryView":506
+    /* "View.MemoryView":511
  * 
  *         for i, c in enumerate(bytesvalue):
  *             itemp[i] = c             # <<<<<<<<<<<<<<
  * 
  *     @cname('getbuffer')
  */
     (__pyx_v_itemp[__pyx_v_i]) = __pyx_v_c;
   }
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "View.MemoryView":492
+  /* "View.MemoryView":497
  *             return result
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         """Only used if instantiated manually by the user, or if Cython doesn't
  *         know how to convert the type"""
  */
 
@@ -10257,20 +10258,20 @@
   __Pyx_XDECREF(__pyx_v_struct);
   __Pyx_XDECREF(__pyx_v_bytesvalue);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":509
+/* "View.MemoryView":514
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
- *         if flags & PyBUF_STRIDES:
- *             info.shape = self.view.shape
+ *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
 /* Python wrapper */
 static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 static CYTHON_UNUSED int __pyx_memoryview_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
@@ -10282,274 +10283,331 @@
   return __pyx_r;
 }
 
 static int __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_8__getbuffer__(struct __pyx_memoryview_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
-  Py_ssize_t *__pyx_t_2;
-  char *__pyx_t_3;
-  void *__pyx_t_4;
-  int __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  Py_ssize_t *__pyx_t_4;
+  char *__pyx_t_5;
+  void *__pyx_t_6;
+  int __pyx_t_7;
+  Py_ssize_t __pyx_t_8;
+  if (__pyx_v_info == NULL) {
+    PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
+    return -1;
+  }
   __Pyx_RefNannySetupContext("__getbuffer__", 0);
-  if (__pyx_v_info != NULL) {
-    __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
-    __Pyx_GIVEREF(__pyx_v_info->obj);
+  __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(__pyx_v_info->obj);
+
+  /* "View.MemoryView":515
+ *     @cname('getbuffer')
+ *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
+ * 
+ */
+  __pyx_t_2 = ((__pyx_v_flags & PyBUF_WRITABLE) != 0);
+  if (__pyx_t_2) {
+  } else {
+    __pyx_t_1 = __pyx_t_2;
+    goto __pyx_L4_bool_binop_done;
   }
+  __pyx_t_2 = (__pyx_v_self->view.readonly != 0);
+  __pyx_t_1 = __pyx_t_2;
+  __pyx_L4_bool_binop_done:;
+  if (unlikely(__pyx_t_1)) {
 
-  /* "View.MemoryView":510
+    /* "View.MemoryView":516
+ *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
+ * 
+ *         if flags & PyBUF_ND:
+ */
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 516, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __PYX_ERR(2, 516, __pyx_L1_error)
+
+    /* "View.MemoryView":515
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):
- *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
+ *         if flags & PyBUF_WRITABLE and self.view.readonly:             # <<<<<<<<<<<<<<
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
+ * 
+ */
+  }
+
+  /* "View.MemoryView":518
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
+ * 
+ *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
-  __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
+  __pyx_t_1 = ((__pyx_v_flags & PyBUF_ND) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":511
- *     def __getbuffer__(self, Py_buffer *info, int flags):
- *         if flags & PyBUF_STRIDES:
+    /* "View.MemoryView":519
+ * 
+ *         if flags & PyBUF_ND:
  *             info.shape = self.view.shape             # <<<<<<<<<<<<<<
  *         else:
  *             info.shape = NULL
  */
-    __pyx_t_2 = __pyx_v_self->view.shape;
-    __pyx_v_info->shape = __pyx_t_2;
+    __pyx_t_4 = __pyx_v_self->view.shape;
+    __pyx_v_info->shape = __pyx_t_4;
 
-    /* "View.MemoryView":510
- *     @cname('getbuffer')
- *     def __getbuffer__(self, Py_buffer *info, int flags):
- *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
+    /* "View.MemoryView":518
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
+ * 
+ *         if flags & PyBUF_ND:             # <<<<<<<<<<<<<<
  *             info.shape = self.view.shape
  *         else:
  */
-    goto __pyx_L3;
+    goto __pyx_L6;
   }
 
-  /* "View.MemoryView":513
+  /* "View.MemoryView":521
  *             info.shape = self.view.shape
  *         else:
  *             info.shape = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_STRIDES:
  */
   /*else*/ {
     __pyx_v_info->shape = NULL;
   }
-  __pyx_L3:;
+  __pyx_L6:;
 
-  /* "View.MemoryView":515
+  /* "View.MemoryView":523
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_STRIDES) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":516
+    /* "View.MemoryView":524
  * 
  *         if flags & PyBUF_STRIDES:
  *             info.strides = self.view.strides             # <<<<<<<<<<<<<<
  *         else:
  *             info.strides = NULL
  */
-    __pyx_t_2 = __pyx_v_self->view.strides;
-    __pyx_v_info->strides = __pyx_t_2;
+    __pyx_t_4 = __pyx_v_self->view.strides;
+    __pyx_v_info->strides = __pyx_t_4;
 
-    /* "View.MemoryView":515
+    /* "View.MemoryView":523
  *             info.shape = NULL
  * 
  *         if flags & PyBUF_STRIDES:             # <<<<<<<<<<<<<<
  *             info.strides = self.view.strides
  *         else:
  */
-    goto __pyx_L4;
+    goto __pyx_L7;
   }
 
-  /* "View.MemoryView":518
+  /* "View.MemoryView":526
  *             info.strides = self.view.strides
  *         else:
  *             info.strides = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_INDIRECT:
  */
   /*else*/ {
     __pyx_v_info->strides = NULL;
   }
-  __pyx_L4:;
+  __pyx_L7:;
 
-  /* "View.MemoryView":520
+  /* "View.MemoryView":528
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_INDIRECT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":521
+    /* "View.MemoryView":529
  * 
  *         if flags & PyBUF_INDIRECT:
  *             info.suboffsets = self.view.suboffsets             # <<<<<<<<<<<<<<
  *         else:
  *             info.suboffsets = NULL
  */
-    __pyx_t_2 = __pyx_v_self->view.suboffsets;
-    __pyx_v_info->suboffsets = __pyx_t_2;
+    __pyx_t_4 = __pyx_v_self->view.suboffsets;
+    __pyx_v_info->suboffsets = __pyx_t_4;
 
-    /* "View.MemoryView":520
+    /* "View.MemoryView":528
  *             info.strides = NULL
  * 
  *         if flags & PyBUF_INDIRECT:             # <<<<<<<<<<<<<<
  *             info.suboffsets = self.view.suboffsets
  *         else:
  */
-    goto __pyx_L5;
+    goto __pyx_L8;
   }
 
-  /* "View.MemoryView":523
+  /* "View.MemoryView":531
  *             info.suboffsets = self.view.suboffsets
  *         else:
  *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
  * 
  *         if flags & PyBUF_FORMAT:
  */
   /*else*/ {
     __pyx_v_info->suboffsets = NULL;
   }
-  __pyx_L5:;
+  __pyx_L8:;
 
-  /* "View.MemoryView":525
+  /* "View.MemoryView":533
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_flags & PyBUF_FORMAT) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":526
+    /* "View.MemoryView":534
  * 
  *         if flags & PyBUF_FORMAT:
  *             info.format = self.view.format             # <<<<<<<<<<<<<<
  *         else:
  *             info.format = NULL
  */
-    __pyx_t_3 = __pyx_v_self->view.format;
-    __pyx_v_info->format = __pyx_t_3;
+    __pyx_t_5 = __pyx_v_self->view.format;
+    __pyx_v_info->format = __pyx_t_5;
 
-    /* "View.MemoryView":525
+    /* "View.MemoryView":533
  *             info.suboffsets = NULL
  * 
  *         if flags & PyBUF_FORMAT:             # <<<<<<<<<<<<<<
  *             info.format = self.view.format
  *         else:
  */
-    goto __pyx_L6;
+    goto __pyx_L9;
   }
 
-  /* "View.MemoryView":528
+  /* "View.MemoryView":536
  *             info.format = self.view.format
  *         else:
  *             info.format = NULL             # <<<<<<<<<<<<<<
  * 
  *         info.buf = self.view.buf
  */
   /*else*/ {
     __pyx_v_info->format = NULL;
   }
-  __pyx_L6:;
+  __pyx_L9:;
 
-  /* "View.MemoryView":530
+  /* "View.MemoryView":538
  *             info.format = NULL
  * 
  *         info.buf = self.view.buf             # <<<<<<<<<<<<<<
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  */
-  __pyx_t_4 = __pyx_v_self->view.buf;
-  __pyx_v_info->buf = __pyx_t_4;
+  __pyx_t_6 = __pyx_v_self->view.buf;
+  __pyx_v_info->buf = __pyx_t_6;
 
-  /* "View.MemoryView":531
+  /* "View.MemoryView":539
  * 
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim             # <<<<<<<<<<<<<<
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
  */
-  __pyx_t_5 = __pyx_v_self->view.ndim;
-  __pyx_v_info->ndim = __pyx_t_5;
+  __pyx_t_7 = __pyx_v_self->view.ndim;
+  __pyx_v_info->ndim = __pyx_t_7;
 
-  /* "View.MemoryView":532
+  /* "View.MemoryView":540
  *         info.buf = self.view.buf
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize             # <<<<<<<<<<<<<<
  *         info.len = self.view.len
- *         info.readonly = 0
+ *         info.readonly = self.view.readonly
  */
-  __pyx_t_6 = __pyx_v_self->view.itemsize;
-  __pyx_v_info->itemsize = __pyx_t_6;
+  __pyx_t_8 = __pyx_v_self->view.itemsize;
+  __pyx_v_info->itemsize = __pyx_t_8;
 
-  /* "View.MemoryView":533
+  /* "View.MemoryView":541
  *         info.ndim = self.view.ndim
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len             # <<<<<<<<<<<<<<
- *         info.readonly = 0
+ *         info.readonly = self.view.readonly
  *         info.obj = self
  */
-  __pyx_t_6 = __pyx_v_self->view.len;
-  __pyx_v_info->len = __pyx_t_6;
+  __pyx_t_8 = __pyx_v_self->view.len;
+  __pyx_v_info->len = __pyx_t_8;
 
-  /* "View.MemoryView":534
+  /* "View.MemoryView":542
  *         info.itemsize = self.view.itemsize
  *         info.len = self.view.len
- *         info.readonly = 0             # <<<<<<<<<<<<<<
+ *         info.readonly = self.view.readonly             # <<<<<<<<<<<<<<
  *         info.obj = self
  * 
  */
-  __pyx_v_info->readonly = 0;
+  __pyx_t_1 = __pyx_v_self->view.readonly;
+  __pyx_v_info->readonly = __pyx_t_1;
 
-  /* "View.MemoryView":535
+  /* "View.MemoryView":543
  *         info.len = self.view.len
- *         info.readonly = 0
+ *         info.readonly = self.view.readonly
  *         info.obj = self             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
   __Pyx_GOTREF(__pyx_v_info->obj);
   __Pyx_DECREF(__pyx_v_info->obj);
   __pyx_v_info->obj = ((PyObject *)__pyx_v_self);
 
-  /* "View.MemoryView":509
+  /* "View.MemoryView":514
  * 
  *     @cname('getbuffer')
  *     def __getbuffer__(self, Py_buffer *info, int flags):             # <<<<<<<<<<<<<<
- *         if flags & PyBUF_STRIDES:
- *             info.shape = self.view.shape
+ *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")
  */
 
   /* function exit code */
   __pyx_r = 0;
-  if (__pyx_v_info != NULL && __pyx_v_info->obj == Py_None) {
-    __Pyx_GOTREF(Py_None);
-    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("View.MemoryView.memoryview.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  if (__pyx_v_info->obj != NULL) {
+    __Pyx_GOTREF(__pyx_v_info->obj);
+    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
   }
+  goto __pyx_L2;
+  __pyx_L0:;
+  if (__pyx_v_info->obj == Py_None) {
+    __Pyx_GOTREF(__pyx_v_info->obj);
+    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
+  }
+  __pyx_L2:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":541
+/* "View.MemoryView":549
  * 
  *     @property
  *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  */
 
@@ -10570,49 +10628,49 @@
   struct __pyx_memoryviewslice_obj *__pyx_v_result = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_t_2;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":542
+  /* "View.MemoryView":550
  *     @property
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&result.from_slice)
  *         return result
  */
-  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 542, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 550, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(2, 542, __pyx_L1_error)
+  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_memoryviewslice_type))))) __PYX_ERR(2, 550, __pyx_L1_error)
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":543
+  /* "View.MemoryView":551
  *     def T(self):
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)             # <<<<<<<<<<<<<<
  *         return result
  * 
  */
-  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(2, 543, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memslice_transpose((&__pyx_v_result->from_slice)); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(2, 551, __pyx_L1_error)
 
-  /* "View.MemoryView":544
+  /* "View.MemoryView":552
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  *         return result             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":541
+  /* "View.MemoryView":549
  * 
  *     @property
  *     def T(self):             # <<<<<<<<<<<<<<
  *         cdef _memoryviewslice result = memoryview_copy(self)
  *         transpose_memslice(&result.from_slice)
  */
 
@@ -10624,15 +10682,15 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":547
+/* "View.MemoryView":555
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
  * 
  */
 
@@ -10650,42 +10708,42 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_4base___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":548
+  /* "View.MemoryView":556
  *     @property
  *     def base(self):
  *         return self.obj             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->obj);
   __pyx_r = __pyx_v_self->obj;
   goto __pyx_L0;
 
-  /* "View.MemoryView":547
+  /* "View.MemoryView":555
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.obj
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":551
+/* "View.MemoryView":559
  * 
  *     @property
  *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
  * 
  */
 
@@ -10709,41 +10767,41 @@
   PyObject *__pyx_t_1 = NULL;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":552
+  /* "View.MemoryView":560
  *     @property
  *     def shape(self):
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 552, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 560, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_3 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
   for (__pyx_t_4 = __pyx_v_self->view.shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++) {
     __pyx_t_2 = __pyx_t_4;
     __pyx_v_length = (__pyx_t_2[0]);
-    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 552, __pyx_L1_error)
+    __pyx_t_5 = PyInt_FromSsize_t(__pyx_v_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 560, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(2, 552, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_5))) __PYX_ERR(2, 560, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 552, __pyx_L1_error)
+  __pyx_t_5 = PyList_AsTuple(((PyObject*)__pyx_t_1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 560, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":551
+  /* "View.MemoryView":559
  * 
  *     @property
  *     def shape(self):             # <<<<<<<<<<<<<<
  *         return tuple([length for length in self.view.shape[:self.view.ndim]])
  * 
  */
 
@@ -10755,15 +10813,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":555
+/* "View.MemoryView":563
  * 
  *     @property
  *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
  * 
  */
 
@@ -10788,73 +10846,73 @@
   PyObject *__pyx_t_2 = NULL;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
   Py_ssize_t *__pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":556
+  /* "View.MemoryView":564
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
  *             raise ValueError("Buffer view does not expose strides")
  */
   __pyx_t_1 = ((__pyx_v_self->view.strides == NULL) != 0);
-  if (__pyx_t_1) {
+  if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":558
+    /* "View.MemoryView":566
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 558, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 566, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(2, 558, __pyx_L1_error)
+    __PYX_ERR(2, 566, __pyx_L1_error)
 
-    /* "View.MemoryView":556
+    /* "View.MemoryView":564
  *     @property
  *     def strides(self):
  *         if self.view.strides == NULL:             # <<<<<<<<<<<<<<
  * 
  *             raise ValueError("Buffer view does not expose strides")
  */
   }
 
-  /* "View.MemoryView":560
+  /* "View.MemoryView":568
  *             raise ValueError("Buffer view does not expose strides")
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 560, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 568, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = (__pyx_v_self->view.strides + __pyx_v_self->view.ndim);
   for (__pyx_t_5 = __pyx_v_self->view.strides; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
     __pyx_t_3 = __pyx_t_5;
     __pyx_v_stride = (__pyx_t_3[0]);
-    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 560, __pyx_L1_error)
+    __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_stride); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 568, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(2, 560, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_6))) __PYX_ERR(2, 568, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
-  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 560, __pyx_L1_error)
+  __pyx_t_6 = PyList_AsTuple(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 568, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_6;
   __pyx_t_6 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":555
+  /* "View.MemoryView":563
  * 
  *     @property
  *     def strides(self):             # <<<<<<<<<<<<<<
  *         if self.view.strides == NULL:
  * 
  */
 
@@ -10866,15 +10924,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":563
+/* "View.MemoryView":571
  * 
  *     @property
  *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim
  */
 
@@ -10899,77 +10957,77 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   Py_ssize_t *__pyx_t_4;
   Py_ssize_t *__pyx_t_5;
   Py_ssize_t *__pyx_t_6;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":564
+  /* "View.MemoryView":572
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
   __pyx_t_1 = ((__pyx_v_self->view.suboffsets == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":565
+    /* "View.MemoryView":573
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 565, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 573, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__20, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 565, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_Multiply(__pyx_tuple__19, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 573, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":564
+    /* "View.MemoryView":572
  *     @property
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:             # <<<<<<<<<<<<<<
  *             return (-1,) * self.view.ndim
  * 
  */
   }
 
-  /* "View.MemoryView":567
+  /* "View.MemoryView":575
  *             return (-1,) * self.view.ndim
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 567, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 575, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_5 = (__pyx_v_self->view.suboffsets + __pyx_v_self->view.ndim);
   for (__pyx_t_6 = __pyx_v_self->view.suboffsets; __pyx_t_6 < __pyx_t_5; __pyx_t_6++) {
     __pyx_t_4 = __pyx_t_6;
     __pyx_v_suboffset = (__pyx_t_4[0]);
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 567, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_suboffset); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 575, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(2, 567, __pyx_L1_error)
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_2))) __PYX_ERR(2, 575, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   }
-  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 567, __pyx_L1_error)
+  __pyx_t_2 = PyList_AsTuple(((PyObject*)__pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 575, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":563
+  /* "View.MemoryView":571
  * 
  *     @property
  *     def suboffsets(self):             # <<<<<<<<<<<<<<
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim
  */
 
@@ -10981,15 +11039,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":570
+/* "View.MemoryView":578
  * 
  *     @property
  *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
  * 
  */
 
@@ -11008,29 +11066,29 @@
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_4ndim___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":571
+  /* "View.MemoryView":579
  *     @property
  *     def ndim(self):
  *         return self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 571, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->view.ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 579, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":570
+  /* "View.MemoryView":578
  * 
  *     @property
  *     def ndim(self):             # <<<<<<<<<<<<<<
  *         return self.view.ndim
  * 
  */
 
@@ -11041,15 +11099,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":574
+/* "View.MemoryView":582
  * 
  *     @property
  *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
  * 
  */
 
@@ -11068,29 +11126,29 @@
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_10memoryview_8itemsize___get__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":575
+  /* "View.MemoryView":583
  *     @property
  *     def itemsize(self):
  *         return self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 575, __pyx_L1_error)
+  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 583, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":574
+  /* "View.MemoryView":582
  * 
  *     @property
  *     def itemsize(self):             # <<<<<<<<<<<<<<
  *         return self.view.itemsize
  * 
  */
 
@@ -11101,15 +11159,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":578
+/* "View.MemoryView":586
  * 
  *     @property
  *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
  * 
  */
 
@@ -11130,35 +11188,35 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":579
+  /* "View.MemoryView":587
  *     @property
  *     def nbytes(self):
  *         return self.size * self.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 579, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 579, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->view.itemsize); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 579, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Multiply(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 587, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":578
+  /* "View.MemoryView":586
  * 
  *     @property
  *     def nbytes(self):             # <<<<<<<<<<<<<<
  *         return self.size * self.view.itemsize
  * 
  */
 
@@ -11171,15 +11229,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":582
+/* "View.MemoryView":590
  * 
  *     @property
  *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
  *             result = 1
  */
 
@@ -11205,98 +11263,98 @@
   int __pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   Py_ssize_t *__pyx_t_4;
   Py_ssize_t *__pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":583
+  /* "View.MemoryView":591
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   __pyx_t_1 = (__pyx_v_self->_size == Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":584
+    /* "View.MemoryView":592
  *     def size(self):
  *         if self._size is None:
  *             result = 1             # <<<<<<<<<<<<<<
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  */
     __Pyx_INCREF(__pyx_int_1);
     __pyx_v_result = __pyx_int_1;
 
-    /* "View.MemoryView":586
+    /* "View.MemoryView":594
  *             result = 1
  * 
  *             for length in self.view.shape[:self.view.ndim]:             # <<<<<<<<<<<<<<
  *                 result *= length
  * 
  */
     __pyx_t_4 = (__pyx_v_self->view.shape + __pyx_v_self->view.ndim);
     for (__pyx_t_5 = __pyx_v_self->view.shape; __pyx_t_5 < __pyx_t_4; __pyx_t_5++) {
       __pyx_t_3 = __pyx_t_5;
-      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 586, __pyx_L1_error)
+      __pyx_t_6 = PyInt_FromSsize_t((__pyx_t_3[0])); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 594, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_6);
       __pyx_t_6 = 0;
 
-      /* "View.MemoryView":587
+      /* "View.MemoryView":595
  * 
  *             for length in self.view.shape[:self.view.ndim]:
  *                 result *= length             # <<<<<<<<<<<<<<
  * 
  *             self._size = result
  */
-      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 587, __pyx_L1_error)
+      __pyx_t_6 = PyNumber_InPlaceMultiply(__pyx_v_result, __pyx_v_length); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 595, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_6);
       __pyx_t_6 = 0;
     }
 
-    /* "View.MemoryView":589
+    /* "View.MemoryView":597
  *                 result *= length
  * 
  *             self._size = result             # <<<<<<<<<<<<<<
  * 
  *         return self._size
  */
     __Pyx_INCREF(__pyx_v_result);
     __Pyx_GIVEREF(__pyx_v_result);
     __Pyx_GOTREF(__pyx_v_self->_size);
     __Pyx_DECREF(__pyx_v_self->_size);
     __pyx_v_self->_size = __pyx_v_result;
 
-    /* "View.MemoryView":583
+    /* "View.MemoryView":591
  *     @property
  *     def size(self):
  *         if self._size is None:             # <<<<<<<<<<<<<<
  *             result = 1
  * 
  */
   }
 
-  /* "View.MemoryView":591
+  /* "View.MemoryView":599
  *             self._size = result
  * 
  *         return self._size             # <<<<<<<<<<<<<<
  * 
  *     def __len__(self):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->_size);
   __pyx_r = __pyx_v_self->_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":582
+  /* "View.MemoryView":590
  * 
  *     @property
  *     def size(self):             # <<<<<<<<<<<<<<
  *         if self._size is None:
  *             result = 1
  */
 
@@ -11309,15 +11367,15 @@
   __Pyx_XDECREF(__pyx_v_result);
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":593
+/* "View.MemoryView":601
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
@@ -11336,68 +11394,68 @@
 
 static Py_ssize_t __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_10__len__(struct __pyx_memoryview_obj *__pyx_v_self) {
   Py_ssize_t __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("__len__", 0);
 
-  /* "View.MemoryView":594
+  /* "View.MemoryView":602
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
   __pyx_t_1 = ((__pyx_v_self->view.ndim >= 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":595
+    /* "View.MemoryView":603
  *     def __len__(self):
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]             # <<<<<<<<<<<<<<
  * 
  *         return 0
  */
     __pyx_r = (__pyx_v_self->view.shape[0]);
     goto __pyx_L0;
 
-    /* "View.MemoryView":594
+    /* "View.MemoryView":602
  * 
  *     def __len__(self):
  *         if self.view.ndim >= 1:             # <<<<<<<<<<<<<<
  *             return self.view.shape[0]
  * 
  */
   }
 
-  /* "View.MemoryView":597
+  /* "View.MemoryView":605
  *             return self.view.shape[0]
  * 
  *         return 0             # <<<<<<<<<<<<<<
  * 
  *     def __repr__(self):
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":593
+  /* "View.MemoryView":601
  *         return self._size
  * 
  *     def __len__(self):             # <<<<<<<<<<<<<<
  *         if self.view.ndim >= 1:
  *             return self.view.shape[0]
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":599
+/* "View.MemoryView":607
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
@@ -11418,70 +11476,64 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "View.MemoryView":600
+  /* "View.MemoryView":608
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 600, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 600, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 600, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 608, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":601
+  /* "View.MemoryView":609
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))             # <<<<<<<<<<<<<<
  * 
  *     def __str__(self):
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 601, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_id, ((PyObject *)__pyx_v_self)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 609, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_INCREF(((PyObject *)__pyx_v_self));
-  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
-  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_self));
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_id, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 601, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "View.MemoryView":600
+  /* "View.MemoryView":608
  * 
  *     def __repr__(self):
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,             # <<<<<<<<<<<<<<
  *                                                id(self))
  * 
  */
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 600, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 608, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
-  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
-  __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_2);
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
   __pyx_t_1 = 0;
-  __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 600, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_r = __pyx_t_3;
-  __pyx_t_3 = 0;
+  __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 608, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":599
+  /* "View.MemoryView":607
  *         return 0
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r at 0x%x>" % (self.base.__class__.__name__,
  *                                                id(self))
  */
 
@@ -11494,15 +11546,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":603
+/* "View.MemoryView":611
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
@@ -11522,43 +11574,43 @@
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_14__str__(struct __pyx_memoryview_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   __Pyx_RefNannySetupContext("__str__", 0);
 
-  /* "View.MemoryView":604
+  /* "View.MemoryView":612
  * 
  *     def __str__(self):
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 604, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 604, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 604, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 604, __pyx_L1_error)
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 604, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_MemoryView_of_r_object, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 612, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":603
+  /* "View.MemoryView":611
  *                                                id(self))
  * 
  *     def __str__(self):             # <<<<<<<<<<<<<<
  *         return "<MemoryView of %r object>" % (self.base.__class__.__name__,)
  * 
  */
 
@@ -11570,15 +11622,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":607
+/* "View.MemoryView":615
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -11599,38 +11651,38 @@
   __Pyx_memviewslice *__pyx_v_mslice;
   __Pyx_memviewslice __pyx_v_tmp;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("is_c_contig", 0);
 
-  /* "View.MemoryView":610
+  /* "View.MemoryView":618
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  */
   __pyx_v_mslice = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp));
 
-  /* "View.MemoryView":611
+  /* "View.MemoryView":619
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def is_f_contig(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 611, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'C', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 619, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":607
+  /* "View.MemoryView":615
  * 
  * 
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -11641,15 +11693,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":613
+/* "View.MemoryView":621
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -11670,38 +11722,38 @@
   __Pyx_memviewslice *__pyx_v_mslice;
   __Pyx_memviewslice __pyx_v_tmp;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("is_f_contig", 0);
 
-  /* "View.MemoryView":616
+  /* "View.MemoryView":624
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)             # <<<<<<<<<<<<<<
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  */
   __pyx_v_mslice = __pyx_memoryview_get_slice_from_memoryview(__pyx_v_self, (&__pyx_v_tmp));
 
-  /* "View.MemoryView":617
+  /* "View.MemoryView":625
  *         cdef __Pyx_memviewslice tmp
  *         mslice = get_slice_from_memview(self, &tmp)
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)             # <<<<<<<<<<<<<<
  * 
  *     def copy(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 617, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_memviewslice_is_contig((__pyx_v_mslice[0]), 'F', __pyx_v_self->view.ndim)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 625, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":613
+  /* "View.MemoryView":621
  *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
  * 
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
@@ -11712,15 +11764,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":619
+/* "View.MemoryView":627
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
@@ -11742,57 +11794,57 @@
   int __pyx_v_flags;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   __Pyx_RefNannySetupContext("copy", 0);
 
-  /* "View.MemoryView":621
+  /* "View.MemoryView":629
  *     def copy(self):
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &mslice)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_F_CONTIGUOUS));
 
-  /* "View.MemoryView":623
+  /* "View.MemoryView":631
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  * 
  *         slice_copy(self, &mslice)             # <<<<<<<<<<<<<<
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,
  *                                    self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_mslice));
 
-  /* "View.MemoryView":624
+  /* "View.MemoryView":632
  * 
  *         slice_copy(self, &mslice)
  *         mslice = slice_copy_contig(&mslice, "c", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                    self.view.itemsize,
  *                                    flags|PyBUF_C_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 624, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_mslice), ((char *)"c"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_C_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 632, __pyx_L1_error)
   __pyx_v_mslice = __pyx_t_1;
 
-  /* "View.MemoryView":629
+  /* "View.MemoryView":637
  *                                    self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &mslice)             # <<<<<<<<<<<<<<
  * 
  *     def copy_fortran(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 629, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_mslice)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 637, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":619
+  /* "View.MemoryView":627
  *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
  * 
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
@@ -11803,15 +11855,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":631
+/* "View.MemoryView":639
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
@@ -11834,57 +11886,57 @@
   int __pyx_v_flags;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_memviewslice __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   __Pyx_RefNannySetupContext("copy_fortran", 0);
 
-  /* "View.MemoryView":633
+  /* "View.MemoryView":641
  *     def copy_fortran(self):
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS             # <<<<<<<<<<<<<<
  * 
  *         slice_copy(self, &src)
  */
   __pyx_v_flags = (__pyx_v_self->flags & (~PyBUF_C_CONTIGUOUS));
 
-  /* "View.MemoryView":635
+  /* "View.MemoryView":643
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  * 
  *         slice_copy(self, &src)             # <<<<<<<<<<<<<<
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,
  *                                 self.view.itemsize,
  */
   __pyx_memoryview_slice_copy(__pyx_v_self, (&__pyx_v_src));
 
-  /* "View.MemoryView":636
+  /* "View.MemoryView":644
  * 
  *         slice_copy(self, &src)
  *         dst = slice_copy_contig(&src, "fortran", self.view.ndim,             # <<<<<<<<<<<<<<
  *                                 self.view.itemsize,
  *                                 flags|PyBUF_F_CONTIGUOUS,
  */
-  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 636, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_new_contig((&__pyx_v_src), ((char *)"fortran"), __pyx_v_self->view.ndim, __pyx_v_self->view.itemsize, (__pyx_v_flags | PyBUF_F_CONTIGUOUS), __pyx_v_self->dtype_is_object); if (unlikely(PyErr_Occurred())) __PYX_ERR(2, 644, __pyx_L1_error)
   __pyx_v_dst = __pyx_t_1;
 
-  /* "View.MemoryView":641
+  /* "View.MemoryView":649
  *                                 self.dtype_is_object)
  * 
  *         return memoryview_copy_from_slice(self, &dst)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 641, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_copy_object_from_slice(__pyx_v_self, (&__pyx_v_dst)); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 649, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":631
+  /* "View.MemoryView":639
  *         return memoryview_copy_from_slice(self, &mslice)
  * 
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
@@ -11926,15 +11978,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(2, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -11979,15 +12031,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(2, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -12002,15 +12054,15 @@
   __Pyx_AddTraceback("View.MemoryView.memoryview.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":645
+/* "View.MemoryView":653
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -12019,64 +12071,64 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   __Pyx_RefNannySetupContext("memoryview_cwrapper", 0);
 
-  /* "View.MemoryView":646
+  /* "View.MemoryView":654
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)             # <<<<<<<<<<<<<<
  *     result.typeinfo = typeinfo
  *     return result
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 646, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_flags); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 654, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 646, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 654, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 646, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 654, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(__pyx_v_o);
   __Pyx_GIVEREF(__pyx_v_o);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_o);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 646, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryview_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 654, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryview_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":647
+  /* "View.MemoryView":655
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo             # <<<<<<<<<<<<<<
  *     return result
  * 
  */
   __pyx_v_result->typeinfo = __pyx_v_typeinfo;
 
-  /* "View.MemoryView":648
+  /* "View.MemoryView":656
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_check')
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":645
+  /* "View.MemoryView":653
  * 
  * @cname('__pyx_memoryview_new')
  * cdef memoryview_cwrapper(object o, int flags, bint dtype_is_object, __Pyx_TypeInfo *typeinfo):             # <<<<<<<<<<<<<<
  *     cdef memoryview result = memoryview(o, flags, dtype_is_object)
  *     result.typeinfo = typeinfo
  */
 
@@ -12090,54 +12142,54 @@
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":651
+/* "View.MemoryView":659
  * 
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *__pyx_v_o) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("memoryview_check", 0);
 
-  /* "View.MemoryView":652
+  /* "View.MemoryView":660
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):
  *     return isinstance(o, memoryview)             # <<<<<<<<<<<<<<
  * 
  * cdef tuple _unellipsify(object index, int ndim):
  */
   __pyx_t_1 = __Pyx_TypeCheck(__pyx_v_o, __pyx_memoryview_type); 
   __pyx_r = __pyx_t_1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":651
+  /* "View.MemoryView":659
  * 
  * @cname('__pyx_memoryview_check')
  * cdef inline bint memoryview_check(object o):             # <<<<<<<<<<<<<<
  *     return isinstance(o, memoryview)
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":654
+/* "View.MemoryView":662
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
@@ -12160,243 +12212,243 @@
   PyObject *__pyx_t_7 = NULL;
   Py_ssize_t __pyx_t_8;
   int __pyx_t_9;
   int __pyx_t_10;
   PyObject *__pyx_t_11 = NULL;
   __Pyx_RefNannySetupContext("_unellipsify", 0);
 
-  /* "View.MemoryView":659
+  /* "View.MemoryView":667
  *     full slices.
  *     """
  *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
  *         tup = (index,)
  *     else:
  */
   __pyx_t_1 = PyTuple_Check(__pyx_v_index); 
   __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":660
+    /* "View.MemoryView":668
  *     """
  *     if not isinstance(index, tuple):
  *         tup = (index,)             # <<<<<<<<<<<<<<
  *     else:
  *         tup = index
  */
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 660, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 668, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_index);
     __Pyx_GIVEREF(__pyx_v_index);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_index);
     __pyx_v_tup = __pyx_t_3;
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":659
+    /* "View.MemoryView":667
  *     full slices.
  *     """
  *     if not isinstance(index, tuple):             # <<<<<<<<<<<<<<
  *         tup = (index,)
  *     else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":662
+  /* "View.MemoryView":670
  *         tup = (index,)
  *     else:
  *         tup = index             # <<<<<<<<<<<<<<
  * 
  *     result = []
  */
   /*else*/ {
     __Pyx_INCREF(__pyx_v_index);
     __pyx_v_tup = __pyx_v_index;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":664
+  /* "View.MemoryView":672
  *         tup = index
  * 
  *     result = []             # <<<<<<<<<<<<<<
  *     have_slices = False
  *     seen_ellipsis = False
  */
-  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 664, __pyx_L1_error)
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 672, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_v_result = ((PyObject*)__pyx_t_3);
   __pyx_t_3 = 0;
 
-  /* "View.MemoryView":665
+  /* "View.MemoryView":673
  * 
  *     result = []
  *     have_slices = False             # <<<<<<<<<<<<<<
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  */
   __pyx_v_have_slices = 0;
 
-  /* "View.MemoryView":666
+  /* "View.MemoryView":674
  *     result = []
  *     have_slices = False
  *     seen_ellipsis = False             # <<<<<<<<<<<<<<
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  */
   __pyx_v_seen_ellipsis = 0;
 
-  /* "View.MemoryView":667
+  /* "View.MemoryView":675
  *     have_slices = False
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
   __Pyx_INCREF(__pyx_int_0);
   __pyx_t_3 = __pyx_int_0;
   if (likely(PyList_CheckExact(__pyx_v_tup)) || PyTuple_CheckExact(__pyx_v_tup)) {
     __pyx_t_4 = __pyx_v_tup; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
     __pyx_t_6 = NULL;
   } else {
-    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 667, __pyx_L1_error)
+    __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_tup); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 675, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 667, __pyx_L1_error)
+    __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 675, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_6)) {
       if (likely(PyList_CheckExact(__pyx_t_4))) {
         if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(2, 667, __pyx_L1_error)
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(2, 675, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 667, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 675, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       } else {
         if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(2, 667, __pyx_L1_error)
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(2, 675, __pyx_L1_error)
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 667, __pyx_L1_error)
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 675, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       }
     } else {
       __pyx_t_7 = __pyx_t_6(__pyx_t_4);
       if (unlikely(!__pyx_t_7)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(2, 667, __pyx_L1_error)
+          else __PYX_ERR(2, 675, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_7);
     }
     __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_7);
     __pyx_t_7 = 0;
     __Pyx_INCREF(__pyx_t_3);
     __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_3);
-    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 667, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_3, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 675, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_3);
     __pyx_t_3 = __pyx_t_7;
     __pyx_t_7 = 0;
 
-    /* "View.MemoryView":668
+    /* "View.MemoryView":676
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
     __pyx_t_2 = (__pyx_v_item == __pyx_builtin_Ellipsis);
     __pyx_t_1 = (__pyx_t_2 != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":669
+      /* "View.MemoryView":677
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
       __pyx_t_1 = ((!(__pyx_v_seen_ellipsis != 0)) != 0);
       if (__pyx_t_1) {
 
-        /* "View.MemoryView":670
+        /* "View.MemoryView":678
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(2, 670, __pyx_L1_error)
-        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 670, __pyx_L1_error)
+        __pyx_t_8 = PyObject_Length(__pyx_v_tup); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(2, 678, __pyx_L1_error)
+        __pyx_t_7 = PyList_New(1 * ((((__pyx_v_ndim - __pyx_t_8) + 1)<0) ? 0:((__pyx_v_ndim - __pyx_t_8) + 1))); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 678, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         { Py_ssize_t __pyx_temp;
           for (__pyx_temp=0; __pyx_temp < ((__pyx_v_ndim - __pyx_t_8) + 1); __pyx_temp++) {
-            __Pyx_INCREF(__pyx_slice__23);
-            __Pyx_GIVEREF(__pyx_slice__23);
-            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__23);
+            __Pyx_INCREF(__pyx_slice__22);
+            __Pyx_GIVEREF(__pyx_slice__22);
+            PyList_SET_ITEM(__pyx_t_7, __pyx_temp, __pyx_slice__22);
           }
         }
-        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 670, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_7); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 678, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-        /* "View.MemoryView":671
+        /* "View.MemoryView":679
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True             # <<<<<<<<<<<<<<
  *             else:
  *                 result.append(slice(None))
  */
         __pyx_v_seen_ellipsis = 1;
 
-        /* "View.MemoryView":669
+        /* "View.MemoryView":677
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:
  *             if not seen_ellipsis:             # <<<<<<<<<<<<<<
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  *                 seen_ellipsis = True
  */
         goto __pyx_L7;
       }
 
-      /* "View.MemoryView":673
+      /* "View.MemoryView":681
  *                 seen_ellipsis = True
  *             else:
  *                 result.append(slice(None))             # <<<<<<<<<<<<<<
  *             have_slices = True
  *         else:
  */
       /*else*/ {
-        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__24); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 673, __pyx_L1_error)
+        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_slice__22); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 681, __pyx_L1_error)
       }
       __pyx_L7:;
 
-      /* "View.MemoryView":674
+      /* "View.MemoryView":682
  *             else:
  *                 result.append(slice(None))
  *             have_slices = True             # <<<<<<<<<<<<<<
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):
  */
       __pyx_v_have_slices = 1;
 
-      /* "View.MemoryView":668
+      /* "View.MemoryView":676
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):
  *         if item is Ellipsis:             # <<<<<<<<<<<<<<
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":676
+    /* "View.MemoryView":684
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  */
     /*else*/ {
@@ -12406,47 +12458,42 @@
       } else {
         __pyx_t_1 = __pyx_t_10;
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_10 = ((!(PyIndex_Check(__pyx_v_item) != 0)) != 0);
       __pyx_t_1 = __pyx_t_10;
       __pyx_L9_bool_binop_done:;
-      if (__pyx_t_1) {
+      if (unlikely(__pyx_t_1)) {
 
-        /* "View.MemoryView":677
+        /* "View.MemoryView":685
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):
  *                 raise TypeError("Cannot index with type '%s'" % type(item))             # <<<<<<<<<<<<<<
  * 
  *             have_slices = have_slices or isinstance(item, slice)
  */
-        __pyx_t_7 = __Pyx_PyString_Format(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 677, __pyx_L1_error)
+        __pyx_t_7 = __Pyx_PyString_FormatSafe(__pyx_kp_s_Cannot_index_with_type_s, ((PyObject *)Py_TYPE(__pyx_v_item))); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 685, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
-        __pyx_t_11 = PyTuple_New(1); if (unlikely(!__pyx_t_11)) __PYX_ERR(2, 677, __pyx_L1_error)
+        __pyx_t_11 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(2, 685, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_11);
-        __Pyx_GIVEREF(__pyx_t_7);
-        PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_7);
-        __pyx_t_7 = 0;
-        __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_t_11, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 677, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_7);
-        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        __Pyx_Raise(__pyx_t_7, 0, 0, 0);
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __PYX_ERR(2, 677, __pyx_L1_error)
+        __Pyx_Raise(__pyx_t_11, 0, 0, 0);
+        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+        __PYX_ERR(2, 685, __pyx_L1_error)
 
-        /* "View.MemoryView":676
+        /* "View.MemoryView":684
  *             have_slices = True
  *         else:
  *             if not isinstance(item, slice) and not PyIndex_Check(item):             # <<<<<<<<<<<<<<
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  */
       }
 
-      /* "View.MemoryView":679
+      /* "View.MemoryView":687
  *                 raise TypeError("Cannot index with type '%s'" % type(item))
  * 
  *             have_slices = have_slices or isinstance(item, slice)             # <<<<<<<<<<<<<<
  *             result.append(item)
  * 
  */
       __pyx_t_10 = (__pyx_v_have_slices != 0);
@@ -12457,120 +12504,120 @@
       }
       __pyx_t_10 = PySlice_Check(__pyx_v_item); 
       __pyx_t_2 = (__pyx_t_10 != 0);
       __pyx_t_1 = __pyx_t_2;
       __pyx_L11_bool_binop_done:;
       __pyx_v_have_slices = __pyx_t_1;
 
-      /* "View.MemoryView":680
+      /* "View.MemoryView":688
  * 
  *             have_slices = have_slices or isinstance(item, slice)
  *             result.append(item)             # <<<<<<<<<<<<<<
  * 
  *     nslices = ndim - len(result)
  */
-      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 680, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_result, __pyx_v_item); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 688, __pyx_L1_error)
     }
     __pyx_L6:;
 
-    /* "View.MemoryView":667
+    /* "View.MemoryView":675
  *     have_slices = False
  *     seen_ellipsis = False
  *     for idx, item in enumerate(tup):             # <<<<<<<<<<<<<<
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  */
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":682
+  /* "View.MemoryView":690
  *             result.append(item)
  * 
  *     nslices = ndim - len(result)             # <<<<<<<<<<<<<<
  *     if nslices:
  *         result.extend([slice(None)] * nslices)
  */
-  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(2, 682, __pyx_L1_error)
+  __pyx_t_5 = PyList_GET_SIZE(__pyx_v_result); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(2, 690, __pyx_L1_error)
   __pyx_v_nslices = (__pyx_v_ndim - __pyx_t_5);
 
-  /* "View.MemoryView":683
+  /* "View.MemoryView":691
  * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
  * 
  */
   __pyx_t_1 = (__pyx_v_nslices != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":684
+    /* "View.MemoryView":692
  *     nslices = ndim - len(result)
  *     if nslices:
  *         result.extend([slice(None)] * nslices)             # <<<<<<<<<<<<<<
  * 
  *     return have_slices or nslices, tuple(result)
  */
-    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 684, __pyx_L1_error)
+    __pyx_t_3 = PyList_New(1 * ((__pyx_v_nslices<0) ? 0:__pyx_v_nslices)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 692, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     { Py_ssize_t __pyx_temp;
       for (__pyx_temp=0; __pyx_temp < __pyx_v_nslices; __pyx_temp++) {
-        __Pyx_INCREF(__pyx_slice__25);
-        __Pyx_GIVEREF(__pyx_slice__25);
-        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__25);
+        __Pyx_INCREF(__pyx_slice__22);
+        __Pyx_GIVEREF(__pyx_slice__22);
+        PyList_SET_ITEM(__pyx_t_3, __pyx_temp, __pyx_slice__22);
       }
     }
-    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 684, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyList_Extend(__pyx_v_result, __pyx_t_3); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 692, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "View.MemoryView":683
+    /* "View.MemoryView":691
  * 
  *     nslices = ndim - len(result)
  *     if nslices:             # <<<<<<<<<<<<<<
  *         result.extend([slice(None)] * nslices)
  * 
  */
   }
 
-  /* "View.MemoryView":686
+  /* "View.MemoryView":694
  *         result.extend([slice(None)] * nslices)
  * 
  *     return have_slices or nslices, tuple(result)             # <<<<<<<<<<<<<<
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  */
   __Pyx_XDECREF(__pyx_r);
   if (!__pyx_v_have_slices) {
   } else {
-    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 686, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyBool_FromLong(__pyx_v_have_slices); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 694, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __pyx_t_3 = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L14_bool_binop_done;
   }
-  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 686, __pyx_L1_error)
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_nslices); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 694, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_3 = __pyx_t_4;
   __pyx_t_4 = 0;
   __pyx_L14_bool_binop_done:;
-  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 686, __pyx_L1_error)
+  __pyx_t_4 = PyList_AsTuple(__pyx_v_result); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 694, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 686, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_11 = PyTuple_New(2); if (unlikely(!__pyx_t_11)) __PYX_ERR(2, 694, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_11);
   __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_4);
-  PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_4);
+  PyTuple_SET_ITEM(__pyx_t_11, 1, __pyx_t_4);
   __pyx_t_3 = 0;
   __pyx_t_4 = 0;
-  __pyx_r = ((PyObject*)__pyx_t_7);
-  __pyx_t_7 = 0;
+  __pyx_r = ((PyObject*)__pyx_t_11);
+  __pyx_t_11 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":654
+  /* "View.MemoryView":662
  *     return isinstance(o, memoryview)
  * 
  * cdef tuple _unellipsify(object index, int ndim):             # <<<<<<<<<<<<<<
  *     """
  *     Replace all ellipses with full slices and fill incomplete indices with
  */
 
@@ -12588,15 +12635,15 @@
   __Pyx_XDECREF(__pyx_v_idx);
   __Pyx_XDECREF(__pyx_v_item);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":688
+/* "View.MemoryView":696
  *     return have_slices or nslices, tuple(result)
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
@@ -12607,60 +12654,60 @@
   Py_ssize_t *__pyx_t_1;
   Py_ssize_t *__pyx_t_2;
   Py_ssize_t *__pyx_t_3;
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   __Pyx_RefNannySetupContext("assert_direct_dimensions", 0);
 
-  /* "View.MemoryView":689
+  /* "View.MemoryView":697
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")
  */
   __pyx_t_2 = (__pyx_v_suboffsets + __pyx_v_ndim);
   for (__pyx_t_3 = __pyx_v_suboffsets; __pyx_t_3 < __pyx_t_2; __pyx_t_3++) {
     __pyx_t_1 = __pyx_t_3;
     __pyx_v_suboffset = (__pyx_t_1[0]);
 
-    /* "View.MemoryView":690
+    /* "View.MemoryView":698
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
  * 
  */
     __pyx_t_4 = ((__pyx_v_suboffset >= 0) != 0);
-    if (__pyx_t_4) {
+    if (unlikely(__pyx_t_4)) {
 
-      /* "View.MemoryView":691
+      /* "View.MemoryView":699
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 691, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 699, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_Raise(__pyx_t_5, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __PYX_ERR(2, 691, __pyx_L1_error)
+      __PYX_ERR(2, 699, __pyx_L1_error)
 
-      /* "View.MemoryView":690
+      /* "View.MemoryView":698
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             raise ValueError("Indirect dimensions not supported")
  * 
  */
     }
   }
 
-  /* "View.MemoryView":688
+  /* "View.MemoryView":696
  *     return have_slices or nslices, tuple(result)
  * 
  * cdef assert_direct_dimensions(Py_ssize_t *suboffsets, int ndim):             # <<<<<<<<<<<<<<
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
 
@@ -12673,15 +12720,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":698
+/* "View.MemoryView":706
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
@@ -12714,529 +12761,529 @@
   PyObject *(*__pyx_t_8)(PyObject *);
   PyObject *__pyx_t_9 = NULL;
   Py_ssize_t __pyx_t_10;
   int __pyx_t_11;
   Py_ssize_t __pyx_t_12;
   __Pyx_RefNannySetupContext("memview_slice", 0);
 
-  /* "View.MemoryView":699
+  /* "View.MemoryView":707
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim             # <<<<<<<<<<<<<<
  *     cdef bint negative_step
  *     cdef __Pyx_memviewslice src, dst
  */
   __pyx_v_new_ndim = 0;
   __pyx_v_suboffset_dim = -1;
 
-  /* "View.MemoryView":706
+  /* "View.MemoryView":714
  * 
  * 
  *     memset(&dst, 0, sizeof(dst))             # <<<<<<<<<<<<<<
  * 
  *     cdef _memoryviewslice memviewsliceobj
  */
-  memset((&__pyx_v_dst), 0, (sizeof(__pyx_v_dst)));
+  (void)(memset((&__pyx_v_dst), 0, (sizeof(__pyx_v_dst))));
 
-  /* "View.MemoryView":710
+  /* "View.MemoryView":718
  *     cdef _memoryviewslice memviewsliceobj
  * 
  *     assert memview.view.ndim > 0             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
   if (unlikely(!Py_OptimizeFlag)) {
     if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
-      __PYX_ERR(2, 710, __pyx_L1_error)
+      __PYX_ERR(2, 718, __pyx_L1_error)
     }
   }
   #endif
 
-  /* "View.MemoryView":712
+  /* "View.MemoryView":720
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":713
+    /* "View.MemoryView":721
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview             # <<<<<<<<<<<<<<
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(2, 713, __pyx_L1_error)
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(2, 721, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
     __Pyx_INCREF(__pyx_t_3);
     __pyx_v_memviewsliceobj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":714
+    /* "View.MemoryView":722
  *     if isinstance(memview, _memoryviewslice):
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, &src)
  */
     __pyx_v_p_src = (&__pyx_v_memviewsliceobj->from_slice);
 
-    /* "View.MemoryView":712
+    /* "View.MemoryView":720
  *     assert memview.view.ndim > 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         memviewsliceobj = memview
  *         p_src = &memviewsliceobj.from_slice
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":716
+  /* "View.MemoryView":724
  *         p_src = &memviewsliceobj.from_slice
  *     else:
  *         slice_copy(memview, &src)             # <<<<<<<<<<<<<<
  *         p_src = &src
  * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_src));
 
-    /* "View.MemoryView":717
+    /* "View.MemoryView":725
  *     else:
  *         slice_copy(memview, &src)
  *         p_src = &src             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_v_p_src = (&__pyx_v_src);
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":723
+  /* "View.MemoryView":731
  * 
  * 
  *     dst.memview = p_src.memview             # <<<<<<<<<<<<<<
  *     dst.data = p_src.data
  * 
  */
   __pyx_t_4 = __pyx_v_p_src->memview;
   __pyx_v_dst.memview = __pyx_t_4;
 
-  /* "View.MemoryView":724
+  /* "View.MemoryView":732
  * 
  *     dst.memview = p_src.memview
  *     dst.data = p_src.data             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_5 = __pyx_v_p_src->data;
   __pyx_v_dst.data = __pyx_t_5;
 
-  /* "View.MemoryView":729
+  /* "View.MemoryView":737
  * 
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst             # <<<<<<<<<<<<<<
  *     cdef int *p_suboffset_dim = &suboffset_dim
  *     cdef Py_ssize_t start, stop, step
  */
   __pyx_v_p_dst = (&__pyx_v_dst);
 
-  /* "View.MemoryView":730
+  /* "View.MemoryView":738
  * 
  *     cdef __Pyx_memviewslice *p_dst = &dst
  *     cdef int *p_suboffset_dim = &suboffset_dim             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t start, stop, step
  *     cdef bint have_start, have_stop, have_step
  */
   __pyx_v_p_suboffset_dim = (&__pyx_v_suboffset_dim);
 
-  /* "View.MemoryView":734
+  /* "View.MemoryView":742
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
  *             slice_memviewslice(
  */
   __pyx_t_6 = 0;
   if (likely(PyList_CheckExact(__pyx_v_indices)) || PyTuple_CheckExact(__pyx_v_indices)) {
     __pyx_t_3 = __pyx_v_indices; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
     __pyx_t_8 = NULL;
   } else {
-    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 734, __pyx_L1_error)
+    __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_indices); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 742, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 734, __pyx_L1_error)
+    __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 742, __pyx_L1_error)
   }
   for (;;) {
     if (likely(!__pyx_t_8)) {
       if (likely(PyList_CheckExact(__pyx_t_3))) {
         if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(2, 734, __pyx_L1_error)
+        __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(2, 742, __pyx_L1_error)
         #else
-        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 734, __pyx_L1_error)
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 742, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         #endif
       } else {
         if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
         #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(2, 734, __pyx_L1_error)
+        __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(2, 742, __pyx_L1_error)
         #else
-        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 734, __pyx_L1_error)
+        __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 742, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_9);
         #endif
       }
     } else {
       __pyx_t_9 = __pyx_t_8(__pyx_t_3);
       if (unlikely(!__pyx_t_9)) {
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(2, 734, __pyx_L1_error)
+          else __PYX_ERR(2, 742, __pyx_L1_error)
         }
         break;
       }
       __Pyx_GOTREF(__pyx_t_9);
     }
     __Pyx_XDECREF_SET(__pyx_v_index, __pyx_t_9);
     __pyx_t_9 = 0;
     __pyx_v_dim = __pyx_t_6;
     __pyx_t_6 = (__pyx_t_6 + 1);
 
-    /* "View.MemoryView":735
+    /* "View.MemoryView":743
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
     __pyx_t_2 = (PyIndex_Check(__pyx_v_index) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":739
+      /* "View.MemoryView":747
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  *                 index, 0, 0, # start, stop, step             # <<<<<<<<<<<<<<
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  */
-      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 739, __pyx_L1_error)
+      __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_v_index); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 747, __pyx_L1_error)
 
-      /* "View.MemoryView":736
+      /* "View.MemoryView":744
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(2, 736, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_t_10, 0, 0, 0, 0, 0, 0); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(2, 744, __pyx_L1_error)
 
-      /* "View.MemoryView":735
+      /* "View.MemoryView":743
  * 
  *     for dim, index in enumerate(indices):
  *         if PyIndex_Check(index):             # <<<<<<<<<<<<<<
  *             slice_memviewslice(
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":742
+    /* "View.MemoryView":750
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
     __pyx_t_2 = (__pyx_v_index == Py_None);
     __pyx_t_1 = (__pyx_t_2 != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":743
+      /* "View.MemoryView":751
  *                 False)
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1             # <<<<<<<<<<<<<<
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  */
       (__pyx_v_p_dst->shape[__pyx_v_new_ndim]) = 1;
 
-      /* "View.MemoryView":744
+      /* "View.MemoryView":752
  *         elif index is None:
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0             # <<<<<<<<<<<<<<
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1
  */
       (__pyx_v_p_dst->strides[__pyx_v_new_ndim]) = 0;
 
-      /* "View.MemoryView":745
+      /* "View.MemoryView":753
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1             # <<<<<<<<<<<<<<
  *             new_ndim += 1
  *         else:
  */
       (__pyx_v_p_dst->suboffsets[__pyx_v_new_ndim]) = -1L;
 
-      /* "View.MemoryView":746
+      /* "View.MemoryView":754
  *             p_dst.strides[new_ndim] = 0
  *             p_dst.suboffsets[new_ndim] = -1
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  *         else:
  *             start = index.start or 0
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
 
-      /* "View.MemoryView":742
+      /* "View.MemoryView":750
  *                 0, 0, 0, # have_{start,stop,step}
  *                 False)
  *         elif index is None:             # <<<<<<<<<<<<<<
  *             p_dst.shape[new_ndim] = 1
  *             p_dst.strides[new_ndim] = 0
  */
       goto __pyx_L6;
     }
 
-    /* "View.MemoryView":748
+    /* "View.MemoryView":756
  *             new_ndim += 1
  *         else:
  *             start = index.start or 0             # <<<<<<<<<<<<<<
  *             stop = index.stop or 0
  *             step = index.step or 0
  */
     /*else*/ {
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 748, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 756, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 748, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 756, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 748, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 756, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L7_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L7_bool_binop_done:;
       __pyx_v_start = __pyx_t_10;
 
-      /* "View.MemoryView":749
+      /* "View.MemoryView":757
  *         else:
  *             start = index.start or 0
  *             stop = index.stop or 0             # <<<<<<<<<<<<<<
  *             step = index.step or 0
  * 
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 749, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 757, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 749, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 757, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 749, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 757, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L9_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L9_bool_binop_done:;
       __pyx_v_stop = __pyx_t_10;
 
-      /* "View.MemoryView":750
+      /* "View.MemoryView":758
  *             start = index.start or 0
  *             stop = index.stop or 0
  *             step = index.step or 0             # <<<<<<<<<<<<<<
  * 
  *             have_start = index.start is not None
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 750, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 758, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 750, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(2, 758, __pyx_L1_error)
       if (!__pyx_t_1) {
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       } else {
-        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 750, __pyx_L1_error)
+        __pyx_t_12 = __Pyx_PyIndex_AsSsize_t(__pyx_t_9); if (unlikely((__pyx_t_12 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 758, __pyx_L1_error)
         __pyx_t_10 = __pyx_t_12;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         goto __pyx_L11_bool_binop_done;
       }
       __pyx_t_10 = 0;
       __pyx_L11_bool_binop_done:;
       __pyx_v_step = __pyx_t_10;
 
-      /* "View.MemoryView":752
+      /* "View.MemoryView":760
  *             step = index.step or 0
  * 
  *             have_start = index.start is not None             # <<<<<<<<<<<<<<
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 752, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_start); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 760, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_start = __pyx_t_1;
 
-      /* "View.MemoryView":753
+      /* "View.MemoryView":761
  * 
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None             # <<<<<<<<<<<<<<
  *             have_step = index.step is not None
  * 
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 753, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_stop); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 761, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_stop = __pyx_t_1;
 
-      /* "View.MemoryView":754
+      /* "View.MemoryView":762
  *             have_start = index.start is not None
  *             have_stop = index.stop is not None
  *             have_step = index.step is not None             # <<<<<<<<<<<<<<
  * 
  *             slice_memviewslice(
  */
-      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 754, __pyx_L1_error)
+      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_index, __pyx_n_s_step); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 762, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_9);
       __pyx_t_1 = (__pyx_t_9 != Py_None);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_v_have_step = __pyx_t_1;
 
-      /* "View.MemoryView":756
+      /* "View.MemoryView":764
  *             have_step = index.step is not None
  * 
  *             slice_memviewslice(             # <<<<<<<<<<<<<<
  *                 p_dst, p_src.shape[dim], p_src.strides[dim], p_src.suboffsets[dim],
  *                 dim, new_ndim, p_suboffset_dim,
  */
-      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(2, 756, __pyx_L1_error)
+      __pyx_t_11 = __pyx_memoryview_slice_memviewslice(__pyx_v_p_dst, (__pyx_v_p_src->shape[__pyx_v_dim]), (__pyx_v_p_src->strides[__pyx_v_dim]), (__pyx_v_p_src->suboffsets[__pyx_v_dim]), __pyx_v_dim, __pyx_v_new_ndim, __pyx_v_p_suboffset_dim, __pyx_v_start, __pyx_v_stop, __pyx_v_step, __pyx_v_have_start, __pyx_v_have_stop, __pyx_v_have_step, 1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(2, 764, __pyx_L1_error)
 
-      /* "View.MemoryView":762
+      /* "View.MemoryView":770
  *                 have_start, have_stop, have_step,
  *                 True)
  *             new_ndim += 1             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
       __pyx_v_new_ndim = (__pyx_v_new_ndim + 1);
     }
     __pyx_L6:;
 
-    /* "View.MemoryView":734
+    /* "View.MemoryView":742
  *     cdef bint have_start, have_stop, have_step
  * 
  *     for dim, index in enumerate(indices):             # <<<<<<<<<<<<<<
  *         if PyIndex_Check(index):
  *             slice_memviewslice(
  */
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "View.MemoryView":764
+  /* "View.MemoryView":772
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":765
+    /* "View.MemoryView":773
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
     __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":766
+    /* "View.MemoryView":774
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_dtype_func,
  *                                     memview.dtype_is_object)
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(2, 766, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(2, 774, __pyx_L1_error) }
 
-    /* "View.MemoryView":767
+    /* "View.MemoryView":775
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  *     else:
  */
-    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(2, 767, __pyx_L1_error) }
+    if (unlikely(!__pyx_v_memviewsliceobj)) { __Pyx_RaiseUnboundLocalError("memviewsliceobj"); __PYX_ERR(2, 775, __pyx_L1_error) }
 
-    /* "View.MemoryView":765
+    /* "View.MemoryView":773
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         return memoryview_fromslice(dst, new_ndim,             # <<<<<<<<<<<<<<
  *                                     memviewsliceobj.to_object_func,
  *                                     memviewsliceobj.to_dtype_func,
  */
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 765, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, __pyx_v_memviewsliceobj->to_object_func, __pyx_v_memviewsliceobj->to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 773, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(2, 765, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(2, 773, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":764
+    /* "View.MemoryView":772
  *             new_ndim += 1
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         return memoryview_fromslice(dst, new_ndim,
  *                                     memviewsliceobj.to_object_func,
  */
   }
 
-  /* "View.MemoryView":770
+  /* "View.MemoryView":778
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(((PyObject *)__pyx_r));
 
-    /* "View.MemoryView":771
+    /* "View.MemoryView":779
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,
  *                                     memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 770, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_dst, __pyx_v_new_ndim, NULL, NULL, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 778, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
 
-    /* "View.MemoryView":770
+    /* "View.MemoryView":778
  *                                     memview.dtype_is_object)
  *     else:
  *         return memoryview_fromslice(dst, new_ndim, NULL, NULL,             # <<<<<<<<<<<<<<
  *                                     memview.dtype_is_object)
  * 
  */
-    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(2, 770, __pyx_L1_error)
+    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_memoryview_type))))) __PYX_ERR(2, 778, __pyx_L1_error)
     __pyx_r = ((struct __pyx_memoryview_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":698
+  /* "View.MemoryView":706
  * 
  * @cname('__pyx_memview_slice')
  * cdef memoryview memview_slice(memoryview memview, object indices):             # <<<<<<<<<<<<<<
  *     cdef int new_ndim = 0, suboffset_dim = -1, dim
  *     cdef bint negative_step
  */
 
@@ -13250,15 +13297,15 @@
   __Pyx_XDECREF((PyObject *)__pyx_v_memviewsliceobj);
   __Pyx_XDECREF(__pyx_v_index);
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":795
+/* "View.MemoryView":803
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
@@ -13266,95 +13313,95 @@
   Py_ssize_t __pyx_v_new_shape;
   int __pyx_v_negative_step;
   int __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
 
-  /* "View.MemoryView":815
+  /* "View.MemoryView":823
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
   __pyx_t_1 = ((!(__pyx_v_is_slice != 0)) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":817
+    /* "View.MemoryView":825
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     __pyx_t_1 = ((__pyx_v_start < 0) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":818
+      /* "View.MemoryView":826
  * 
  *         if start < 0:
  *             start += shape             # <<<<<<<<<<<<<<
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  */
       __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-      /* "View.MemoryView":817
+      /* "View.MemoryView":825
  *     if not is_slice:
  * 
  *         if start < 0:             # <<<<<<<<<<<<<<
  *             start += shape
  *         if not 0 <= start < shape:
  */
     }
 
-    /* "View.MemoryView":819
+    /* "View.MemoryView":827
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     __pyx_t_1 = (0 <= __pyx_v_start);
     if (__pyx_t_1) {
       __pyx_t_1 = (__pyx_v_start < __pyx_v_shape);
     }
     __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":820
+      /* "View.MemoryView":828
  *             start += shape
  *         if not 0 <= start < shape:
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)             # <<<<<<<<<<<<<<
  *     else:
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 820, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"Index out of bounds (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 828, __pyx_L1_error)
 
-      /* "View.MemoryView":819
+      /* "View.MemoryView":827
  *         if start < 0:
  *             start += shape
  *         if not 0 <= start < shape:             # <<<<<<<<<<<<<<
  *             _err_dim(IndexError, "Index out of bounds (axis %d)", dim)
  *     else:
  */
     }
 
-    /* "View.MemoryView":815
+    /* "View.MemoryView":823
  *     cdef bint negative_step
  * 
  *     if not is_slice:             # <<<<<<<<<<<<<<
  * 
  *         if start < 0:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":823
+  /* "View.MemoryView":831
  *     else:
  * 
  *         negative_step = have_step != 0 and step < 0             # <<<<<<<<<<<<<<
  * 
  *         if have_step and step == 0:
  */
   /*else*/ {
@@ -13365,15 +13412,15 @@
       goto __pyx_L6_bool_binop_done;
     }
     __pyx_t_1 = ((__pyx_v_step < 0) != 0);
     __pyx_t_2 = __pyx_t_1;
     __pyx_L6_bool_binop_done:;
     __pyx_v_negative_step = __pyx_t_2;
 
-    /* "View.MemoryView":825
+    /* "View.MemoryView":833
  *         negative_step = have_step != 0 and step < 0
  * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
  */
     __pyx_t_1 = (__pyx_v_have_step != 0);
@@ -13383,639 +13430,639 @@
       goto __pyx_L9_bool_binop_done;
     }
     __pyx_t_1 = ((__pyx_v_step == 0) != 0);
     __pyx_t_2 = __pyx_t_1;
     __pyx_L9_bool_binop_done:;
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":826
+      /* "View.MemoryView":834
  * 
  *         if have_step and step == 0:
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 826, __pyx_L1_error)
+      __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Step may not be zero (axis %d)"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 834, __pyx_L1_error)
 
-      /* "View.MemoryView":825
+      /* "View.MemoryView":833
  *         negative_step = have_step != 0 and step < 0
  * 
  *         if have_step and step == 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Step may not be zero (axis %d)", dim)
  * 
  */
     }
 
-    /* "View.MemoryView":829
+    /* "View.MemoryView":837
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
     __pyx_t_2 = (__pyx_v_have_start != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":830
+      /* "View.MemoryView":838
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
       __pyx_t_2 = ((__pyx_v_start < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":831
+        /* "View.MemoryView":839
  *         if have_start:
  *             if start < 0:
  *                 start += shape             # <<<<<<<<<<<<<<
  *                 if start < 0:
  *                     start = 0
  */
         __pyx_v_start = (__pyx_v_start + __pyx_v_shape);
 
-        /* "View.MemoryView":832
+        /* "View.MemoryView":840
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         __pyx_t_2 = ((__pyx_v_start < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":833
+          /* "View.MemoryView":841
  *                 start += shape
  *                 if start < 0:
  *                     start = 0             # <<<<<<<<<<<<<<
  *             elif start >= shape:
  *                 if negative_step:
  */
           __pyx_v_start = 0;
 
-          /* "View.MemoryView":832
+          /* "View.MemoryView":840
  *             if start < 0:
  *                 start += shape
  *                 if start < 0:             # <<<<<<<<<<<<<<
  *                     start = 0
  *             elif start >= shape:
  */
         }
 
-        /* "View.MemoryView":830
+        /* "View.MemoryView":838
  * 
  *         if have_start:
  *             if start < 0:             # <<<<<<<<<<<<<<
  *                 start += shape
  *                 if start < 0:
  */
         goto __pyx_L12;
       }
 
-      /* "View.MemoryView":834
+      /* "View.MemoryView":842
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
       __pyx_t_2 = ((__pyx_v_start >= __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":835
+        /* "View.MemoryView":843
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
         __pyx_t_2 = (__pyx_v_negative_step != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":836
+          /* "View.MemoryView":844
  *             elif start >= shape:
  *                 if negative_step:
  *                     start = shape - 1             # <<<<<<<<<<<<<<
  *                 else:
  *                     start = shape
  */
           __pyx_v_start = (__pyx_v_shape - 1);
 
-          /* "View.MemoryView":835
+          /* "View.MemoryView":843
  *                     start = 0
  *             elif start >= shape:
  *                 if negative_step:             # <<<<<<<<<<<<<<
  *                     start = shape - 1
  *                 else:
  */
           goto __pyx_L14;
         }
 
-        /* "View.MemoryView":838
+        /* "View.MemoryView":846
  *                     start = shape - 1
  *                 else:
  *                     start = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         /*else*/ {
           __pyx_v_start = __pyx_v_shape;
         }
         __pyx_L14:;
 
-        /* "View.MemoryView":834
+        /* "View.MemoryView":842
  *                 if start < 0:
  *                     start = 0
  *             elif start >= shape:             # <<<<<<<<<<<<<<
  *                 if negative_step:
  *                     start = shape - 1
  */
       }
       __pyx_L12:;
 
-      /* "View.MemoryView":829
+      /* "View.MemoryView":837
  * 
  * 
  *         if have_start:             # <<<<<<<<<<<<<<
  *             if start < 0:
  *                 start += shape
  */
       goto __pyx_L11;
     }
 
-    /* "View.MemoryView":840
+    /* "View.MemoryView":848
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
     /*else*/ {
       __pyx_t_2 = (__pyx_v_negative_step != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":841
+        /* "View.MemoryView":849
  *         else:
  *             if negative_step:
  *                 start = shape - 1             # <<<<<<<<<<<<<<
  *             else:
  *                 start = 0
  */
         __pyx_v_start = (__pyx_v_shape - 1);
 
-        /* "View.MemoryView":840
+        /* "View.MemoryView":848
  *                     start = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 start = shape - 1
  *             else:
  */
         goto __pyx_L15;
       }
 
-      /* "View.MemoryView":843
+      /* "View.MemoryView":851
  *                 start = shape - 1
  *             else:
  *                 start = 0             # <<<<<<<<<<<<<<
  * 
  *         if have_stop:
  */
       /*else*/ {
         __pyx_v_start = 0;
       }
       __pyx_L15:;
     }
     __pyx_L11:;
 
-    /* "View.MemoryView":845
+    /* "View.MemoryView":853
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
     __pyx_t_2 = (__pyx_v_have_stop != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":846
+      /* "View.MemoryView":854
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
       __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":847
+        /* "View.MemoryView":855
  *         if have_stop:
  *             if stop < 0:
  *                 stop += shape             # <<<<<<<<<<<<<<
  *                 if stop < 0:
  *                     stop = 0
  */
         __pyx_v_stop = (__pyx_v_stop + __pyx_v_shape);
 
-        /* "View.MemoryView":848
+        /* "View.MemoryView":856
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         __pyx_t_2 = ((__pyx_v_stop < 0) != 0);
         if (__pyx_t_2) {
 
-          /* "View.MemoryView":849
+          /* "View.MemoryView":857
  *                 stop += shape
  *                 if stop < 0:
  *                     stop = 0             # <<<<<<<<<<<<<<
  *             elif stop > shape:
  *                 stop = shape
  */
           __pyx_v_stop = 0;
 
-          /* "View.MemoryView":848
+          /* "View.MemoryView":856
  *             if stop < 0:
  *                 stop += shape
  *                 if stop < 0:             # <<<<<<<<<<<<<<
  *                     stop = 0
  *             elif stop > shape:
  */
         }
 
-        /* "View.MemoryView":846
+        /* "View.MemoryView":854
  * 
  *         if have_stop:
  *             if stop < 0:             # <<<<<<<<<<<<<<
  *                 stop += shape
  *                 if stop < 0:
  */
         goto __pyx_L17;
       }
 
-      /* "View.MemoryView":850
+      /* "View.MemoryView":858
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
       __pyx_t_2 = ((__pyx_v_stop > __pyx_v_shape) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":851
+        /* "View.MemoryView":859
  *                     stop = 0
  *             elif stop > shape:
  *                 stop = shape             # <<<<<<<<<<<<<<
  *         else:
  *             if negative_step:
  */
         __pyx_v_stop = __pyx_v_shape;
 
-        /* "View.MemoryView":850
+        /* "View.MemoryView":858
  *                 if stop < 0:
  *                     stop = 0
  *             elif stop > shape:             # <<<<<<<<<<<<<<
  *                 stop = shape
  *         else:
  */
       }
       __pyx_L17:;
 
-      /* "View.MemoryView":845
+      /* "View.MemoryView":853
  *                 start = 0
  * 
  *         if have_stop:             # <<<<<<<<<<<<<<
  *             if stop < 0:
  *                 stop += shape
  */
       goto __pyx_L16;
     }
 
-    /* "View.MemoryView":853
+    /* "View.MemoryView":861
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
     /*else*/ {
       __pyx_t_2 = (__pyx_v_negative_step != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":854
+        /* "View.MemoryView":862
  *         else:
  *             if negative_step:
  *                 stop = -1             # <<<<<<<<<<<<<<
  *             else:
  *                 stop = shape
  */
         __pyx_v_stop = -1L;
 
-        /* "View.MemoryView":853
+        /* "View.MemoryView":861
  *                 stop = shape
  *         else:
  *             if negative_step:             # <<<<<<<<<<<<<<
  *                 stop = -1
  *             else:
  */
         goto __pyx_L19;
       }
 
-      /* "View.MemoryView":856
+      /* "View.MemoryView":864
  *                 stop = -1
  *             else:
  *                 stop = shape             # <<<<<<<<<<<<<<
  * 
  *         if not have_step:
  */
       /*else*/ {
         __pyx_v_stop = __pyx_v_shape;
       }
       __pyx_L19:;
     }
     __pyx_L16:;
 
-    /* "View.MemoryView":858
+    /* "View.MemoryView":866
  *                 stop = shape
  * 
  *         if not have_step:             # <<<<<<<<<<<<<<
  *             step = 1
  * 
  */
     __pyx_t_2 = ((!(__pyx_v_have_step != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":859
+      /* "View.MemoryView":867
  * 
  *         if not have_step:
  *             step = 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_step = 1;
 
-      /* "View.MemoryView":858
+      /* "View.MemoryView":866
  *                 stop = shape
  * 
  *         if not have_step:             # <<<<<<<<<<<<<<
  *             step = 1
  * 
  */
     }
 
-    /* "View.MemoryView":863
+    /* "View.MemoryView":871
  * 
  *         with cython.cdivision(True):
  *             new_shape = (stop - start) // step             # <<<<<<<<<<<<<<
  * 
  *             if (stop - start) - step * new_shape:
  */
     __pyx_v_new_shape = ((__pyx_v_stop - __pyx_v_start) / __pyx_v_step);
 
-    /* "View.MemoryView":865
+    /* "View.MemoryView":873
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     __pyx_t_2 = (((__pyx_v_stop - __pyx_v_start) - (__pyx_v_step * __pyx_v_new_shape)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":866
+      /* "View.MemoryView":874
  * 
  *             if (stop - start) - step * new_shape:
  *                 new_shape += 1             # <<<<<<<<<<<<<<
  * 
  *         if new_shape < 0:
  */
       __pyx_v_new_shape = (__pyx_v_new_shape + 1);
 
-      /* "View.MemoryView":865
+      /* "View.MemoryView":873
  *             new_shape = (stop - start) // step
  * 
  *             if (stop - start) - step * new_shape:             # <<<<<<<<<<<<<<
  *                 new_shape += 1
  * 
  */
     }
 
-    /* "View.MemoryView":868
+    /* "View.MemoryView":876
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
     __pyx_t_2 = ((__pyx_v_new_shape < 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":869
+      /* "View.MemoryView":877
  * 
  *         if new_shape < 0:
  *             new_shape = 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_new_shape = 0;
 
-      /* "View.MemoryView":868
+      /* "View.MemoryView":876
  *                 new_shape += 1
  * 
  *         if new_shape < 0:             # <<<<<<<<<<<<<<
  *             new_shape = 0
  * 
  */
     }
 
-    /* "View.MemoryView":872
+    /* "View.MemoryView":880
  * 
  * 
  *         dst.strides[new_ndim] = stride * step             # <<<<<<<<<<<<<<
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset
  */
     (__pyx_v_dst->strides[__pyx_v_new_ndim]) = (__pyx_v_stride * __pyx_v_step);
 
-    /* "View.MemoryView":873
+    /* "View.MemoryView":881
  * 
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape             # <<<<<<<<<<<<<<
  *         dst.suboffsets[new_ndim] = suboffset
  * 
  */
     (__pyx_v_dst->shape[__pyx_v_new_ndim]) = __pyx_v_new_shape;
 
-    /* "View.MemoryView":874
+    /* "View.MemoryView":882
  *         dst.strides[new_ndim] = stride * step
  *         dst.shape[new_ndim] = new_shape
  *         dst.suboffsets[new_ndim] = suboffset             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_dst->suboffsets[__pyx_v_new_ndim]) = __pyx_v_suboffset;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":877
+  /* "View.MemoryView":885
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
   __pyx_t_2 = (((__pyx_v_suboffset_dim[0]) < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":878
+    /* "View.MemoryView":886
  * 
  *     if suboffset_dim[0] < 0:
  *         dst.data += start * stride             # <<<<<<<<<<<<<<
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  */
     __pyx_v_dst->data = (__pyx_v_dst->data + (__pyx_v_start * __pyx_v_stride));
 
-    /* "View.MemoryView":877
+    /* "View.MemoryView":885
  * 
  * 
  *     if suboffset_dim[0] < 0:             # <<<<<<<<<<<<<<
  *         dst.data += start * stride
  *     else:
  */
     goto __pyx_L23;
   }
 
-  /* "View.MemoryView":880
+  /* "View.MemoryView":888
  *         dst.data += start * stride
  *     else:
  *         dst.suboffsets[suboffset_dim[0]] += start * stride             # <<<<<<<<<<<<<<
  * 
  *     if suboffset >= 0:
  */
   /*else*/ {
     __pyx_t_3 = (__pyx_v_suboffset_dim[0]);
     (__pyx_v_dst->suboffsets[__pyx_t_3]) = ((__pyx_v_dst->suboffsets[__pyx_t_3]) + (__pyx_v_start * __pyx_v_stride));
   }
   __pyx_L23:;
 
-  /* "View.MemoryView":882
+  /* "View.MemoryView":890
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":883
+    /* "View.MemoryView":891
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
     __pyx_t_2 = ((!(__pyx_v_is_slice != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":884
+      /* "View.MemoryView":892
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
       __pyx_t_2 = ((__pyx_v_new_ndim == 0) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":885
+        /* "View.MemoryView":893
  *         if not is_slice:
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset             # <<<<<<<<<<<<<<
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  */
         __pyx_v_dst->data = ((((char **)__pyx_v_dst->data)[0]) + __pyx_v_suboffset);
 
-        /* "View.MemoryView":884
+        /* "View.MemoryView":892
  *     if suboffset >= 0:
  *         if not is_slice:
  *             if new_ndim == 0:             # <<<<<<<<<<<<<<
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  */
         goto __pyx_L26;
       }
 
-      /* "View.MemoryView":887
+      /* "View.MemoryView":895
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "             # <<<<<<<<<<<<<<
  *                                      "must be indexed and not sliced", dim)
  *         else:
  */
       /*else*/ {
 
-        /* "View.MemoryView":888
+        /* "View.MemoryView":896
  *             else:
  *                 _err_dim(IndexError, "All dimensions preceding dimension %d "
  *                                      "must be indexed and not sliced", dim)             # <<<<<<<<<<<<<<
  *         else:
  *             suboffset_dim[0] = new_ndim
  */
-        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 887, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_err_dim(__pyx_builtin_IndexError, ((char *)"All dimensions preceding dimension %d must be indexed and not sliced"), __pyx_v_dim); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 895, __pyx_L1_error)
       }
       __pyx_L26:;
 
-      /* "View.MemoryView":883
+      /* "View.MemoryView":891
  * 
  *     if suboffset >= 0:
  *         if not is_slice:             # <<<<<<<<<<<<<<
  *             if new_ndim == 0:
  *                 dst.data = (<char **> dst.data)[0] + suboffset
  */
       goto __pyx_L25;
     }
 
-    /* "View.MemoryView":890
+    /* "View.MemoryView":898
  *                                      "must be indexed and not sliced", dim)
  *         else:
  *             suboffset_dim[0] = new_ndim             # <<<<<<<<<<<<<<
  * 
  *     return 0
  */
     /*else*/ {
       (__pyx_v_suboffset_dim[0]) = __pyx_v_new_ndim;
     }
     __pyx_L25:;
 
-    /* "View.MemoryView":882
+    /* "View.MemoryView":890
  *         dst.suboffsets[suboffset_dim[0]] += start * stride
  * 
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         if not is_slice:
  *             if new_ndim == 0:
  */
   }
 
-  /* "View.MemoryView":892
+  /* "View.MemoryView":900
  *             suboffset_dim[0] = new_ndim
  * 
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":795
+  /* "View.MemoryView":803
  * 
  * @cname('__pyx_memoryview_slice_memviewslice')
  * cdef int slice_memviewslice(             # <<<<<<<<<<<<<<
  *         __Pyx_memviewslice *dst,
  *         Py_ssize_t shape, Py_ssize_t stride, Py_ssize_t suboffset,
  */
 
@@ -14031,15 +14078,15 @@
     #endif
   }
   __pyx_r = -1;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":898
+/* "View.MemoryView":906
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
@@ -14053,290 +14100,280 @@
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   __Pyx_RefNannySetupContext("pybuffer_index", 0);
 
-  /* "View.MemoryView":900
+  /* "View.MemoryView":908
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t itemsize = view.itemsize
  *     cdef char *resultp
  */
   __pyx_v_suboffset = -1L;
 
-  /* "View.MemoryView":901
+  /* "View.MemoryView":909
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  *     cdef Py_ssize_t itemsize = view.itemsize             # <<<<<<<<<<<<<<
  *     cdef char *resultp
  * 
  */
   __pyx_t_1 = __pyx_v_view->itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":904
+  /* "View.MemoryView":912
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
  *         shape = view.len / itemsize
  *         stride = itemsize
  */
   __pyx_t_2 = ((__pyx_v_view->ndim == 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":905
+    /* "View.MemoryView":913
  * 
  *     if view.ndim == 0:
  *         shape = view.len / itemsize             # <<<<<<<<<<<<<<
  *         stride = itemsize
  *     else:
  */
     if (unlikely(__pyx_v_itemsize == 0)) {
       PyErr_SetString(PyExc_ZeroDivisionError, "integer division or modulo by zero");
-      __PYX_ERR(2, 905, __pyx_L1_error)
+      __PYX_ERR(2, 913, __pyx_L1_error)
     }
     else if (sizeof(Py_ssize_t) == sizeof(long) && (!(((Py_ssize_t)-1) > 0)) && unlikely(__pyx_v_itemsize == (Py_ssize_t)-1)  && unlikely(UNARY_NEG_WOULD_OVERFLOW(__pyx_v_view->len))) {
       PyErr_SetString(PyExc_OverflowError, "value too large to perform division");
-      __PYX_ERR(2, 905, __pyx_L1_error)
+      __PYX_ERR(2, 913, __pyx_L1_error)
     }
     __pyx_v_shape = __Pyx_div_Py_ssize_t(__pyx_v_view->len, __pyx_v_itemsize);
 
-    /* "View.MemoryView":906
+    /* "View.MemoryView":914
  *     if view.ndim == 0:
  *         shape = view.len / itemsize
  *         stride = itemsize             # <<<<<<<<<<<<<<
  *     else:
  *         shape = view.shape[dim]
  */
     __pyx_v_stride = __pyx_v_itemsize;
 
-    /* "View.MemoryView":904
+    /* "View.MemoryView":912
  *     cdef char *resultp
  * 
  *     if view.ndim == 0:             # <<<<<<<<<<<<<<
  *         shape = view.len / itemsize
  *         stride = itemsize
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":908
+  /* "View.MemoryView":916
  *         stride = itemsize
  *     else:
  *         shape = view.shape[dim]             # <<<<<<<<<<<<<<
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  */
   /*else*/ {
     __pyx_v_shape = (__pyx_v_view->shape[__pyx_v_dim]);
 
-    /* "View.MemoryView":909
+    /* "View.MemoryView":917
  *     else:
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]             # <<<<<<<<<<<<<<
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]
  */
     __pyx_v_stride = (__pyx_v_view->strides[__pyx_v_dim]);
 
-    /* "View.MemoryView":910
+    /* "View.MemoryView":918
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
     __pyx_t_2 = ((__pyx_v_view->suboffsets != NULL) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":911
+      /* "View.MemoryView":919
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:
  *             suboffset = view.suboffsets[dim]             # <<<<<<<<<<<<<<
  * 
  *     if index < 0:
  */
       __pyx_v_suboffset = (__pyx_v_view->suboffsets[__pyx_v_dim]);
 
-      /* "View.MemoryView":910
+      /* "View.MemoryView":918
  *         shape = view.shape[dim]
  *         stride = view.strides[dim]
  *         if view.suboffsets != NULL:             # <<<<<<<<<<<<<<
  *             suboffset = view.suboffsets[dim]
  * 
  */
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":913
+  /* "View.MemoryView":921
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   __pyx_t_2 = ((__pyx_v_index < 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":914
+    /* "View.MemoryView":922
  * 
  *     if index < 0:
  *         index += view.shape[dim]             # <<<<<<<<<<<<<<
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  */
     __pyx_v_index = (__pyx_v_index + (__pyx_v_view->shape[__pyx_v_dim]));
 
-    /* "View.MemoryView":915
+    /* "View.MemoryView":923
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
     __pyx_t_2 = ((__pyx_v_index < 0) != 0);
-    if (__pyx_t_2) {
+    if (unlikely(__pyx_t_2)) {
 
-      /* "View.MemoryView":916
+      /* "View.MemoryView":924
  *         index += view.shape[dim]
  *         if index < 0:
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     if index >= shape:
  */
-      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 916, __pyx_L1_error)
+      __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 924, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 916, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 924, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 916, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 924, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_GIVEREF(__pyx_t_4);
-      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
-      __pyx_t_4 = 0;
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_IndexError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 916, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __PYX_ERR(2, 916, __pyx_L1_error)
+      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __PYX_ERR(2, 924, __pyx_L1_error)
 
-      /* "View.MemoryView":915
+      /* "View.MemoryView":923
  *     if index < 0:
  *         index += view.shape[dim]
  *         if index < 0:             # <<<<<<<<<<<<<<
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
     }
 
-    /* "View.MemoryView":913
+    /* "View.MemoryView":921
  *             suboffset = view.suboffsets[dim]
  * 
  *     if index < 0:             # <<<<<<<<<<<<<<
  *         index += view.shape[dim]
  *         if index < 0:
  */
   }
 
-  /* "View.MemoryView":918
+  /* "View.MemoryView":926
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
   __pyx_t_2 = ((__pyx_v_index >= __pyx_v_shape) != 0);
-  if (__pyx_t_2) {
+  if (unlikely(__pyx_t_2)) {
 
-    /* "View.MemoryView":919
+    /* "View.MemoryView":927
  * 
  *     if index >= shape:
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)             # <<<<<<<<<<<<<<
  * 
  *     resultp = bufp + index * stride
  */
-    __pyx_t_4 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 919, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 919, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 927, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 919, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Out_of_bounds_on_buffer_access_a, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 927, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_GIVEREF(__pyx_t_3);
-    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
-    __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_IndexError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 919, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_IndexError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 927, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(2, 919, __pyx_L1_error)
+    __PYX_ERR(2, 927, __pyx_L1_error)
 
-    /* "View.MemoryView":918
+    /* "View.MemoryView":926
  *             raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     if index >= shape:             # <<<<<<<<<<<<<<
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  */
   }
 
-  /* "View.MemoryView":921
+  /* "View.MemoryView":929
  *         raise IndexError("Out of bounds on buffer access (axis %d)" % dim)
  * 
  *     resultp = bufp + index * stride             # <<<<<<<<<<<<<<
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset
  */
   __pyx_v_resultp = (__pyx_v_bufp + (__pyx_v_index * __pyx_v_stride));
 
-  /* "View.MemoryView":922
+  /* "View.MemoryView":930
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
   __pyx_t_2 = ((__pyx_v_suboffset >= 0) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":923
+    /* "View.MemoryView":931
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:
  *         resultp = (<char **> resultp)[0] + suboffset             # <<<<<<<<<<<<<<
  * 
  *     return resultp
  */
     __pyx_v_resultp = ((((char **)__pyx_v_resultp)[0]) + __pyx_v_suboffset);
 
-    /* "View.MemoryView":922
+    /* "View.MemoryView":930
  * 
  *     resultp = bufp + index * stride
  *     if suboffset >= 0:             # <<<<<<<<<<<<<<
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  */
   }
 
-  /* "View.MemoryView":925
+  /* "View.MemoryView":933
  *         resultp = (<char **> resultp)[0] + suboffset
  * 
  *     return resultp             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_resultp;
   goto __pyx_L0;
 
-  /* "View.MemoryView":898
+  /* "View.MemoryView":906
  * 
  * @cname('__pyx_pybuffer_index')
  * cdef char *pybuffer_index(Py_buffer *view, char *bufp, Py_ssize_t index,             # <<<<<<<<<<<<<<
  *                           Py_ssize_t dim) except NULL:
  *     cdef Py_ssize_t shape, stride, suboffset = -1
  */
 
@@ -14347,15 +14384,15 @@
   __Pyx_AddTraceback("View.MemoryView.pybuffer_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":931
+/* "View.MemoryView":939
  * 
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
@@ -14365,142 +14402,144 @@
   Py_ssize_t *__pyx_v_strides;
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_r;
   int __pyx_t_1;
   Py_ssize_t *__pyx_t_2;
   long __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
+  long __pyx_t_4;
   Py_ssize_t __pyx_t_5;
-  int __pyx_t_6;
+  Py_ssize_t __pyx_t_6;
   int __pyx_t_7;
   int __pyx_t_8;
+  int __pyx_t_9;
 
-  /* "View.MemoryView":932
+  /* "View.MemoryView":940
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:
  *     cdef int ndim = memslice.memview.view.ndim             # <<<<<<<<<<<<<<
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  */
   __pyx_t_1 = __pyx_v_memslice->memview->view.ndim;
   __pyx_v_ndim = __pyx_t_1;
 
-  /* "View.MemoryView":934
+  /* "View.MemoryView":942
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  *     cdef Py_ssize_t *shape = memslice.shape             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t *strides = memslice.strides
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->shape;
   __pyx_v_shape = __pyx_t_2;
 
-  /* "View.MemoryView":935
+  /* "View.MemoryView":943
  * 
  *     cdef Py_ssize_t *shape = memslice.shape
  *     cdef Py_ssize_t *strides = memslice.strides             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = __pyx_v_memslice->strides;
   __pyx_v_strides = __pyx_t_2;
 
-  /* "View.MemoryView":939
+  /* "View.MemoryView":947
  * 
  *     cdef int i, j
  *     for i in range(ndim / 2):             # <<<<<<<<<<<<<<
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  */
   __pyx_t_3 = __Pyx_div_long(__pyx_v_ndim, 2);
-  for (__pyx_t_1 = 0; __pyx_t_1 < __pyx_t_3; __pyx_t_1+=1) {
+  __pyx_t_4 = __pyx_t_3;
+  for (__pyx_t_1 = 0; __pyx_t_1 < __pyx_t_4; __pyx_t_1+=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":940
+    /* "View.MemoryView":948
  *     cdef int i, j
  *     for i in range(ndim / 2):
  *         j = ndim - 1 - i             # <<<<<<<<<<<<<<
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]
  */
     __pyx_v_j = ((__pyx_v_ndim - 1) - __pyx_v_i);
 
-    /* "View.MemoryView":941
+    /* "View.MemoryView":949
  *     for i in range(ndim / 2):
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]             # <<<<<<<<<<<<<<
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  */
-    __pyx_t_4 = (__pyx_v_strides[__pyx_v_j]);
-    __pyx_t_5 = (__pyx_v_strides[__pyx_v_i]);
-    (__pyx_v_strides[__pyx_v_i]) = __pyx_t_4;
-    (__pyx_v_strides[__pyx_v_j]) = __pyx_t_5;
+    __pyx_t_5 = (__pyx_v_strides[__pyx_v_j]);
+    __pyx_t_6 = (__pyx_v_strides[__pyx_v_i]);
+    (__pyx_v_strides[__pyx_v_i]) = __pyx_t_5;
+    (__pyx_v_strides[__pyx_v_j]) = __pyx_t_6;
 
-    /* "View.MemoryView":942
+    /* "View.MemoryView":950
  *         j = ndim - 1 - i
  *         strides[i], strides[j] = strides[j], strides[i]
  *         shape[i], shape[j] = shape[j], shape[i]             # <<<<<<<<<<<<<<
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  */
-    __pyx_t_5 = (__pyx_v_shape[__pyx_v_j]);
-    __pyx_t_4 = (__pyx_v_shape[__pyx_v_i]);
-    (__pyx_v_shape[__pyx_v_i]) = __pyx_t_5;
-    (__pyx_v_shape[__pyx_v_j]) = __pyx_t_4;
+    __pyx_t_6 = (__pyx_v_shape[__pyx_v_j]);
+    __pyx_t_5 = (__pyx_v_shape[__pyx_v_i]);
+    (__pyx_v_shape[__pyx_v_i]) = __pyx_t_6;
+    (__pyx_v_shape[__pyx_v_j]) = __pyx_t_5;
 
-    /* "View.MemoryView":944
+    /* "View.MemoryView":952
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
-    __pyx_t_7 = (((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0) != 0);
-    if (!__pyx_t_7) {
+    __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_i]) >= 0) != 0);
+    if (!__pyx_t_8) {
     } else {
-      __pyx_t_6 = __pyx_t_7;
+      __pyx_t_7 = __pyx_t_8;
       goto __pyx_L6_bool_binop_done;
     }
-    __pyx_t_7 = (((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0) != 0);
-    __pyx_t_6 = __pyx_t_7;
+    __pyx_t_8 = (((__pyx_v_memslice->suboffsets[__pyx_v_j]) >= 0) != 0);
+    __pyx_t_7 = __pyx_t_8;
     __pyx_L6_bool_binop_done:;
-    if (__pyx_t_6) {
+    if (__pyx_t_7) {
 
-      /* "View.MemoryView":945
+      /* "View.MemoryView":953
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")             # <<<<<<<<<<<<<<
  * 
  *     return 1
  */
-      __pyx_t_8 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(2, 945, __pyx_L1_error)
+      __pyx_t_9 = __pyx_memoryview_err(__pyx_builtin_ValueError, ((char *)"Cannot transpose memoryview with indirect dimensions")); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(2, 953, __pyx_L1_error)
 
-      /* "View.MemoryView":944
+      /* "View.MemoryView":952
  *         shape[i], shape[j] = shape[j], shape[i]
  * 
  *         if memslice.suboffsets[i] >= 0 or memslice.suboffsets[j] >= 0:             # <<<<<<<<<<<<<<
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  */
     }
   }
 
-  /* "View.MemoryView":947
+  /* "View.MemoryView":955
  *             _err(ValueError, "Cannot transpose memoryview with indirect dimensions")
  * 
  *     return 1             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = 1;
   goto __pyx_L0;
 
-  /* "View.MemoryView":931
+  /* "View.MemoryView":939
  * 
  * @cname('__pyx_memslice_transpose')
  * cdef int transpose_memslice(__Pyx_memviewslice *memslice) nogil except 0:             # <<<<<<<<<<<<<<
  *     cdef int ndim = memslice.memview.view.ndim
  * 
  */
 
@@ -14516,15 +14555,15 @@
     #endif
   }
   __pyx_r = 0;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":964
+/* "View.MemoryView":972
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
@@ -14539,100 +14578,100 @@
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "View.MemoryView":965
+  /* "View.MemoryView":973
  * 
  *     def __dealloc__(self):
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)             # <<<<<<<<<<<<<<
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  */
   __PYX_XDEC_MEMVIEW((&__pyx_v_self->from_slice), 1);
 
-  /* "View.MemoryView":964
+  /* "View.MemoryView":972
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":967
+/* "View.MemoryView":975
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   __Pyx_RefNannySetupContext("convert_item_to_object", 0);
 
-  /* "View.MemoryView":968
+  /* "View.MemoryView":976
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_self->to_object_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":969
+    /* "View.MemoryView":977
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)             # <<<<<<<<<<<<<<
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 969, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_object_func(__pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 977, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
 
-    /* "View.MemoryView":968
+    /* "View.MemoryView":976
  * 
  *     cdef convert_item_to_object(self, char *itemp):
  *         if self.to_object_func != NULL:             # <<<<<<<<<<<<<<
  *             return self.to_object_func(itemp)
  *         else:
  */
   }
 
-  /* "View.MemoryView":971
+  /* "View.MemoryView":979
  *             return self.to_object_func(itemp)
  *         else:
  *             return memoryview.convert_item_to_object(self, itemp)             # <<<<<<<<<<<<<<
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 971, __pyx_L1_error)
+    __pyx_t_2 = __pyx_memoryview_convert_item_to_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 979, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_r = __pyx_t_2;
     __pyx_t_2 = 0;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":967
+  /* "View.MemoryView":975
  *         __PYX_XDEC_MEMVIEW(&self.from_slice, 1)
  * 
  *     cdef convert_item_to_object(self, char *itemp):             # <<<<<<<<<<<<<<
  *         if self.to_object_func != NULL:
  *             return self.to_object_func(itemp)
  */
 
@@ -14643,15 +14682,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":973
+/* "View.MemoryView":981
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -14659,58 +14698,58 @@
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   __Pyx_RefNannySetupContext("assign_item_from_object", 0);
 
-  /* "View.MemoryView":974
+  /* "View.MemoryView":982
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
   __pyx_t_1 = ((__pyx_v_self->to_dtype_func != NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":975
+    /* "View.MemoryView":983
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)             # <<<<<<<<<<<<<<
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)
  */
-    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(2, 975, __pyx_L1_error)
+    __pyx_t_2 = __pyx_v_self->to_dtype_func(__pyx_v_itemp, __pyx_v_value); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(2, 983, __pyx_L1_error)
 
-    /* "View.MemoryView":974
+    /* "View.MemoryView":982
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):
  *         if self.to_dtype_func != NULL:             # <<<<<<<<<<<<<<
  *             self.to_dtype_func(itemp, value)
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":977
+  /* "View.MemoryView":985
  *             self.to_dtype_func(itemp, value)
  *         else:
  *             memoryview.assign_item_from_object(self, itemp, value)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   /*else*/ {
-    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 977, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_assign_item_from_object(((struct __pyx_memoryview_obj *)__pyx_v_self), __pyx_v_itemp, __pyx_v_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 985, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":973
+  /* "View.MemoryView":981
  *             return memoryview.convert_item_to_object(self, itemp)
  * 
  *     cdef assign_item_from_object(self, char *itemp, object value):             # <<<<<<<<<<<<<<
  *         if self.to_dtype_func != NULL:
  *             self.to_dtype_func(itemp, value)
  */
 
@@ -14723,15 +14762,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":980
+/* "View.MemoryView":988
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
@@ -14749,27 +14788,27 @@
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView_16_memoryviewslice_4base___get__(struct __pyx_memoryviewslice_obj *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "View.MemoryView":981
+  /* "View.MemoryView":989
  *     @property
  *     def base(self):
  *         return self.from_object             # <<<<<<<<<<<<<<
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->from_object);
   __pyx_r = __pyx_v_self->from_object;
   goto __pyx_L0;
 
-  /* "View.MemoryView":980
+  /* "View.MemoryView":988
  * 
  *     @property
  *     def base(self):             # <<<<<<<<<<<<<<
  *         return self.from_object
  * 
  */
 
@@ -14807,15 +14846,15 @@
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 2, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(2, 2, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
@@ -14860,15 +14899,15 @@
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __PYX_ERR(2, 4, __pyx_L1_error)
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
@@ -14883,15 +14922,15 @@
   __Pyx_AddTraceback("View.MemoryView._memoryviewslice.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":987
+/* "View.MemoryView":995
  * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
  *                           int ndim,
  *                           object (*to_object_func)(char *),
  */
 
@@ -14908,320 +14947,351 @@
   Py_buffer __pyx_t_5;
   Py_ssize_t *__pyx_t_6;
   Py_ssize_t *__pyx_t_7;
   Py_ssize_t *__pyx_t_8;
   Py_ssize_t __pyx_t_9;
   __Pyx_RefNannySetupContext("memoryview_fromslice", 0);
 
-  /* "View.MemoryView":995
+  /* "View.MemoryView":1003
  *     cdef _memoryviewslice result
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
   __pyx_t_1 = ((((PyObject *)__pyx_v_memviewslice.memview) == Py_None) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":996
+    /* "View.MemoryView":1004
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:
  *         return None             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF(Py_None);
-    __pyx_r = Py_None;
+    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "View.MemoryView":995
+    /* "View.MemoryView":1003
  *     cdef _memoryviewslice result
  * 
  *     if <PyObject *> memviewslice.memview == Py_None:             # <<<<<<<<<<<<<<
  *         return None
  * 
  */
   }
 
-  /* "View.MemoryView":1001
+  /* "View.MemoryView":1009
  * 
  * 
  *     result = _memoryviewslice(None, 0, dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  *     result.from_slice = memviewslice
  */
-  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1001, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_v_dtype_is_object); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1009, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1001, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1009, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(Py_None);
   __Pyx_GIVEREF(Py_None);
   PyTuple_SET_ITEM(__pyx_t_3, 0, Py_None);
   __Pyx_INCREF(__pyx_int_0);
   __Pyx_GIVEREF(__pyx_int_0);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_0);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1001, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_memoryviewslice_type), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1009, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_result = ((struct __pyx_memoryviewslice_obj *)__pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":1003
+  /* "View.MemoryView":1011
  *     result = _memoryviewslice(None, 0, dtype_is_object)
  * 
  *     result.from_slice = memviewslice             # <<<<<<<<<<<<<<
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  */
   __pyx_v_result->from_slice = __pyx_v_memviewslice;
 
-  /* "View.MemoryView":1004
+  /* "View.MemoryView":1012
  * 
  *     result.from_slice = memviewslice
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)             # <<<<<<<<<<<<<<
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base
  */
   __PYX_INC_MEMVIEW((&__pyx_v_memviewslice), 1);
 
-  /* "View.MemoryView":1006
+  /* "View.MemoryView":1014
  *     __PYX_INC_MEMVIEW(&memviewslice, 1)
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base             # <<<<<<<<<<<<<<
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1006, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_memviewslice.memview), __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1014, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_2);
   __Pyx_GOTREF(__pyx_v_result->from_object);
   __Pyx_DECREF(__pyx_v_result->from_object);
   __pyx_v_result->from_object = __pyx_t_2;
   __pyx_t_2 = 0;
 
-  /* "View.MemoryView":1007
+  /* "View.MemoryView":1015
  * 
  *     result.from_object = (<memoryview> memviewslice.memview).base
  *     result.typeinfo = memviewslice.memview.typeinfo             # <<<<<<<<<<<<<<
  * 
  *     result.view = memviewslice.memview.view
  */
   __pyx_t_4 = __pyx_v_memviewslice.memview->typeinfo;
   __pyx_v_result->__pyx_base.typeinfo = __pyx_t_4;
 
-  /* "View.MemoryView":1009
+  /* "View.MemoryView":1017
  *     result.typeinfo = memviewslice.memview.typeinfo
  * 
  *     result.view = memviewslice.memview.view             # <<<<<<<<<<<<<<
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim
  */
   __pyx_t_5 = __pyx_v_memviewslice.memview->view;
   __pyx_v_result->__pyx_base.view = __pyx_t_5;
 
-  /* "View.MemoryView":1010
+  /* "View.MemoryView":1018
  * 
  *     result.view = memviewslice.memview.view
  *     result.view.buf = <void *> memviewslice.data             # <<<<<<<<<<<<<<
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  */
   __pyx_v_result->__pyx_base.view.buf = ((void *)__pyx_v_memviewslice.data);
 
-  /* "View.MemoryView":1011
+  /* "View.MemoryView":1019
  *     result.view = memviewslice.memview.view
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim             # <<<<<<<<<<<<<<
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  *     Py_INCREF(Py_None)
  */
   __pyx_v_result->__pyx_base.view.ndim = __pyx_v_ndim;
 
-  /* "View.MemoryView":1012
+  /* "View.MemoryView":1020
  *     result.view.buf = <void *> memviewslice.data
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None             # <<<<<<<<<<<<<<
  *     Py_INCREF(Py_None)
  * 
  */
   ((Py_buffer *)(&__pyx_v_result->__pyx_base.view))->obj = Py_None;
 
-  /* "View.MemoryView":1013
+  /* "View.MemoryView":1021
  *     result.view.ndim = ndim
  *     (<__pyx_buffer *> &result.view).obj = Py_None
  *     Py_INCREF(Py_None)             # <<<<<<<<<<<<<<
  * 
- *     result.flags = PyBUF_RECORDS
+ *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:
  */
   Py_INCREF(Py_None);
 
-  /* "View.MemoryView":1015
+  /* "View.MemoryView":1023
  *     Py_INCREF(Py_None)
  * 
- *     result.flags = PyBUF_RECORDS             # <<<<<<<<<<<<<<
+ *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:             # <<<<<<<<<<<<<<
+ *         result.flags = PyBUF_RECORDS
+ *     else:
+ */
+  __pyx_t_1 = ((((struct __pyx_memoryview_obj *)__pyx_v_memviewslice.memview)->flags & PyBUF_WRITABLE) != 0);
+  if (__pyx_t_1) {
+
+    /* "View.MemoryView":1024
+ * 
+ *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:
+ *         result.flags = PyBUF_RECORDS             # <<<<<<<<<<<<<<
+ *     else:
+ *         result.flags = PyBUF_RECORDS_RO
+ */
+    __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS;
+
+    /* "View.MemoryView":1023
+ *     Py_INCREF(Py_None)
+ * 
+ *     if (<memoryview>memviewslice.memview).flags & PyBUF_WRITABLE:             # <<<<<<<<<<<<<<
+ *         result.flags = PyBUF_RECORDS
+ *     else:
+ */
+    goto __pyx_L4;
+  }
+
+  /* "View.MemoryView":1026
+ *         result.flags = PyBUF_RECORDS
+ *     else:
+ *         result.flags = PyBUF_RECORDS_RO             # <<<<<<<<<<<<<<
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape
  */
-  __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS;
+  /*else*/ {
+    __pyx_v_result->__pyx_base.flags = PyBUF_RECORDS_RO;
+  }
+  __pyx_L4:;
 
-  /* "View.MemoryView":1017
- *     result.flags = PyBUF_RECORDS
+  /* "View.MemoryView":1028
+ *         result.flags = PyBUF_RECORDS_RO
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape             # <<<<<<<<<<<<<<
  *     result.view.strides = <Py_ssize_t *> result.from_slice.strides
  * 
  */
   __pyx_v_result->__pyx_base.view.shape = ((Py_ssize_t *)__pyx_v_result->from_slice.shape);
 
-  /* "View.MemoryView":1018
+  /* "View.MemoryView":1029
  * 
  *     result.view.shape = <Py_ssize_t *> result.from_slice.shape
  *     result.view.strides = <Py_ssize_t *> result.from_slice.strides             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_v_result->__pyx_base.view.strides = ((Py_ssize_t *)__pyx_v_result->from_slice.strides);
 
-  /* "View.MemoryView":1021
+  /* "View.MemoryView":1032
  * 
  * 
  *     result.view.suboffsets = NULL             # <<<<<<<<<<<<<<
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  */
   __pyx_v_result->__pyx_base.view.suboffsets = NULL;
 
-  /* "View.MemoryView":1022
+  /* "View.MemoryView":1033
  * 
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:             # <<<<<<<<<<<<<<
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  */
   __pyx_t_7 = (__pyx_v_result->from_slice.suboffsets + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->from_slice.suboffsets; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
     __pyx_t_6 = __pyx_t_8;
     __pyx_v_suboffset = (__pyx_t_6[0]);
 
-    /* "View.MemoryView":1023
+    /* "View.MemoryView":1034
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break
  */
     __pyx_t_1 = ((__pyx_v_suboffset >= 0) != 0);
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":1024
+      /* "View.MemoryView":1035
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_result->__pyx_base.view.suboffsets = ((Py_ssize_t *)__pyx_v_result->from_slice.suboffsets);
 
-      /* "View.MemoryView":1025
+      /* "View.MemoryView":1036
  *         if suboffset >= 0:
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break             # <<<<<<<<<<<<<<
  * 
  *     result.view.len = result.view.itemsize
  */
-      goto __pyx_L5_break;
+      goto __pyx_L6_break;
 
-      /* "View.MemoryView":1023
+      /* "View.MemoryView":1034
  *     result.view.suboffsets = NULL
  *     for suboffset in result.from_slice.suboffsets[:ndim]:
  *         if suboffset >= 0:             # <<<<<<<<<<<<<<
  *             result.view.suboffsets = <Py_ssize_t *> result.from_slice.suboffsets
  *             break
  */
     }
   }
-  __pyx_L5_break:;
+  __pyx_L6_break:;
 
-  /* "View.MemoryView":1027
+  /* "View.MemoryView":1038
  *             break
  * 
  *     result.view.len = result.view.itemsize             # <<<<<<<<<<<<<<
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length
  */
   __pyx_t_9 = __pyx_v_result->__pyx_base.view.itemsize;
   __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
 
-  /* "View.MemoryView":1028
+  /* "View.MemoryView":1039
  * 
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:             # <<<<<<<<<<<<<<
  *         result.view.len *= length
  * 
  */
   __pyx_t_7 = (__pyx_v_result->__pyx_base.view.shape + __pyx_v_ndim);
   for (__pyx_t_8 = __pyx_v_result->__pyx_base.view.shape; __pyx_t_8 < __pyx_t_7; __pyx_t_8++) {
     __pyx_t_6 = __pyx_t_8;
-    __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1028, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_6[0])); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1039, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_2);
     __pyx_t_2 = 0;
 
-    /* "View.MemoryView":1029
+    /* "View.MemoryView":1040
  *     result.view.len = result.view.itemsize
  *     for length in result.view.shape[:ndim]:
  *         result.view.len *= length             # <<<<<<<<<<<<<<
  * 
  *     result.to_object_func = to_object_func
  */
-    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1029, __pyx_L1_error)
+    __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_result->__pyx_base.view.len); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1040, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1029, __pyx_L1_error)
+    __pyx_t_3 = PyNumber_InPlaceMultiply(__pyx_t_2, __pyx_v_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1040, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 1029, __pyx_L1_error)
+    __pyx_t_9 = __Pyx_PyIndex_AsSsize_t(__pyx_t_3); if (unlikely((__pyx_t_9 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 1040, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_result->__pyx_base.view.len = __pyx_t_9;
   }
 
-  /* "View.MemoryView":1031
+  /* "View.MemoryView":1042
  *         result.view.len *= length
  * 
  *     result.to_object_func = to_object_func             # <<<<<<<<<<<<<<
  *     result.to_dtype_func = to_dtype_func
  * 
  */
   __pyx_v_result->to_object_func = __pyx_v_to_object_func;
 
-  /* "View.MemoryView":1032
+  /* "View.MemoryView":1043
  * 
  *     result.to_object_func = to_object_func
  *     result.to_dtype_func = to_dtype_func             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
   __pyx_v_result->to_dtype_func = __pyx_v_to_dtype_func;
 
-  /* "View.MemoryView":1034
+  /* "View.MemoryView":1045
  *     result.to_dtype_func = to_dtype_func
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_result));
   __pyx_r = ((PyObject *)__pyx_v_result);
   goto __pyx_L0;
 
-  /* "View.MemoryView":987
+  /* "View.MemoryView":995
  * 
  * @cname('__pyx_memoryview_fromslice')
  * cdef memoryview_fromslice(__Pyx_memviewslice memviewslice,             # <<<<<<<<<<<<<<
  *                           int ndim,
  *                           object (*to_object_func)(char *),
  */
 
@@ -15235,15 +15305,15 @@
   __Pyx_XDECREF((PyObject *)__pyx_v_result);
   __Pyx_XDECREF(__pyx_v_length);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1037
+/* "View.MemoryView":1048
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice):
  *     cdef _memoryviewslice obj
  */
 
@@ -15252,79 +15322,79 @@
   __Pyx_memviewslice *__pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   int __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   __Pyx_RefNannySetupContext("get_slice_from_memview", 0);
 
-  /* "View.MemoryView":1040
+  /* "View.MemoryView":1051
  *                                                    __Pyx_memviewslice *mslice):
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1041
+    /* "View.MemoryView":1052
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview             # <<<<<<<<<<<<<<
  *         return &obj.from_slice
  *     else:
  */
-    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(2, 1041, __pyx_L1_error)
+    if (!(likely(((((PyObject *)__pyx_v_memview)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type))))) __PYX_ERR(2, 1052, __pyx_L1_error)
     __pyx_t_3 = ((PyObject *)__pyx_v_memview);
     __Pyx_INCREF(__pyx_t_3);
     __pyx_v_obj = ((struct __pyx_memoryviewslice_obj *)__pyx_t_3);
     __pyx_t_3 = 0;
 
-    /* "View.MemoryView":1042
+    /* "View.MemoryView":1053
  *     if isinstance(memview, _memoryviewslice):
  *         obj = memview
  *         return &obj.from_slice             # <<<<<<<<<<<<<<
  *     else:
  *         slice_copy(memview, mslice)
  */
     __pyx_r = (&__pyx_v_obj->from_slice);
     goto __pyx_L0;
 
-    /* "View.MemoryView":1040
+    /* "View.MemoryView":1051
  *                                                    __Pyx_memviewslice *mslice):
  *     cdef _memoryviewslice obj
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         obj = memview
  *         return &obj.from_slice
  */
   }
 
-  /* "View.MemoryView":1044
+  /* "View.MemoryView":1055
  *         return &obj.from_slice
  *     else:
  *         slice_copy(memview, mslice)             # <<<<<<<<<<<<<<
  *         return mslice
  * 
  */
   /*else*/ {
     __pyx_memoryview_slice_copy(__pyx_v_memview, __pyx_v_mslice);
 
-    /* "View.MemoryView":1045
+    /* "View.MemoryView":1056
  *     else:
  *         slice_copy(memview, mslice)
  *         return mslice             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_slice_copy')
  */
     __pyx_r = __pyx_v_mslice;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1037
+  /* "View.MemoryView":1048
  * 
  * @cname('__pyx_memoryview_get_slice_from_memoryview')
  * cdef __Pyx_memviewslice *get_slice_from_memview(memoryview memview,             # <<<<<<<<<<<<<<
  *                                                    __Pyx_memviewslice *mslice):
  *     cdef _memoryviewslice obj
  */
 
@@ -15335,15 +15405,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_obj);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1048
+/* "View.MemoryView":1059
  * 
  * @cname('__pyx_memoryview_slice_copy')
  * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
@@ -15352,160 +15422,162 @@
   Py_ssize_t *__pyx_v_shape;
   Py_ssize_t *__pyx_v_strides;
   Py_ssize_t *__pyx_v_suboffsets;
   __Pyx_RefNannyDeclarations
   Py_ssize_t *__pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
-  Py_ssize_t __pyx_t_4;
+  int __pyx_t_4;
+  Py_ssize_t __pyx_t_5;
   __Pyx_RefNannySetupContext("slice_copy", 0);
 
-  /* "View.MemoryView":1052
+  /* "View.MemoryView":1063
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  * 
  *     shape = memview.view.shape             # <<<<<<<<<<<<<<
  *     strides = memview.view.strides
  *     suboffsets = memview.view.suboffsets
  */
   __pyx_t_1 = __pyx_v_memview->view.shape;
   __pyx_v_shape = __pyx_t_1;
 
-  /* "View.MemoryView":1053
+  /* "View.MemoryView":1064
  * 
  *     shape = memview.view.shape
  *     strides = memview.view.strides             # <<<<<<<<<<<<<<
  *     suboffsets = memview.view.suboffsets
  * 
  */
   __pyx_t_1 = __pyx_v_memview->view.strides;
   __pyx_v_strides = __pyx_t_1;
 
-  /* "View.MemoryView":1054
+  /* "View.MemoryView":1065
  *     shape = memview.view.shape
  *     strides = memview.view.strides
  *     suboffsets = memview.view.suboffsets             # <<<<<<<<<<<<<<
  * 
  *     dst.memview = <__pyx_memoryview *> memview
  */
   __pyx_t_1 = __pyx_v_memview->view.suboffsets;
   __pyx_v_suboffsets = __pyx_t_1;
 
-  /* "View.MemoryView":1056
+  /* "View.MemoryView":1067
  *     suboffsets = memview.view.suboffsets
  * 
  *     dst.memview = <__pyx_memoryview *> memview             # <<<<<<<<<<<<<<
  *     dst.data = <char *> memview.view.buf
  * 
  */
   __pyx_v_dst->memview = ((struct __pyx_memoryview_obj *)__pyx_v_memview);
 
-  /* "View.MemoryView":1057
+  /* "View.MemoryView":1068
  * 
  *     dst.memview = <__pyx_memoryview *> memview
  *     dst.data = <char *> memview.view.buf             # <<<<<<<<<<<<<<
  * 
  *     for dim in range(memview.view.ndim):
  */
   __pyx_v_dst->data = ((char *)__pyx_v_memview->view.buf);
 
-  /* "View.MemoryView":1059
+  /* "View.MemoryView":1070
  *     dst.data = <char *> memview.view.buf
  * 
  *     for dim in range(memview.view.ndim):             # <<<<<<<<<<<<<<
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]
  */
   __pyx_t_2 = __pyx_v_memview->view.ndim;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_dim = __pyx_t_3;
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_dim = __pyx_t_4;
 
-    /* "View.MemoryView":1060
+    /* "View.MemoryView":1071
  * 
  *     for dim in range(memview.view.ndim):
  *         dst.shape[dim] = shape[dim]             # <<<<<<<<<<<<<<
  *         dst.strides[dim] = strides[dim]
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1
  */
     (__pyx_v_dst->shape[__pyx_v_dim]) = (__pyx_v_shape[__pyx_v_dim]);
 
-    /* "View.MemoryView":1061
+    /* "View.MemoryView":1072
  *     for dim in range(memview.view.ndim):
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]             # <<<<<<<<<<<<<<
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1
  * 
  */
     (__pyx_v_dst->strides[__pyx_v_dim]) = (__pyx_v_strides[__pyx_v_dim]);
 
-    /* "View.MemoryView":1062
+    /* "View.MemoryView":1073
  *         dst.shape[dim] = shape[dim]
  *         dst.strides[dim] = strides[dim]
  *         dst.suboffsets[dim] = suboffsets[dim] if suboffsets else -1             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_object')
  */
     if ((__pyx_v_suboffsets != 0)) {
-      __pyx_t_4 = (__pyx_v_suboffsets[__pyx_v_dim]);
+      __pyx_t_5 = (__pyx_v_suboffsets[__pyx_v_dim]);
     } else {
-      __pyx_t_4 = -1L;
+      __pyx_t_5 = -1L;
     }
-    (__pyx_v_dst->suboffsets[__pyx_v_dim]) = __pyx_t_4;
+    (__pyx_v_dst->suboffsets[__pyx_v_dim]) = __pyx_t_5;
   }
 
-  /* "View.MemoryView":1048
+  /* "View.MemoryView":1059
  * 
  * @cname('__pyx_memoryview_slice_copy')
  * cdef void slice_copy(memoryview memview, __Pyx_memviewslice *dst):             # <<<<<<<<<<<<<<
  *     cdef int dim
  *     cdef (Py_ssize_t*) shape, strides, suboffsets
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":1065
+/* "View.MemoryView":1076
  * 
  * @cname('__pyx_memoryview_copy_object')
  * cdef memoryview_copy(memoryview memview):             # <<<<<<<<<<<<<<
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  */
 
 static PyObject *__pyx_memoryview_copy_object(struct __pyx_memoryview_obj *__pyx_v_memview) {
   __Pyx_memviewslice __pyx_v_memviewslice;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   __Pyx_RefNannySetupContext("memoryview_copy", 0);
 
-  /* "View.MemoryView":1068
+  /* "View.MemoryView":1079
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)             # <<<<<<<<<<<<<<
  *     return memoryview_copy_from_slice(memview, &memviewslice)
  * 
  */
   __pyx_memoryview_slice_copy(__pyx_v_memview, (&__pyx_v_memviewslice));
 
-  /* "View.MemoryView":1069
+  /* "View.MemoryView":1080
  *     cdef __Pyx_memviewslice memviewslice
  *     slice_copy(memview, &memviewslice)
  *     return memoryview_copy_from_slice(memview, &memviewslice)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1069, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_copy_object_from_slice(__pyx_v_memview, (&__pyx_v_memviewslice)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1080, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1065
+  /* "View.MemoryView":1076
  * 
  * @cname('__pyx_memoryview_copy_object')
  * cdef memoryview_copy(memoryview memview):             # <<<<<<<<<<<<<<
  *     "Create a new memoryview object"
  *     cdef __Pyx_memviewslice memviewslice
  */
 
@@ -15516,15 +15588,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1072
+/* "View.MemoryView":1083
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
@@ -15536,99 +15608,99 @@
   int __pyx_t_1;
   int __pyx_t_2;
   PyObject *(*__pyx_t_3)(char *);
   int (*__pyx_t_4)(char *, PyObject *);
   PyObject *__pyx_t_5 = NULL;
   __Pyx_RefNannySetupContext("memoryview_copy_from_slice", 0);
 
-  /* "View.MemoryView":1079
+  /* "View.MemoryView":1090
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
   __pyx_t_1 = __Pyx_TypeCheck(((PyObject *)__pyx_v_memview), __pyx_memoryviewslice_type); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1080
+    /* "View.MemoryView":1091
  * 
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func             # <<<<<<<<<<<<<<
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  */
     __pyx_t_3 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_object_func;
     __pyx_v_to_object_func = __pyx_t_3;
 
-    /* "View.MemoryView":1081
+    /* "View.MemoryView":1092
  *     if isinstance(memview, _memoryviewslice):
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func             # <<<<<<<<<<<<<<
  *     else:
  *         to_object_func = NULL
  */
     __pyx_t_4 = ((struct __pyx_memoryviewslice_obj *)__pyx_v_memview)->to_dtype_func;
     __pyx_v_to_dtype_func = __pyx_t_4;
 
-    /* "View.MemoryView":1079
+    /* "View.MemoryView":1090
  *     cdef int (*to_dtype_func)(char *, object) except 0
  * 
  *     if isinstance(memview, _memoryviewslice):             # <<<<<<<<<<<<<<
  *         to_object_func = (<_memoryviewslice> memview).to_object_func
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1083
+  /* "View.MemoryView":1094
  *         to_dtype_func = (<_memoryviewslice> memview).to_dtype_func
  *     else:
  *         to_object_func = NULL             # <<<<<<<<<<<<<<
  *         to_dtype_func = NULL
  * 
  */
   /*else*/ {
     __pyx_v_to_object_func = NULL;
 
-    /* "View.MemoryView":1084
+    /* "View.MemoryView":1095
  *     else:
  *         to_object_func = NULL
  *         to_dtype_func = NULL             # <<<<<<<<<<<<<<
  * 
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  */
     __pyx_v_to_dtype_func = NULL;
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1086
+  /* "View.MemoryView":1097
  *         to_dtype_func = NULL
  * 
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,             # <<<<<<<<<<<<<<
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)
  */
   __Pyx_XDECREF(__pyx_r);
 
-  /* "View.MemoryView":1088
+  /* "View.MemoryView":1099
  *     return memoryview_fromslice(memviewslice[0], memview.view.ndim,
  *                                 to_object_func, to_dtype_func,
  *                                 memview.dtype_is_object)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 1086, __pyx_L1_error)
+  __pyx_t_5 = __pyx_memoryview_fromslice((__pyx_v_memviewslice[0]), __pyx_v_memview->view.ndim, __pyx_v_to_object_func, __pyx_v_to_dtype_func, __pyx_v_memview->dtype_is_object); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 1097, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1072
+  /* "View.MemoryView":1083
  * 
  * @cname('__pyx_memoryview_copy_object_from_slice')
  * cdef memoryview_copy_from_slice(memoryview memview, __Pyx_memviewslice *memviewslice):             # <<<<<<<<<<<<<<
  *     """
  *     Create a new memoryview object from a given memoryview object and slice.
  */
 
@@ -15639,81 +15711,81 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "View.MemoryView":1094
+/* "View.MemoryView":1105
  * 
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
  *     if arg < 0:
  *         return -arg
  */
 
 static Py_ssize_t abs_py_ssize_t(Py_ssize_t __pyx_v_arg) {
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
 
-  /* "View.MemoryView":1095
+  /* "View.MemoryView":1106
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:             # <<<<<<<<<<<<<<
  *         return -arg
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_arg < 0) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1096
+    /* "View.MemoryView":1107
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:
  *         return -arg             # <<<<<<<<<<<<<<
  *     else:
  *         return arg
  */
     __pyx_r = (-__pyx_v_arg);
     goto __pyx_L0;
 
-    /* "View.MemoryView":1095
+    /* "View.MemoryView":1106
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:
  *     if arg < 0:             # <<<<<<<<<<<<<<
  *         return -arg
  *     else:
  */
   }
 
-  /* "View.MemoryView":1098
+  /* "View.MemoryView":1109
  *         return -arg
  *     else:
  *         return arg             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_get_best_slice_order')
  */
   /*else*/ {
     __pyx_r = __pyx_v_arg;
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1094
+  /* "View.MemoryView":1105
  * 
  * 
  * cdef Py_ssize_t abs_py_ssize_t(Py_ssize_t arg) nogil:             # <<<<<<<<<<<<<<
  *     if arg < 0:
  *         return -arg
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1101
+/* "View.MemoryView":1112
  * 
  * @cname('__pyx_get_best_slice_order')
  * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
@@ -15721,187 +15793,189 @@
   int __pyx_v_i;
   Py_ssize_t __pyx_v_c_stride;
   Py_ssize_t __pyx_v_f_stride;
   char __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
+  int __pyx_t_4;
 
-  /* "View.MemoryView":1106
+  /* "View.MemoryView":1117
  *     """
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t f_stride = 0
  * 
  */
   __pyx_v_c_stride = 0;
 
-  /* "View.MemoryView":1107
+  /* "View.MemoryView":1118
  *     cdef int i
  *     cdef Py_ssize_t c_stride = 0
  *     cdef Py_ssize_t f_stride = 0             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_f_stride = 0;
 
-  /* "View.MemoryView":1109
+  /* "View.MemoryView":1120
  *     cdef Py_ssize_t f_stride = 0
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  */
-  for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1L; __pyx_t_1-=1) {
+  for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1110
+    /* "View.MemoryView":1121
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1111
+      /* "View.MemoryView":1122
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_c_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1112
+      /* "View.MemoryView":1123
  *         if mslice.shape[i] > 1:
  *             c_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
       goto __pyx_L4_break;
 
-      /* "View.MemoryView":1110
+      /* "View.MemoryView":1121
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             c_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L4_break:;
 
-  /* "View.MemoryView":1114
+  /* "View.MemoryView":1125
  *             break
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  */
   __pyx_t_1 = __pyx_v_ndim;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_1; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_3 = __pyx_t_1;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1115
+    /* "View.MemoryView":1126
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     __pyx_t_2 = (((__pyx_v_mslice->shape[__pyx_v_i]) > 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1116
+      /* "View.MemoryView":1127
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]             # <<<<<<<<<<<<<<
  *             break
  * 
  */
       __pyx_v_f_stride = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-      /* "View.MemoryView":1117
+      /* "View.MemoryView":1128
  *         if mslice.shape[i] > 1:
  *             f_stride = mslice.strides[i]
  *             break             # <<<<<<<<<<<<<<
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  */
       goto __pyx_L7_break;
 
-      /* "View.MemoryView":1115
+      /* "View.MemoryView":1126
  * 
  *     for i in range(ndim):
  *         if mslice.shape[i] > 1:             # <<<<<<<<<<<<<<
  *             f_stride = mslice.strides[i]
  *             break
  */
     }
   }
   __pyx_L7_break:;
 
-  /* "View.MemoryView":1119
+  /* "View.MemoryView":1130
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   __pyx_t_2 = ((abs_py_ssize_t(__pyx_v_c_stride) <= abs_py_ssize_t(__pyx_v_f_stride)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1120
+    /* "View.MemoryView":1131
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):
  *         return 'C'             # <<<<<<<<<<<<<<
  *     else:
  *         return 'F'
  */
     __pyx_r = 'C';
     goto __pyx_L0;
 
-    /* "View.MemoryView":1119
+    /* "View.MemoryView":1130
  *             break
  * 
  *     if abs_py_ssize_t(c_stride) <= abs_py_ssize_t(f_stride):             # <<<<<<<<<<<<<<
  *         return 'C'
  *     else:
  */
   }
 
-  /* "View.MemoryView":1122
+  /* "View.MemoryView":1133
  *         return 'C'
  *     else:
  *         return 'F'             # <<<<<<<<<<<<<<
  * 
  * @cython.cdivision(True)
  */
   /*else*/ {
     __pyx_r = 'F';
     goto __pyx_L0;
   }
 
-  /* "View.MemoryView":1101
+  /* "View.MemoryView":1112
  * 
  * @cname('__pyx_get_best_slice_order')
  * cdef char get_best_order(__Pyx_memviewslice *mslice, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     Figure out the best memory access order for a given slice.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1125
+/* "View.MemoryView":1136
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
@@ -15912,62 +15986,63 @@
   Py_ssize_t __pyx_v_src_stride;
   Py_ssize_t __pyx_v_dst_stride;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   Py_ssize_t __pyx_t_5;
+  Py_ssize_t __pyx_t_6;
 
-  /* "View.MemoryView":1132
+  /* "View.MemoryView":1143
  * 
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  */
   __pyx_v_src_extent = (__pyx_v_src_shape[0]);
 
-  /* "View.MemoryView":1133
+  /* "View.MemoryView":1144
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  */
   __pyx_v_dst_extent = (__pyx_v_dst_shape[0]);
 
-  /* "View.MemoryView":1134
+  /* "View.MemoryView":1145
  *     cdef Py_ssize_t src_extent = src_shape[0]
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  */
   __pyx_v_src_stride = (__pyx_v_src_strides[0]);
 
-  /* "View.MemoryView":1135
+  /* "View.MemoryView":1146
  *     cdef Py_ssize_t dst_extent = dst_shape[0]
  *     cdef Py_ssize_t src_stride = src_strides[0]
  *     cdef Py_ssize_t dst_stride = dst_strides[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_dst_stride = (__pyx_v_dst_strides[0]);
 
-  /* "View.MemoryView":1137
+  /* "View.MemoryView":1148
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
   __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1138
+    /* "View.MemoryView":1149
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     __pyx_t_2 = ((__pyx_v_src_stride > 0) != 0);
@@ -15979,383 +16054,389 @@
     __pyx_t_2 = ((__pyx_v_dst_stride > 0) != 0);
     if (__pyx_t_2) {
     } else {
       __pyx_t_1 = __pyx_t_2;
       goto __pyx_L5_bool_binop_done;
     }
 
-    /* "View.MemoryView":1139
+    /* "View.MemoryView":1150
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):             # <<<<<<<<<<<<<<
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  *        else:
  */
     __pyx_t_2 = (((size_t)__pyx_v_src_stride) == __pyx_v_itemsize);
     if (__pyx_t_2) {
       __pyx_t_2 = (__pyx_v_itemsize == ((size_t)__pyx_v_dst_stride));
     }
     __pyx_t_3 = (__pyx_t_2 != 0);
     __pyx_t_1 = __pyx_t_3;
     __pyx_L5_bool_binop_done:;
 
-    /* "View.MemoryView":1138
+    /* "View.MemoryView":1149
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
     if (__pyx_t_1) {
 
-      /* "View.MemoryView":1140
+      /* "View.MemoryView":1151
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)             # <<<<<<<<<<<<<<
  *        else:
  *            for i in range(dst_extent):
  */
-      memcpy(__pyx_v_dst_data, __pyx_v_src_data, (__pyx_v_itemsize * __pyx_v_dst_extent));
+      (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, (__pyx_v_itemsize * __pyx_v_dst_extent)));
 
-      /* "View.MemoryView":1138
+      /* "View.MemoryView":1149
  * 
  *     if ndim == 1:
  *        if (src_stride > 0 and dst_stride > 0 and             # <<<<<<<<<<<<<<
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  */
       goto __pyx_L4;
     }
 
-    /* "View.MemoryView":1142
+    /* "View.MemoryView":1153
  *            memcpy(dst_data, src_data, itemsize * dst_extent)
  *        else:
  *            for i in range(dst_extent):             # <<<<<<<<<<<<<<
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride
  */
     /*else*/ {
       __pyx_t_4 = __pyx_v_dst_extent;
-      for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
-        __pyx_v_i = __pyx_t_5;
+      __pyx_t_5 = __pyx_t_4;
+      for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+        __pyx_v_i = __pyx_t_6;
 
-        /* "View.MemoryView":1143
+        /* "View.MemoryView":1154
  *        else:
  *            for i in range(dst_extent):
  *                memcpy(dst_data, src_data, itemsize)             # <<<<<<<<<<<<<<
  *                src_data += src_stride
  *                dst_data += dst_stride
  */
-        memcpy(__pyx_v_dst_data, __pyx_v_src_data, __pyx_v_itemsize);
+        (void)(memcpy(__pyx_v_dst_data, __pyx_v_src_data, __pyx_v_itemsize));
 
-        /* "View.MemoryView":1144
+        /* "View.MemoryView":1155
  *            for i in range(dst_extent):
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride             # <<<<<<<<<<<<<<
  *                dst_data += dst_stride
  *     else:
  */
         __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-        /* "View.MemoryView":1145
+        /* "View.MemoryView":1156
  *                memcpy(dst_data, src_data, itemsize)
  *                src_data += src_stride
  *                dst_data += dst_stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(dst_extent):
  */
         __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
       }
     }
     __pyx_L4:;
 
-    /* "View.MemoryView":1137
+    /* "View.MemoryView":1148
  *     cdef Py_ssize_t dst_stride = dst_strides[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *        if (src_stride > 0 and dst_stride > 0 and
  *            <size_t> src_stride == itemsize == <size_t> dst_stride):
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1147
+  /* "View.MemoryView":1158
  *                dst_data += dst_stride
  *     else:
  *         for i in range(dst_extent):             # <<<<<<<<<<<<<<
  *             _copy_strided_to_strided(src_data, src_strides + 1,
  *                                      dst_data, dst_strides + 1,
  */
   /*else*/ {
     __pyx_t_4 = __pyx_v_dst_extent;
-    for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
-      __pyx_v_i = __pyx_t_5;
+    __pyx_t_5 = __pyx_t_4;
+    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+      __pyx_v_i = __pyx_t_6;
 
-      /* "View.MemoryView":1148
+      /* "View.MemoryView":1159
  *     else:
  *         for i in range(dst_extent):
  *             _copy_strided_to_strided(src_data, src_strides + 1,             # <<<<<<<<<<<<<<
  *                                      dst_data, dst_strides + 1,
  *                                      src_shape + 1, dst_shape + 1,
  */
       _copy_strided_to_strided(__pyx_v_src_data, (__pyx_v_src_strides + 1), __pyx_v_dst_data, (__pyx_v_dst_strides + 1), (__pyx_v_src_shape + 1), (__pyx_v_dst_shape + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize);
 
-      /* "View.MemoryView":1152
+      /* "View.MemoryView":1163
  *                                      src_shape + 1, dst_shape + 1,
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride             # <<<<<<<<<<<<<<
  *             dst_data += dst_stride
  * 
  */
       __pyx_v_src_data = (__pyx_v_src_data + __pyx_v_src_stride);
 
-      /* "View.MemoryView":1153
+      /* "View.MemoryView":1164
  *                                      ndim - 1, itemsize)
  *             src_data += src_stride
  *             dst_data += dst_stride             # <<<<<<<<<<<<<<
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,
  */
       __pyx_v_dst_data = (__pyx_v_dst_data + __pyx_v_dst_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1125
+  /* "View.MemoryView":1136
  * 
  * @cython.cdivision(True)
  * cdef void _copy_strided_to_strided(char *src_data, Py_ssize_t *src_strides,             # <<<<<<<<<<<<<<
  *                                    char *dst_data, Py_ssize_t *dst_strides,
  *                                    Py_ssize_t *src_shape, Py_ssize_t *dst_shape,
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1155
+/* "View.MemoryView":1166
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  */
 
 static void copy_strided_to_strided(__Pyx_memviewslice *__pyx_v_src, __Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize) {
 
-  /* "View.MemoryView":1158
+  /* "View.MemoryView":1169
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  *     _copy_strided_to_strided(src.data, src.strides, dst.data, dst.strides,             # <<<<<<<<<<<<<<
  *                              src.shape, dst.shape, ndim, itemsize)
  * 
  */
   _copy_strided_to_strided(__pyx_v_src->data, __pyx_v_src->strides, __pyx_v_dst->data, __pyx_v_dst->strides, __pyx_v_src->shape, __pyx_v_dst->shape, __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1155
+  /* "View.MemoryView":1166
  *             dst_data += dst_stride
  * 
  * cdef void copy_strided_to_strided(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice *dst,
  *                                   int ndim, size_t itemsize) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1162
+/* "View.MemoryView":1173
  * 
  * @cname('__pyx_memoryview_slice_get_size')
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef int i
  */
 
 static Py_ssize_t __pyx_memoryview_slice_get_size(__Pyx_memviewslice *__pyx_v_src, int __pyx_v_ndim) {
   int __pyx_v_i;
   Py_ssize_t __pyx_v_size;
   Py_ssize_t __pyx_r;
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
+  int __pyx_t_4;
 
-  /* "View.MemoryView":1165
+  /* "View.MemoryView":1176
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef int i
  *     cdef Py_ssize_t size = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_size = __pyx_t_1;
 
-  /* "View.MemoryView":1167
+  /* "View.MemoryView":1178
  *     cdef Py_ssize_t size = src.memview.view.itemsize
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         size *= src.shape[i]
  * 
  */
   __pyx_t_2 = __pyx_v_ndim;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1168
+    /* "View.MemoryView":1179
  * 
  *     for i in range(ndim):
  *         size *= src.shape[i]             # <<<<<<<<<<<<<<
  * 
  *     return size
  */
     __pyx_v_size = (__pyx_v_size * (__pyx_v_src->shape[__pyx_v_i]));
   }
 
-  /* "View.MemoryView":1170
+  /* "View.MemoryView":1181
  *         size *= src.shape[i]
  * 
  *     return size             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_fill_contig_strides_array')
  */
   __pyx_r = __pyx_v_size;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1162
+  /* "View.MemoryView":1173
  * 
  * @cname('__pyx_memoryview_slice_get_size')
  * cdef Py_ssize_t slice_get_size(__Pyx_memviewslice *src, int ndim) nogil:             # <<<<<<<<<<<<<<
  *     "Return the size of the memory occupied by the slice in number of bytes"
  *     cdef int i
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1173
+/* "View.MemoryView":1184
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
  *                 int ndim, char order) nogil:
  */
 
 static Py_ssize_t __pyx_fill_contig_strides_array(Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, Py_ssize_t __pyx_v_stride, int __pyx_v_ndim, char __pyx_v_order) {
   int __pyx_v_idx;
   Py_ssize_t __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
+  int __pyx_t_4;
 
-  /* "View.MemoryView":1182
+  /* "View.MemoryView":1193
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
   __pyx_t_1 = ((__pyx_v_order == 'F') != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1183
+    /* "View.MemoryView":1194
  * 
  *     if order == 'F':
  *         for idx in range(ndim):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride = stride * shape[idx]
  */
     __pyx_t_2 = __pyx_v_ndim;
-    for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-      __pyx_v_idx = __pyx_t_3;
+    __pyx_t_3 = __pyx_t_2;
+    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+      __pyx_v_idx = __pyx_t_4;
 
-      /* "View.MemoryView":1184
+      /* "View.MemoryView":1195
  *     if order == 'F':
  *         for idx in range(ndim):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride = stride * shape[idx]
  *     else:
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1185
+      /* "View.MemoryView":1196
  *         for idx in range(ndim):
  *             strides[idx] = stride
  *             stride = stride * shape[idx]             # <<<<<<<<<<<<<<
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
 
-    /* "View.MemoryView":1182
+    /* "View.MemoryView":1193
  *     cdef int idx
  * 
  *     if order == 'F':             # <<<<<<<<<<<<<<
  *         for idx in range(ndim):
  *             strides[idx] = stride
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1187
+  /* "View.MemoryView":1198
  *             stride = stride * shape[idx]
  *     else:
  *         for idx in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *             strides[idx] = stride
  *             stride = stride * shape[idx]
  */
   /*else*/ {
-    for (__pyx_t_2 = (__pyx_v_ndim - 1); __pyx_t_2 > -1L; __pyx_t_2-=1) {
+    for (__pyx_t_2 = (__pyx_v_ndim - 1); __pyx_t_2 > -1; __pyx_t_2-=1) {
       __pyx_v_idx = __pyx_t_2;
 
-      /* "View.MemoryView":1188
+      /* "View.MemoryView":1199
  *     else:
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride             # <<<<<<<<<<<<<<
  *             stride = stride * shape[idx]
  * 
  */
       (__pyx_v_strides[__pyx_v_idx]) = __pyx_v_stride;
 
-      /* "View.MemoryView":1189
+      /* "View.MemoryView":1200
  *         for idx in range(ndim - 1, -1, -1):
  *             strides[idx] = stride
  *             stride = stride * shape[idx]             # <<<<<<<<<<<<<<
  * 
  *     return stride
  */
       __pyx_v_stride = (__pyx_v_stride * (__pyx_v_shape[__pyx_v_idx]));
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1191
+  /* "View.MemoryView":1202
  *             stride = stride * shape[idx]
  * 
  *     return stride             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  */
   __pyx_r = __pyx_v_stride;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1173
+  /* "View.MemoryView":1184
  * 
  * @cname('__pyx_fill_contig_strides_array')
  * cdef Py_ssize_t fill_contig_strides_array(             # <<<<<<<<<<<<<<
  *                 Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t stride,
  *                 int ndim, char order) nogil:
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1194
+/* "View.MemoryView":1205
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
@@ -16366,221 +16447,224 @@
   size_t __pyx_v_size;
   void *__pyx_r;
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   struct __pyx_memoryview_obj *__pyx_t_4;
   int __pyx_t_5;
+  int __pyx_t_6;
 
-  /* "View.MemoryView":1205
+  /* "View.MemoryView":1216
  *     cdef void *result
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  */
   __pyx_t_1 = __pyx_v_src->memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1206
+  /* "View.MemoryView":1217
  * 
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef size_t size = slice_get_size(src, ndim)             # <<<<<<<<<<<<<<
  * 
  *     result = malloc(size)
  */
   __pyx_v_size = __pyx_memoryview_slice_get_size(__pyx_v_src, __pyx_v_ndim);
 
-  /* "View.MemoryView":1208
+  /* "View.MemoryView":1219
  *     cdef size_t size = slice_get_size(src, ndim)
  * 
  *     result = malloc(size)             # <<<<<<<<<<<<<<
  *     if not result:
  *         _err(MemoryError, NULL)
  */
   __pyx_v_result = malloc(__pyx_v_size);
 
-  /* "View.MemoryView":1209
+  /* "View.MemoryView":1220
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_result != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1210
+    /* "View.MemoryView":1221
  *     result = malloc(size)
  *     if not result:
  *         _err(MemoryError, NULL)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 1210, __pyx_L1_error)
+    __pyx_t_3 = __pyx_memoryview_err(__pyx_builtin_MemoryError, NULL); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(2, 1221, __pyx_L1_error)
 
-    /* "View.MemoryView":1209
+    /* "View.MemoryView":1220
  * 
  *     result = malloc(size)
  *     if not result:             # <<<<<<<<<<<<<<
  *         _err(MemoryError, NULL)
  * 
  */
   }
 
-  /* "View.MemoryView":1213
+  /* "View.MemoryView":1224
  * 
  * 
  *     tmpslice.data = <char *> result             # <<<<<<<<<<<<<<
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  */
   __pyx_v_tmpslice->data = ((char *)__pyx_v_result);
 
-  /* "View.MemoryView":1214
+  /* "View.MemoryView":1225
  * 
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview             # <<<<<<<<<<<<<<
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  */
   __pyx_t_4 = __pyx_v_src->memview;
   __pyx_v_tmpslice->memview = __pyx_t_4;
 
-  /* "View.MemoryView":1215
+  /* "View.MemoryView":1226
  *     tmpslice.data = <char *> result
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1
  */
   __pyx_t_3 = __pyx_v_ndim;
-  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_3; __pyx_t_5+=1) {
-    __pyx_v_i = __pyx_t_5;
+  __pyx_t_5 = __pyx_t_3;
+  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+    __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1216
+    /* "View.MemoryView":1227
  *     tmpslice.memview = src.memview
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]             # <<<<<<<<<<<<<<
  *         tmpslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_tmpslice->shape[__pyx_v_i]) = (__pyx_v_src->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1217
+    /* "View.MemoryView":1228
  *     for i in range(ndim):
  *         tmpslice.shape[i] = src.shape[i]
  *         tmpslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
  *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,
  */
     (__pyx_v_tmpslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1219
+  /* "View.MemoryView":1230
  *         tmpslice.suboffsets[i] = -1
  * 
  *     fill_contig_strides_array(&tmpslice.shape[0], &tmpslice.strides[0], itemsize,             # <<<<<<<<<<<<<<
  *                               ndim, order)
  * 
  */
-  __pyx_fill_contig_strides_array((&(__pyx_v_tmpslice->shape[0])), (&(__pyx_v_tmpslice->strides[0])), __pyx_v_itemsize, __pyx_v_ndim, __pyx_v_order);
+  (void)(__pyx_fill_contig_strides_array((&(__pyx_v_tmpslice->shape[0])), (&(__pyx_v_tmpslice->strides[0])), __pyx_v_itemsize, __pyx_v_ndim, __pyx_v_order));
 
-  /* "View.MemoryView":1223
+  /* "View.MemoryView":1234
  * 
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0
  */
   __pyx_t_3 = __pyx_v_ndim;
-  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_3; __pyx_t_5+=1) {
-    __pyx_v_i = __pyx_t_5;
+  __pyx_t_5 = __pyx_t_3;
+  for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
+    __pyx_v_i = __pyx_t_6;
 
-    /* "View.MemoryView":1224
+    /* "View.MemoryView":1235
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
     __pyx_t_2 = (((__pyx_v_tmpslice->shape[__pyx_v_i]) == 1) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1225
+      /* "View.MemoryView":1236
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:
  *             tmpslice.strides[i] = 0             # <<<<<<<<<<<<<<
  * 
  *     if slice_is_contig(src[0], order, ndim):
  */
       (__pyx_v_tmpslice->strides[__pyx_v_i]) = 0;
 
-      /* "View.MemoryView":1224
+      /* "View.MemoryView":1235
  * 
  *     for i in range(ndim):
  *         if tmpslice.shape[i] == 1:             # <<<<<<<<<<<<<<
  *             tmpslice.strides[i] = 0
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1227
+  /* "View.MemoryView":1238
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
   __pyx_t_2 = (__pyx_memviewslice_is_contig((__pyx_v_src[0]), __pyx_v_order, __pyx_v_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1228
+    /* "View.MemoryView":1239
  * 
  *     if slice_is_contig(src[0], order, ndim):
  *         memcpy(result, src.data, size)             # <<<<<<<<<<<<<<
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  */
-    memcpy(__pyx_v_result, __pyx_v_src->data, __pyx_v_size);
+    (void)(memcpy(__pyx_v_result, __pyx_v_src->data, __pyx_v_size));
 
-    /* "View.MemoryView":1227
+    /* "View.MemoryView":1238
  *             tmpslice.strides[i] = 0
  * 
  *     if slice_is_contig(src[0], order, ndim):             # <<<<<<<<<<<<<<
  *         memcpy(result, src.data, size)
  *     else:
  */
     goto __pyx_L9;
   }
 
-  /* "View.MemoryView":1230
+  /* "View.MemoryView":1241
  *         memcpy(result, src.data, size)
  *     else:
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)             # <<<<<<<<<<<<<<
  * 
  *     return result
  */
   /*else*/ {
     copy_strided_to_strided(__pyx_v_src, __pyx_v_tmpslice, __pyx_v_ndim, __pyx_v_itemsize);
   }
   __pyx_L9:;
 
-  /* "View.MemoryView":1232
+  /* "View.MemoryView":1243
  *         copy_strided_to_strided(src, tmpslice, ndim, itemsize)
  * 
  *     return result             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = __pyx_v_result;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1194
+  /* "View.MemoryView":1205
  * 
  * @cname('__pyx_memoryview_copy_data_to_temp')
  * cdef void *copy_data_to_temp(__Pyx_memviewslice *src,             # <<<<<<<<<<<<<<
  *                              __Pyx_memviewslice *tmpslice,
  *                              char order,
  */
 
@@ -16596,15 +16680,15 @@
     #endif
   }
   __pyx_r = NULL;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1237
+/* "View.MemoryView":1248
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
@@ -16616,62 +16700,57 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_extents", 0);
 
-  /* "View.MemoryView":1240
+  /* "View.MemoryView":1251
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  *                                                         (i, extent1, extent2))             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err_dim')
  */
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1240, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1251, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1240, __pyx_L1_error)
+  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_extent1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1251, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1240, __pyx_L1_error)
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_extent2); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1251, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 1240, __pyx_L1_error)
+  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 1251, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
   __pyx_t_1 = 0;
   __pyx_t_2 = 0;
   __pyx_t_3 = 0;
 
-  /* "View.MemoryView":1239
+  /* "View.MemoryView":1250
  * cdef int _err_extents(int i, Py_ssize_t extent1,
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %             # <<<<<<<<<<<<<<
  *                                                         (i, extent1, extent2))
  * 
  */
-  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1239, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1250, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 1239, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 1250, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_3);
-  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
-  __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1239, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_Raise(__pyx_t_3, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __PYX_ERR(2, 1239, __pyx_L1_error)
+  __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __PYX_ERR(2, 1250, __pyx_L1_error)
 
-  /* "View.MemoryView":1237
+  /* "View.MemoryView":1248
  * 
  * @cname('__pyx_memoryview_err_extents')
  * cdef int _err_extents(int i, Py_ssize_t extent1,             # <<<<<<<<<<<<<<
  *                              Py_ssize_t extent2) except -1 with gil:
  *     raise ValueError("got differing extents in dimension %d (got %d and %d)" %
  */
 
@@ -16686,128 +16765,96 @@
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1243
+/* "View.MemoryView":1254
  * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
 static int __pyx_memoryview_err_dim(PyObject *__pyx_v_error, char *__pyx_v_msg, int __pyx_v_dim) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err_dim", 0);
   __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1244
+  /* "View.MemoryView":1255
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:
  *     raise error(msg.decode('ascii') % dim)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_err')
  */
-  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1244, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1255, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1244, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_dim); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1255, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 1244, __pyx_L1_error)
+  __pyx_t_4 = PyUnicode_Format(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 1255, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_INCREF(__pyx_v_error);
   __pyx_t_3 = __pyx_v_error; __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
-  if (!__pyx_t_2) {
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1244, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_GOTREF(__pyx_t_1);
-  } else {
-    #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(__pyx_t_3)) {
-      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_t_4};
-      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1244, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    } else
-    #endif
-    #if CYTHON_FAST_PYCCALL
-    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
-      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_t_4};
-      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1244, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    } else
-    #endif
-    {
-      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(2, 1244, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
-      __Pyx_GIVEREF(__pyx_t_4);
-      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_4);
-      __pyx_t_4 = 0;
-      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1244, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    }
-  }
+  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1255, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(2, 1244, __pyx_L1_error)
+  __PYX_ERR(2, 1255, __pyx_L1_error)
 
-  /* "View.MemoryView":1243
+  /* "View.MemoryView":1254
  * 
  * @cname('__pyx_memoryview_err_dim')
  * cdef int _err_dim(object error, char *msg, int dim) except -1 with gil:             # <<<<<<<<<<<<<<
  *     raise error(msg.decode('ascii') % dim)
  * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
   __Pyx_AddTraceback("View.MemoryView._err_dim", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __Pyx_XDECREF(__pyx_v_error);
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1247
+/* "View.MemoryView":1258
  * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))
  */
 
@@ -16815,138 +16862,106 @@
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("_err", 0);
   __Pyx_INCREF(__pyx_v_error);
 
-  /* "View.MemoryView":1248
+  /* "View.MemoryView":1259
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:             # <<<<<<<<<<<<<<
  *         raise error(msg.decode('ascii'))
  *     else:
  */
   __pyx_t_1 = ((__pyx_v_msg != NULL) != 0);
-  if (__pyx_t_1) {
+  if (unlikely(__pyx_t_1)) {
 
-    /* "View.MemoryView":1249
+    /* "View.MemoryView":1260
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))             # <<<<<<<<<<<<<<
  *     else:
  *         raise error
  */
-    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1249, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeASCII); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 1260, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_INCREF(__pyx_v_error);
     __pyx_t_4 = __pyx_v_error; __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_4, function);
       }
     }
-    if (!__pyx_t_5) {
-      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1249, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __Pyx_GOTREF(__pyx_t_2);
-    } else {
-      #if CYTHON_FAST_PYCALL
-      if (PyFunction_Check(__pyx_t_4)) {
-        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_3};
-        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1249, __pyx_L1_error)
-        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __Pyx_GOTREF(__pyx_t_2);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      } else
-      #endif
-      #if CYTHON_FAST_PYCCALL
-      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
-        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_3};
-        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1249, __pyx_L1_error)
-        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __Pyx_GOTREF(__pyx_t_2);
-        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      } else
-      #endif
-      {
-        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 1249, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_6);
-        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
-        __Pyx_GIVEREF(__pyx_t_3);
-        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_3);
-        __pyx_t_3 = 0;
-        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1249, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_2);
-        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      }
-    }
+    __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 1260, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_2, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(2, 1249, __pyx_L1_error)
+    __PYX_ERR(2, 1260, __pyx_L1_error)
 
-    /* "View.MemoryView":1248
+    /* "View.MemoryView":1259
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:
  *     if msg != NULL:             # <<<<<<<<<<<<<<
  *         raise error(msg.decode('ascii'))
  *     else:
  */
   }
 
-  /* "View.MemoryView":1251
+  /* "View.MemoryView":1262
  *         raise error(msg.decode('ascii'))
  *     else:
  *         raise error             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_copy_contents')
  */
   /*else*/ {
     __Pyx_Raise(__pyx_v_error, 0, 0, 0);
-    __PYX_ERR(2, 1251, __pyx_L1_error)
+    __PYX_ERR(2, 1262, __pyx_L1_error)
   }
 
-  /* "View.MemoryView":1247
+  /* "View.MemoryView":1258
  * 
  * @cname('__pyx_memoryview_err')
  * cdef int _err(object error, char *msg) except -1 with gil:             # <<<<<<<<<<<<<<
  *     if msg != NULL:
  *         raise error(msg.decode('ascii'))
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView._err", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __Pyx_XDECREF(__pyx_v_error);
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
   return __pyx_r;
 }
 
-/* "View.MemoryView":1254
+/* "View.MemoryView":1265
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
@@ -16961,122 +16976,123 @@
   int __pyx_v_ndim;
   int __pyx_r;
   Py_ssize_t __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
-  void *__pyx_t_6;
-  int __pyx_t_7;
+  int __pyx_t_6;
+  void *__pyx_t_7;
+  int __pyx_t_8;
 
-  /* "View.MemoryView":1262
+  /* "View.MemoryView":1273
  *     Check for overlapping memory and verify the shapes.
  *     """
  *     cdef void *tmpdata = NULL             # <<<<<<<<<<<<<<
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  */
   __pyx_v_tmpdata = NULL;
 
-  /* "View.MemoryView":1263
+  /* "View.MemoryView":1274
  *     """
  *     cdef void *tmpdata = NULL
  *     cdef size_t itemsize = src.memview.view.itemsize             # <<<<<<<<<<<<<<
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  */
   __pyx_t_1 = __pyx_v_src.memview->view.itemsize;
   __pyx_v_itemsize = __pyx_t_1;
 
-  /* "View.MemoryView":1265
+  /* "View.MemoryView":1276
  *     cdef size_t itemsize = src.memview.view.itemsize
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)             # <<<<<<<<<<<<<<
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False
  */
   __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_src), __pyx_v_src_ndim);
 
-  /* "View.MemoryView":1266
+  /* "View.MemoryView":1277
  *     cdef int i
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False             # <<<<<<<<<<<<<<
  *     cdef bint direct_copy = False
  *     cdef __Pyx_memviewslice tmp
  */
   __pyx_v_broadcasting = 0;
 
-  /* "View.MemoryView":1267
+  /* "View.MemoryView":1278
  *     cdef char order = get_best_order(&src, src_ndim)
  *     cdef bint broadcasting = False
  *     cdef bint direct_copy = False             # <<<<<<<<<<<<<<
  *     cdef __Pyx_memviewslice tmp
  * 
  */
   __pyx_v_direct_copy = 0;
 
-  /* "View.MemoryView":1270
+  /* "View.MemoryView":1281
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
   __pyx_t_2 = ((__pyx_v_src_ndim < __pyx_v_dst_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1271
+    /* "View.MemoryView":1282
  * 
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_src), __pyx_v_src_ndim, __pyx_v_dst_ndim);
 
-    /* "View.MemoryView":1270
+    /* "View.MemoryView":1281
  *     cdef __Pyx_memviewslice tmp
  * 
  *     if src_ndim < dst_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1272
+  /* "View.MemoryView":1283
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
   __pyx_t_2 = ((__pyx_v_dst_ndim < __pyx_v_src_ndim) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1273
+    /* "View.MemoryView":1284
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:
  *         broadcast_leading(&dst, dst_ndim, src_ndim)             # <<<<<<<<<<<<<<
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)
  */
     __pyx_memoryview_broadcast_leading((&__pyx_v_dst), __pyx_v_dst_ndim, __pyx_v_src_ndim);
 
-    /* "View.MemoryView":1272
+    /* "View.MemoryView":1283
  *     if src_ndim < dst_ndim:
  *         broadcast_leading(&src, src_ndim, dst_ndim)
  *     elif dst_ndim < src_ndim:             # <<<<<<<<<<<<<<
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  */
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1275
+  /* "View.MemoryView":1286
  *         broadcast_leading(&dst, dst_ndim, src_ndim)
  * 
  *     cdef int ndim = max(src_ndim, dst_ndim)             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim):
  */
   __pyx_t_3 = __pyx_v_dst_ndim;
@@ -17084,419 +17100,420 @@
   if (((__pyx_t_3 > __pyx_t_4) != 0)) {
     __pyx_t_5 = __pyx_t_3;
   } else {
     __pyx_t_5 = __pyx_t_4;
   }
   __pyx_v_ndim = __pyx_t_5;
 
-  /* "View.MemoryView":1277
+  /* "View.MemoryView":1288
  *     cdef int ndim = max(src_ndim, dst_ndim)
  * 
  *     for i in range(ndim):             # <<<<<<<<<<<<<<
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  */
   __pyx_t_5 = __pyx_v_ndim;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_5; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_3 = __pyx_t_5;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
 
-    /* "View.MemoryView":1278
+    /* "View.MemoryView":1289
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) != (__pyx_v_dst.shape[__pyx_v_i])) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1279
+      /* "View.MemoryView":1290
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
       __pyx_t_2 = (((__pyx_v_src.shape[__pyx_v_i]) == 1) != 0);
       if (__pyx_t_2) {
 
-        /* "View.MemoryView":1280
+        /* "View.MemoryView":1291
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:
  *                 broadcasting = True             # <<<<<<<<<<<<<<
  *                 src.strides[i] = 0
  *             else:
  */
         __pyx_v_broadcasting = 1;
 
-        /* "View.MemoryView":1281
+        /* "View.MemoryView":1292
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  *                 src.strides[i] = 0             # <<<<<<<<<<<<<<
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  */
         (__pyx_v_src.strides[__pyx_v_i]) = 0;
 
-        /* "View.MemoryView":1279
+        /* "View.MemoryView":1290
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:
  *             if src.shape[i] == 1:             # <<<<<<<<<<<<<<
  *                 broadcasting = True
  *                 src.strides[i] = 0
  */
         goto __pyx_L7;
       }
 
-      /* "View.MemoryView":1283
+      /* "View.MemoryView":1294
  *                 src.strides[i] = 0
  *             else:
  *                 _err_extents(i, dst.shape[i], src.shape[i])             # <<<<<<<<<<<<<<
  * 
  *         if src.suboffsets[i] >= 0:
  */
       /*else*/ {
-        __pyx_t_4 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 1283, __pyx_L1_error)
+        __pyx_t_6 = __pyx_memoryview_err_extents(__pyx_v_i, (__pyx_v_dst.shape[__pyx_v_i]), (__pyx_v_src.shape[__pyx_v_i])); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(2, 1294, __pyx_L1_error)
       }
       __pyx_L7:;
 
-      /* "View.MemoryView":1278
+      /* "View.MemoryView":1289
  * 
  *     for i in range(ndim):
  *         if src.shape[i] != dst.shape[i]:             # <<<<<<<<<<<<<<
  *             if src.shape[i] == 1:
  *                 broadcasting = True
  */
     }
 
-    /* "View.MemoryView":1285
+    /* "View.MemoryView":1296
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
     __pyx_t_2 = (((__pyx_v_src.suboffsets[__pyx_v_i]) >= 0) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1286
+      /* "View.MemoryView":1297
  * 
  *         if src.suboffsets[i] >= 0:
  *             _err_dim(ValueError, "Dimension %d is not direct", i)             # <<<<<<<<<<<<<<
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  */
-      __pyx_t_4 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 1286, __pyx_L1_error)
+      __pyx_t_6 = __pyx_memoryview_err_dim(__pyx_builtin_ValueError, ((char *)"Dimension %d is not direct"), __pyx_v_i); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(2, 1297, __pyx_L1_error)
 
-      /* "View.MemoryView":1285
+      /* "View.MemoryView":1296
  *                 _err_extents(i, dst.shape[i], src.shape[i])
  * 
  *         if src.suboffsets[i] >= 0:             # <<<<<<<<<<<<<<
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  */
     }
   }
 
-  /* "View.MemoryView":1288
+  /* "View.MemoryView":1299
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
   __pyx_t_2 = (__pyx_slices_overlap((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1290
+    /* "View.MemoryView":1301
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
     __pyx_t_2 = ((!(__pyx_memviewslice_is_contig(__pyx_v_src, __pyx_v_order, __pyx_v_ndim) != 0)) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1291
+      /* "View.MemoryView":1302
  * 
  *         if not slice_is_contig(src, order, ndim):
  *             order = get_best_order(&dst, ndim)             # <<<<<<<<<<<<<<
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  */
       __pyx_v_order = __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim);
 
-      /* "View.MemoryView":1290
+      /* "View.MemoryView":1301
  *     if slices_overlap(&src, &dst, ndim, itemsize):
  * 
  *         if not slice_is_contig(src, order, ndim):             # <<<<<<<<<<<<<<
  *             order = get_best_order(&dst, ndim)
  * 
  */
     }
 
-    /* "View.MemoryView":1293
+    /* "View.MemoryView":1304
  *             order = get_best_order(&dst, ndim)
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)             # <<<<<<<<<<<<<<
  *         src = tmp
  * 
  */
-    __pyx_t_6 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_6 == ((void *)NULL))) __PYX_ERR(2, 1293, __pyx_L1_error)
-    __pyx_v_tmpdata = __pyx_t_6;
+    __pyx_t_7 = __pyx_memoryview_copy_data_to_temp((&__pyx_v_src), (&__pyx_v_tmp), __pyx_v_order, __pyx_v_ndim); if (unlikely(__pyx_t_7 == ((void *)NULL))) __PYX_ERR(2, 1304, __pyx_L1_error)
+    __pyx_v_tmpdata = __pyx_t_7;
 
-    /* "View.MemoryView":1294
+    /* "View.MemoryView":1305
  * 
  *         tmpdata = copy_data_to_temp(&src, &tmp, order, ndim)
  *         src = tmp             # <<<<<<<<<<<<<<
  * 
  *     if not broadcasting:
  */
     __pyx_v_src = __pyx_v_tmp;
 
-    /* "View.MemoryView":1288
+    /* "View.MemoryView":1299
  *             _err_dim(ValueError, "Dimension %d is not direct", i)
  * 
  *     if slices_overlap(&src, &dst, ndim, itemsize):             # <<<<<<<<<<<<<<
  * 
  *         if not slice_is_contig(src, order, ndim):
  */
   }
 
-  /* "View.MemoryView":1296
+  /* "View.MemoryView":1307
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = ((!(__pyx_v_broadcasting != 0)) != 0);
   if (__pyx_t_2) {
 
-    /* "View.MemoryView":1299
+    /* "View.MemoryView":1310
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
     __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'C', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1300
+      /* "View.MemoryView":1311
  * 
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)             # <<<<<<<<<<<<<<
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'C', __pyx_v_ndim);
 
-      /* "View.MemoryView":1299
+      /* "View.MemoryView":1310
  * 
  * 
  *         if slice_is_contig(src, 'C', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  */
       goto __pyx_L12;
     }
 
-    /* "View.MemoryView":1301
+    /* "View.MemoryView":1312
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
     __pyx_t_2 = (__pyx_memviewslice_is_contig(__pyx_v_src, 'F', __pyx_v_ndim) != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1302
+      /* "View.MemoryView":1313
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):
  *             direct_copy = slice_is_contig(dst, 'F', ndim)             # <<<<<<<<<<<<<<
  * 
  *         if direct_copy:
  */
       __pyx_v_direct_copy = __pyx_memviewslice_is_contig(__pyx_v_dst, 'F', __pyx_v_ndim);
 
-      /* "View.MemoryView":1301
+      /* "View.MemoryView":1312
  *         if slice_is_contig(src, 'C', ndim):
  *             direct_copy = slice_is_contig(dst, 'C', ndim)
  *         elif slice_is_contig(src, 'F', ndim):             # <<<<<<<<<<<<<<
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  */
     }
     __pyx_L12:;
 
-    /* "View.MemoryView":1304
+    /* "View.MemoryView":1315
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     __pyx_t_2 = (__pyx_v_direct_copy != 0);
     if (__pyx_t_2) {
 
-      /* "View.MemoryView":1306
+      /* "View.MemoryView":1317
  *         if direct_copy:
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-      /* "View.MemoryView":1307
+      /* "View.MemoryView":1318
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))             # <<<<<<<<<<<<<<
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  */
-      memcpy(__pyx_v_dst.data, __pyx_v_src.data, __pyx_memoryview_slice_get_size((&__pyx_v_src), __pyx_v_ndim));
+      (void)(memcpy(__pyx_v_dst.data, __pyx_v_src.data, __pyx_memoryview_slice_get_size((&__pyx_v_src), __pyx_v_ndim)));
 
-      /* "View.MemoryView":1308
+      /* "View.MemoryView":1319
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  *             free(tmpdata)
  *             return 0
  */
       __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-      /* "View.MemoryView":1309
+      /* "View.MemoryView":1320
  *             memcpy(dst.data, src.data, slice_get_size(&src, ndim))
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)             # <<<<<<<<<<<<<<
  *             return 0
  * 
  */
       free(__pyx_v_tmpdata);
 
-      /* "View.MemoryView":1310
+      /* "View.MemoryView":1321
  *             refcount_copying(&dst, dtype_is_object, ndim, True)
  *             free(tmpdata)
  *             return 0             # <<<<<<<<<<<<<<
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):
  */
       __pyx_r = 0;
       goto __pyx_L0;
 
-      /* "View.MemoryView":1304
+      /* "View.MemoryView":1315
  *             direct_copy = slice_is_contig(dst, 'F', ndim)
  * 
  *         if direct_copy:             # <<<<<<<<<<<<<<
  * 
  *             refcount_copying(&dst, dtype_is_object, ndim, False)
  */
     }
 
-    /* "View.MemoryView":1296
+    /* "View.MemoryView":1307
  *         src = tmp
  * 
  *     if not broadcasting:             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1312
+  /* "View.MemoryView":1323
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_2 = (__pyx_v_order == 'F');
   if (__pyx_t_2) {
     __pyx_t_2 = ('F' == __pyx_get_best_slice_order((&__pyx_v_dst), __pyx_v_ndim));
   }
-  __pyx_t_7 = (__pyx_t_2 != 0);
-  if (__pyx_t_7) {
+  __pyx_t_8 = (__pyx_t_2 != 0);
+  if (__pyx_t_8) {
 
-    /* "View.MemoryView":1315
+    /* "View.MemoryView":1326
  * 
  * 
  *         transpose_memslice(&src)             # <<<<<<<<<<<<<<
  *         transpose_memslice(&dst)
  * 
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(2, 1315, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_src)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(2, 1326, __pyx_L1_error)
 
-    /* "View.MemoryView":1316
+    /* "View.MemoryView":1327
  * 
  *         transpose_memslice(&src)
  *         transpose_memslice(&dst)             # <<<<<<<<<<<<<<
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  */
-    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(2, 1316, __pyx_L1_error)
+    __pyx_t_5 = __pyx_memslice_transpose((&__pyx_v_dst)); if (unlikely(__pyx_t_5 == ((int)0))) __PYX_ERR(2, 1327, __pyx_L1_error)
 
-    /* "View.MemoryView":1312
+    /* "View.MemoryView":1323
  *             return 0
  * 
  *     if order == 'F' == get_best_order(&dst, ndim):             # <<<<<<<<<<<<<<
  * 
  * 
  */
   }
 
-  /* "View.MemoryView":1318
+  /* "View.MemoryView":1329
  *         transpose_memslice(&dst)
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1319
+  /* "View.MemoryView":1330
  * 
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)             # <<<<<<<<<<<<<<
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  */
   copy_strided_to_strided((&__pyx_v_src), (&__pyx_v_dst), __pyx_v_ndim, __pyx_v_itemsize);
 
-  /* "View.MemoryView":1320
+  /* "View.MemoryView":1331
  *     refcount_copying(&dst, dtype_is_object, ndim, False)
  *     copy_strided_to_strided(&src, &dst, ndim, itemsize)
  *     refcount_copying(&dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  *     free(tmpdata)
  */
   __pyx_memoryview_refcount_copying((&__pyx_v_dst), __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1322
+  /* "View.MemoryView":1333
  *     refcount_copying(&dst, dtype_is_object, ndim, True)
  * 
  *     free(tmpdata)             # <<<<<<<<<<<<<<
  *     return 0
  * 
  */
   free(__pyx_v_tmpdata);
 
-  /* "View.MemoryView":1323
+  /* "View.MemoryView":1334
  * 
  *     free(tmpdata)
  *     return 0             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  */
   __pyx_r = 0;
   goto __pyx_L0;
 
-  /* "View.MemoryView":1254
+  /* "View.MemoryView":1265
  * 
  * @cname('__pyx_memoryview_copy_contents')
  * cdef int memoryview_copy_contents(__Pyx_memviewslice src,             # <<<<<<<<<<<<<<
  *                                   __Pyx_memviewslice dst,
  *                                   int src_ndim, int dst_ndim,
  */
 
@@ -17512,529 +17529,536 @@
     #endif
   }
   __pyx_r = -1;
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "View.MemoryView":1326
+/* "View.MemoryView":1337
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
  *                             int ndim_other) nogil:
  */
 
 static void __pyx_memoryview_broadcast_leading(__Pyx_memviewslice *__pyx_v_mslice, int __pyx_v_ndim, int __pyx_v_ndim_other) {
   int __pyx_v_i;
   int __pyx_v_offset;
   int __pyx_t_1;
   int __pyx_t_2;
+  int __pyx_t_3;
 
-  /* "View.MemoryView":1330
+  /* "View.MemoryView":1341
  *                             int ndim_other) nogil:
  *     cdef int i
  *     cdef int offset = ndim_other - ndim             # <<<<<<<<<<<<<<
  * 
  *     for i in range(ndim - 1, -1, -1):
  */
   __pyx_v_offset = (__pyx_v_ndim_other - __pyx_v_ndim);
 
-  /* "View.MemoryView":1332
+  /* "View.MemoryView":1343
  *     cdef int offset = ndim_other - ndim
  * 
  *     for i in range(ndim - 1, -1, -1):             # <<<<<<<<<<<<<<
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  */
-  for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1L; __pyx_t_1-=1) {
+  for (__pyx_t_1 = (__pyx_v_ndim - 1); __pyx_t_1 > -1; __pyx_t_1-=1) {
     __pyx_v_i = __pyx_t_1;
 
-    /* "View.MemoryView":1333
+    /* "View.MemoryView":1344
  * 
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]             # <<<<<<<<<<<<<<
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  */
     (__pyx_v_mslice->shape[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->shape[__pyx_v_i]);
 
-    /* "View.MemoryView":1334
+    /* "View.MemoryView":1345
  *     for i in range(ndim - 1, -1, -1):
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  */
     (__pyx_v_mslice->strides[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->strides[__pyx_v_i]);
 
-    /* "View.MemoryView":1335
+    /* "View.MemoryView":1346
  *         mslice.shape[i + offset] = mslice.shape[i]
  *         mslice.strides[i + offset] = mslice.strides[i]
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]             # <<<<<<<<<<<<<<
  * 
  *     for i in range(offset):
  */
     (__pyx_v_mslice->suboffsets[(__pyx_v_i + __pyx_v_offset)]) = (__pyx_v_mslice->suboffsets[__pyx_v_i]);
   }
 
-  /* "View.MemoryView":1337
+  /* "View.MemoryView":1348
  *         mslice.suboffsets[i + offset] = mslice.suboffsets[i]
  * 
  *     for i in range(offset):             # <<<<<<<<<<<<<<
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  */
   __pyx_t_1 = __pyx_v_offset;
-  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
-    __pyx_v_i = __pyx_t_2;
+  __pyx_t_2 = __pyx_t_1;
+  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
+    __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1338
+    /* "View.MemoryView":1349
  * 
  *     for i in range(offset):
  *         mslice.shape[i] = 1             # <<<<<<<<<<<<<<
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1
  */
     (__pyx_v_mslice->shape[__pyx_v_i]) = 1;
 
-    /* "View.MemoryView":1339
+    /* "View.MemoryView":1350
  *     for i in range(offset):
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]             # <<<<<<<<<<<<<<
  *         mslice.suboffsets[i] = -1
  * 
  */
     (__pyx_v_mslice->strides[__pyx_v_i]) = (__pyx_v_mslice->strides[0]);
 
-    /* "View.MemoryView":1340
+    /* "View.MemoryView":1351
  *         mslice.shape[i] = 1
  *         mslice.strides[i] = mslice.strides[0]
  *         mslice.suboffsets[i] = -1             # <<<<<<<<<<<<<<
  * 
  * 
  */
     (__pyx_v_mslice->suboffsets[__pyx_v_i]) = -1L;
   }
 
-  /* "View.MemoryView":1326
+  /* "View.MemoryView":1337
  * 
  * @cname('__pyx_memoryview_broadcast_leading')
  * cdef void broadcast_leading(__Pyx_memviewslice *mslice,             # <<<<<<<<<<<<<<
  *                             int ndim,
  *                             int ndim_other) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1348
+/* "View.MemoryView":1359
  * 
  * @cname('__pyx_memoryview_refcount_copying')
  * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
  *                            int ndim, bint inc) nogil:
  * 
  */
 
 static void __pyx_memoryview_refcount_copying(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_dtype_is_object, int __pyx_v_ndim, int __pyx_v_inc) {
   int __pyx_t_1;
 
-  /* "View.MemoryView":1352
+  /* "View.MemoryView":1363
  * 
  * 
  *     if dtype_is_object:             # <<<<<<<<<<<<<<
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
  *                                            dst.strides, ndim, inc)
  */
   __pyx_t_1 = (__pyx_v_dtype_is_object != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1353
+    /* "View.MemoryView":1364
  * 
  *     if dtype_is_object:
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,             # <<<<<<<<<<<<<<
  *                                            dst.strides, ndim, inc)
  * 
  */
     __pyx_memoryview_refcount_objects_in_slice_with_gil(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_inc);
 
-    /* "View.MemoryView":1352
+    /* "View.MemoryView":1363
  * 
  * 
  *     if dtype_is_object:             # <<<<<<<<<<<<<<
  *         refcount_objects_in_slice_with_gil(dst.data, dst.shape,
  *                                            dst.strides, ndim, inc)
  */
   }
 
-  /* "View.MemoryView":1348
+  /* "View.MemoryView":1359
  * 
  * @cname('__pyx_memoryview_refcount_copying')
  * cdef void refcount_copying(__Pyx_memviewslice *dst, bint dtype_is_object,             # <<<<<<<<<<<<<<
  *                            int ndim, bint inc) nogil:
  * 
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1357
+/* "View.MemoryView":1368
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice_with_gil(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
   __Pyx_RefNannyDeclarations
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
   #endif
   __Pyx_RefNannySetupContext("refcount_objects_in_slice_with_gil", 0);
 
-  /* "View.MemoryView":1360
+  /* "View.MemoryView":1371
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  *     refcount_objects_in_slice(data, shape, strides, ndim, inc)             # <<<<<<<<<<<<<<
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  */
   __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, __pyx_v_shape, __pyx_v_strides, __pyx_v_ndim, __pyx_v_inc);
 
-  /* "View.MemoryView":1357
+  /* "View.MemoryView":1368
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice_with_gil')
  * cdef void refcount_objects_in_slice_with_gil(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                              Py_ssize_t *strides, int ndim,
  *                                              bint inc) with gil:
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
 }
 
-/* "View.MemoryView":1363
+/* "View.MemoryView":1374
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
 static void __pyx_memoryview_refcount_objects_in_slice(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, int __pyx_v_inc) {
   CYTHON_UNUSED Py_ssize_t __pyx_v_i;
   __Pyx_RefNannyDeclarations
   Py_ssize_t __pyx_t_1;
   Py_ssize_t __pyx_t_2;
-  int __pyx_t_3;
+  Py_ssize_t __pyx_t_3;
+  int __pyx_t_4;
   __Pyx_RefNannySetupContext("refcount_objects_in_slice", 0);
 
-  /* "View.MemoryView":1367
+  /* "View.MemoryView":1378
  *     cdef Py_ssize_t i
  * 
  *     for i in range(shape[0]):             # <<<<<<<<<<<<<<
  *         if ndim == 1:
  *             if inc:
  */
   __pyx_t_1 = (__pyx_v_shape[0]);
-  for (__pyx_t_2 = 0; __pyx_t_2 < __pyx_t_1; __pyx_t_2+=1) {
-    __pyx_v_i = __pyx_t_2;
+  __pyx_t_2 = __pyx_t_1;
+  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
+    __pyx_v_i = __pyx_t_3;
 
-    /* "View.MemoryView":1368
+    /* "View.MemoryView":1379
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
-    __pyx_t_3 = ((__pyx_v_ndim == 1) != 0);
-    if (__pyx_t_3) {
+    __pyx_t_4 = ((__pyx_v_ndim == 1) != 0);
+    if (__pyx_t_4) {
 
-      /* "View.MemoryView":1369
+      /* "View.MemoryView":1380
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
-      __pyx_t_3 = (__pyx_v_inc != 0);
-      if (__pyx_t_3) {
+      __pyx_t_4 = (__pyx_v_inc != 0);
+      if (__pyx_t_4) {
 
-        /* "View.MemoryView":1370
+        /* "View.MemoryView":1381
  *         if ndim == 1:
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])
  */
         Py_INCREF((((PyObject **)__pyx_v_data)[0]));
 
-        /* "View.MemoryView":1369
+        /* "View.MemoryView":1380
  *     for i in range(shape[0]):
  *         if ndim == 1:
  *             if inc:             # <<<<<<<<<<<<<<
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  */
         goto __pyx_L6;
       }
 
-      /* "View.MemoryView":1372
+      /* "View.MemoryView":1383
  *                 Py_INCREF((<PyObject **> data)[0])
  *             else:
  *                 Py_DECREF((<PyObject **> data)[0])             # <<<<<<<<<<<<<<
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  */
       /*else*/ {
         Py_DECREF((((PyObject **)__pyx_v_data)[0]));
       }
       __pyx_L6:;
 
-      /* "View.MemoryView":1368
+      /* "View.MemoryView":1379
  * 
  *     for i in range(shape[0]):
  *         if ndim == 1:             # <<<<<<<<<<<<<<
  *             if inc:
  *                 Py_INCREF((<PyObject **> data)[0])
  */
       goto __pyx_L5;
     }
 
-    /* "View.MemoryView":1374
+    /* "View.MemoryView":1385
  *                 Py_DECREF((<PyObject **> data)[0])
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
  *                                       ndim - 1, inc)
  * 
  */
     /*else*/ {
 
-      /* "View.MemoryView":1375
+      /* "View.MemoryView":1386
  *         else:
  *             refcount_objects_in_slice(data, shape + 1, strides + 1,
  *                                       ndim - 1, inc)             # <<<<<<<<<<<<<<
  * 
  *         data += strides[0]
  */
       __pyx_memoryview_refcount_objects_in_slice(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_inc);
     }
     __pyx_L5:;
 
-    /* "View.MemoryView":1377
+    /* "View.MemoryView":1388
  *                                       ndim - 1, inc)
  * 
  *         data += strides[0]             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __pyx_v_data = (__pyx_v_data + (__pyx_v_strides[0]));
   }
 
-  /* "View.MemoryView":1363
+  /* "View.MemoryView":1374
  * 
  * @cname('__pyx_memoryview_refcount_objects_in_slice')
  * cdef void refcount_objects_in_slice(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                                     Py_ssize_t *strides, int ndim, bint inc):
  *     cdef Py_ssize_t i
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "View.MemoryView":1383
+/* "View.MemoryView":1394
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  */
 
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *__pyx_v_dst, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item, int __pyx_v_dtype_is_object) {
 
-  /* "View.MemoryView":1386
+  /* "View.MemoryView":1397
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  *     refcount_copying(dst, dtype_is_object, ndim, False)             # <<<<<<<<<<<<<<
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
  *                          itemsize, item)
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 0);
 
-  /* "View.MemoryView":1387
+  /* "View.MemoryView":1398
  *                               bint dtype_is_object) nogil:
  *     refcount_copying(dst, dtype_is_object, ndim, False)
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,             # <<<<<<<<<<<<<<
  *                          itemsize, item)
  *     refcount_copying(dst, dtype_is_object, ndim, True)
  */
   __pyx_memoryview__slice_assign_scalar(__pyx_v_dst->data, __pyx_v_dst->shape, __pyx_v_dst->strides, __pyx_v_ndim, __pyx_v_itemsize, __pyx_v_item);
 
-  /* "View.MemoryView":1389
+  /* "View.MemoryView":1400
  *     _slice_assign_scalar(dst.data, dst.shape, dst.strides, ndim,
  *                          itemsize, item)
  *     refcount_copying(dst, dtype_is_object, ndim, True)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_memoryview_refcount_copying(__pyx_v_dst, __pyx_v_dtype_is_object, __pyx_v_ndim, 1);
 
-  /* "View.MemoryView":1383
+  /* "View.MemoryView":1394
  * 
  * @cname('__pyx_memoryview_slice_assign_scalar')
  * cdef void slice_assign_scalar(__Pyx_memviewslice *dst, int ndim,             # <<<<<<<<<<<<<<
  *                               size_t itemsize, void *item,
  *                               bint dtype_is_object) nogil:
  */
 
   /* function exit code */
 }
 
-/* "View.MemoryView":1393
+/* "View.MemoryView":1404
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
  *                               size_t itemsize, void *item) nogil:
  */
 
 static void __pyx_memoryview__slice_assign_scalar(char *__pyx_v_data, Py_ssize_t *__pyx_v_shape, Py_ssize_t *__pyx_v_strides, int __pyx_v_ndim, size_t __pyx_v_itemsize, void *__pyx_v_item) {
   CYTHON_UNUSED Py_ssize_t __pyx_v_i;
   Py_ssize_t __pyx_v_stride;
   Py_ssize_t __pyx_v_extent;
   int __pyx_t_1;
   Py_ssize_t __pyx_t_2;
   Py_ssize_t __pyx_t_3;
+  Py_ssize_t __pyx_t_4;
 
-  /* "View.MemoryView":1397
+  /* "View.MemoryView":1408
  *                               size_t itemsize, void *item) nogil:
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]             # <<<<<<<<<<<<<<
  *     cdef Py_ssize_t extent = shape[0]
  * 
  */
   __pyx_v_stride = (__pyx_v_strides[0]);
 
-  /* "View.MemoryView":1398
+  /* "View.MemoryView":1409
  *     cdef Py_ssize_t i
  *     cdef Py_ssize_t stride = strides[0]
  *     cdef Py_ssize_t extent = shape[0]             # <<<<<<<<<<<<<<
  * 
  *     if ndim == 1:
  */
   __pyx_v_extent = (__pyx_v_shape[0]);
 
-  /* "View.MemoryView":1400
+  /* "View.MemoryView":1411
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
   __pyx_t_1 = ((__pyx_v_ndim == 1) != 0);
   if (__pyx_t_1) {
 
-    /* "View.MemoryView":1401
+    /* "View.MemoryView":1412
  * 
  *     if ndim == 1:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             memcpy(data, item, itemsize)
  *             data += stride
  */
     __pyx_t_2 = __pyx_v_extent;
-    for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-      __pyx_v_i = __pyx_t_3;
+    __pyx_t_3 = __pyx_t_2;
+    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+      __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1402
+      /* "View.MemoryView":1413
  *     if ndim == 1:
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)             # <<<<<<<<<<<<<<
  *             data += stride
  *     else:
  */
-      memcpy(__pyx_v_data, __pyx_v_item, __pyx_v_itemsize);
+      (void)(memcpy(__pyx_v_data, __pyx_v_item, __pyx_v_itemsize));
 
-      /* "View.MemoryView":1403
+      /* "View.MemoryView":1414
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  *             data += stride             # <<<<<<<<<<<<<<
  *     else:
  *         for i in range(extent):
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
 
-    /* "View.MemoryView":1400
+    /* "View.MemoryView":1411
  *     cdef Py_ssize_t extent = shape[0]
  * 
  *     if ndim == 1:             # <<<<<<<<<<<<<<
  *         for i in range(extent):
  *             memcpy(data, item, itemsize)
  */
     goto __pyx_L3;
   }
 
-  /* "View.MemoryView":1405
+  /* "View.MemoryView":1416
  *             data += stride
  *     else:
  *         for i in range(extent):             # <<<<<<<<<<<<<<
  *             _slice_assign_scalar(data, shape + 1, strides + 1,
  *                                 ndim - 1, itemsize, item)
  */
   /*else*/ {
     __pyx_t_2 = __pyx_v_extent;
-    for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-      __pyx_v_i = __pyx_t_3;
+    __pyx_t_3 = __pyx_t_2;
+    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+      __pyx_v_i = __pyx_t_4;
 
-      /* "View.MemoryView":1406
+      /* "View.MemoryView":1417
  *     else:
  *         for i in range(extent):
  *             _slice_assign_scalar(data, shape + 1, strides + 1,             # <<<<<<<<<<<<<<
  *                                 ndim - 1, itemsize, item)
  *             data += stride
  */
       __pyx_memoryview__slice_assign_scalar(__pyx_v_data, (__pyx_v_shape + 1), (__pyx_v_strides + 1), (__pyx_v_ndim - 1), __pyx_v_itemsize, __pyx_v_item);
 
-      /* "View.MemoryView":1408
+      /* "View.MemoryView":1419
  *             _slice_assign_scalar(data, shape + 1, strides + 1,
  *                                 ndim - 1, itemsize, item)
  *             data += stride             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_v_data = (__pyx_v_data + __pyx_v_stride);
     }
   }
   __pyx_L3:;
 
-  /* "View.MemoryView":1393
+  /* "View.MemoryView":1404
  * 
  * @cname('__pyx_memoryview__slice_assign_scalar')
  * cdef void _slice_assign_scalar(char *data, Py_ssize_t *shape,             # <<<<<<<<<<<<<<
  *                               Py_ssize_t *strides, int ndim,
  *                               size_t itemsize, void *item) nogil:
  */
 
   /* function exit code */
 }
 
 /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
- *     if __pyx_checksum != 0xb068931:
- *         from pickle import PickleError as __pyx_PickleError
+ *     cdef object __pyx_PickleError
+ *     cdef object __pyx_result
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyMethodDef __pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum = {"__pyx_unpickle_Enum", (PyCFunction)__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum, METH_VARARGS|METH_KEYWORDS, 0};
+static PyMethodDef __pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum = {"__pyx_unpickle_Enum", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum, METH_VARARGS|METH_KEYWORDS, 0};
 static PyObject *__pyx_pw_15View_dot_MemoryView_1__pyx_unpickle_Enum(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v___pyx_type = 0;
   long __pyx_v___pyx_checksum;
   PyObject *__pyx_v___pyx_state = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum (wrapper)", 0);
@@ -18053,25 +18077,25 @@
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
-        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;
+        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;
+        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 1); __PYX_ERR(2, 1, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;
+        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;
         else {
           __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_Enum", 1, 3, 3, 2); __PYX_ERR(2, 1, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__pyx_unpickle_Enum") < 0)) __PYX_ERR(2, 1, __pyx_L3_error)
       }
@@ -18098,252 +18122,194 @@
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
-  PyObject *__pyx_v___pyx_PickleError = NULL;
-  PyObject *__pyx_v___pyx_result = NULL;
+  PyObject *__pyx_v___pyx_PickleError = 0;
+  PyObject *__pyx_v___pyx_result = 0;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
+  int __pyx_t_6;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum", 0);
 
-  /* "(tree fragment)":2
- * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):
+  /* "(tree fragment)":4
+ *     cdef object __pyx_PickleError
+ *     cdef object __pyx_result
  *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
   __pyx_t_1 = ((__pyx_v___pyx_checksum != 0xb068931) != 0);
   if (__pyx_t_1) {
 
-    /* "(tree fragment)":3
- * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):
+    /* "(tree fragment)":5
+ *     cdef object __pyx_result
  *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
  *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  */
-    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 3, __pyx_L1_error)
+    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_n_s_PickleError);
     __Pyx_GIVEREF(__pyx_n_s_PickleError);
     PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);
-    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 3, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 3, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 5, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __Pyx_INCREF(__pyx_t_2);
     __pyx_v___pyx_PickleError = __pyx_t_2;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "(tree fragment)":4
+    /* "(tree fragment)":6
  *     if __pyx_checksum != 0xb068931:
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)             # <<<<<<<<<<<<<<
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  */
-    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 4, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 4, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 6, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_INCREF(__pyx_v___pyx_PickleError);
     __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_2, function);
       }
     }
-    if (!__pyx_t_5) {
-      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 4, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __Pyx_GOTREF(__pyx_t_3);
-    } else {
-      #if CYTHON_FAST_PYCALL
-      if (PyFunction_Check(__pyx_t_2)) {
-        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_4};
-        __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 4, __pyx_L1_error)
-        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __Pyx_GOTREF(__pyx_t_3);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      } else
-      #endif
-      #if CYTHON_FAST_PYCCALL
-      if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
-        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_4};
-        __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 4, __pyx_L1_error)
-        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-        __Pyx_GOTREF(__pyx_t_3);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      } else
-      #endif
-      {
-        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 4, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_6);
-        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
-        __Pyx_GIVEREF(__pyx_t_4);
-        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_4);
-        __pyx_t_4 = 0;
-        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 4, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_3);
-        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      }
-    }
+    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 6, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_Raise(__pyx_t_3, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __PYX_ERR(2, 4, __pyx_L1_error)
+    __PYX_ERR(2, 6, __pyx_L1_error)
 
-    /* "(tree fragment)":2
- * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):
+    /* "(tree fragment)":4
+ *     cdef object __pyx_PickleError
+ *     cdef object __pyx_result
  *     if __pyx_checksum != 0xb068931:             # <<<<<<<<<<<<<<
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  */
   }
 
-  /* "(tree fragment)":5
+  /* "(tree fragment)":7
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)             # <<<<<<<<<<<<<<
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 5, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_MemviewEnum_type), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(2, 7, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_6 = NULL;
+  __pyx_t_4 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_6)) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_6);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
-  if (!__pyx_t_6) {
-    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 5, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-  } else {
-    #if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(__pyx_t_2)) {
-      PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_v___pyx_type};
-      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 5, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __Pyx_GOTREF(__pyx_t_3);
-    } else
-    #endif
-    #if CYTHON_FAST_PYCCALL
-    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
-      PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_v___pyx_type};
-      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 5, __pyx_L1_error)
-      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __Pyx_GOTREF(__pyx_t_3);
-    } else
-    #endif
-    {
-      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 5, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_6); __pyx_t_6 = NULL;
-      __Pyx_INCREF(__pyx_v___pyx_type);
-      __Pyx_GIVEREF(__pyx_v___pyx_type);
-      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v___pyx_type);
-      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 5, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    }
-  }
+  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);
+  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 7, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v___pyx_result = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "(tree fragment)":6
+  /* "(tree fragment)":8
  *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   __pyx_t_1 = (__pyx_v___pyx_state != Py_None);
-  __pyx_t_7 = (__pyx_t_1 != 0);
-  if (__pyx_t_7) {
+  __pyx_t_6 = (__pyx_t_1 != 0);
+  if (__pyx_t_6) {
 
-    /* "(tree fragment)":7
+    /* "(tree fragment)":9
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  */
-    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(2, 7, __pyx_L1_error)
-    __pyx_t_3 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 7, __pyx_L1_error)
+    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(2, 9, __pyx_L1_error)
+    __pyx_t_3 = __pyx_unpickle_Enum__set_state(((struct __pyx_MemviewEnum_obj *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(2, 9, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "(tree fragment)":6
+    /* "(tree fragment)":8
  *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xb068931 = (name))" % __pyx_checksum)
  *     __pyx_result = Enum.__new__(__pyx_type)
  *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  */
   }
 
-  /* "(tree fragment)":8
+  /* "(tree fragment)":10
  *     if __pyx_state is not None:
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result             # <<<<<<<<<<<<<<
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v___pyx_result);
   __pyx_r = __pyx_v___pyx_result;
   goto __pyx_L0;
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
- *     if __pyx_checksum != 0xb068931:
- *         from pickle import PickleError as __pyx_PickleError
+ *     cdef object __pyx_PickleError
+ *     cdef object __pyx_result
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v___pyx_PickleError);
   __Pyx_XDECREF(__pyx_v___pyx_result);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "(tree fragment)":9
+/* "(tree fragment)":11
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  */
 
@@ -18354,132 +18320,101 @@
   int __pyx_t_2;
   Py_ssize_t __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
-  PyObject *__pyx_t_9 = NULL;
   __Pyx_RefNannySetupContext("__pyx_unpickle_Enum__set_state", 0);
 
-  /* "(tree fragment)":10
+  /* "(tree fragment)":12
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]             # <<<<<<<<<<<<<<
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  *         __pyx_result.__dict__.update(__pyx_state[1])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-    __PYX_ERR(2, 10, __pyx_L1_error)
+    __PYX_ERR(2, 12, __pyx_L1_error)
   }
-  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 10, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 12, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v___pyx_result->name);
   __Pyx_DECREF(__pyx_v___pyx_result->name);
   __pyx_v___pyx_result->name = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "(tree fragment)":11
+  /* "(tree fragment)":13
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
  *         __pyx_result.__dict__.update(__pyx_state[1])
  */
   if (unlikely(__pyx_v___pyx_state == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
-    __PYX_ERR(2, 11, __pyx_L1_error)
+    __PYX_ERR(2, 13, __pyx_L1_error)
   }
-  __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(2, 11, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(2, 13, __pyx_L1_error)
   __pyx_t_4 = ((__pyx_t_3 > 1) != 0);
   if (__pyx_t_4) {
   } else {
     __pyx_t_2 = __pyx_t_4;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 11, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 13, __pyx_L1_error)
   __pyx_t_5 = (__pyx_t_4 != 0);
   __pyx_t_2 = __pyx_t_5;
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_2) {
 
-    /* "(tree fragment)":12
+    /* "(tree fragment)":14
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  *         __pyx_result.__dict__.update(__pyx_state[1])             # <<<<<<<<<<<<<<
  */
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 12, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
-    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 12, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(2, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
     if (unlikely(__pyx_v___pyx_state == Py_None)) {
       PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
-      __PYX_ERR(2, 12, __pyx_L1_error)
+      __PYX_ERR(2, 14, __pyx_L1_error)
     }
-    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 12, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(2, 14, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_8 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
       __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
       if (likely(__pyx_t_8)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
         __Pyx_INCREF(__pyx_t_8);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_7, function);
       }
     }
-    if (!__pyx_t_8) {
-      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 12, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __Pyx_GOTREF(__pyx_t_1);
-    } else {
-      #if CYTHON_FAST_PYCALL
-      if (PyFunction_Check(__pyx_t_7)) {
-        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_t_6};
-        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 12, __pyx_L1_error)
-        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      } else
-      #endif
-      #if CYTHON_FAST_PYCCALL
-      if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
-        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_t_6};
-        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 12, __pyx_L1_error)
-        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      } else
-      #endif
-      {
-        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(2, 12, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_9);
-        __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8); __pyx_t_8 = NULL;
-        __Pyx_GIVEREF(__pyx_t_6);
-        PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_t_6);
-        __pyx_t_6 = 0;
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 12, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-      }
-    }
+    __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 14, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-    /* "(tree fragment)":11
+    /* "(tree fragment)":13
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
  *         __pyx_result.__dict__.update(__pyx_state[1])
  */
   }
 
-  /* "(tree fragment)":9
+  /* "(tree fragment)":11
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  */
 
@@ -18487,15 +18422,14 @@
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
   __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_XDECREF(__pyx_t_9);
   __Pyx_AddTraceback("View.MemoryView.__pyx_unpickle_Enum__set_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
@@ -18556,15 +18490,15 @@
     PyErr_Format(PyExc_NotImplementedError,
       "Subscript deletion not supported by %.200s", Py_TYPE(o)->tp_name);
     return -1;
   }
 }
 
 static PyObject *__pyx_tp_getattro_array(PyObject *o, PyObject *n) {
-  PyObject *v = PyObject_GenericGetAttr(o, n);
+  PyObject *v = __Pyx_PyObject_GenericGetAttr(o, n);
   if (!v && PyErr_ExceptionMatches(PyExc_AttributeError)) {
     PyErr_Clear();
     v = __pyx_array___getattr__(o, n);
   }
   return v;
 }
 
@@ -19168,15 +19102,15 @@
   0, /*tp_version_tag*/
   #if PY_VERSION_HEX >= 0x030400a1
   0, /*tp_finalize*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
-  {"lomb_scargle", (PyCFunction)__pyx_pw_6cesium_8features_13_lomb_scargle_1lomb_scargle, METH_VARARGS|METH_KEYWORDS, 0},
+  {"lomb_scargle", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_6cesium_8features_13_lomb_scargle_1lomb_scargle, METH_VARARGS|METH_KEYWORDS, 0},
   {0, 0, 0, 0}
 };
 
 #if PY_MAJOR_VERSION >= 3
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
 static int __pyx_pymod_exec__lomb_scargle(PyObject* module); /*proto*/
@@ -19203,19 +19137,30 @@
     NULL, /* m_reload */
   #endif
     NULL, /* m_traverse */
     NULL, /* m_clear */
     NULL /* m_free */
 };
 #endif
+#ifndef CYTHON_SMALL_CODE
+#if defined(__clang__)
+    #define CYTHON_SMALL_CODE
+#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
+    #define CYTHON_SMALL_CODE __attribute__((cold))
+#else
+    #define CYTHON_SMALL_CODE
+#endif
+#endif
 
 static __Pyx_StringTabEntry __pyx_string_tab[] = {
   {&__pyx_n_s_ASCII, __pyx_k_ASCII, sizeof(__pyx_k_ASCII), 0, 0, 1, 1},
   {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
   {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
+  {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
+  {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_index_with_type_s, __pyx_k_Cannot_index_with_type_s, sizeof(__pyx_k_Cannot_index_with_type_s), 0, 0, 1, 0},
   {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
   {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
   {&__pyx_kp_u_Format_string_allocated_too_shor, __pyx_k_Format_string_allocated_too_shor, sizeof(__pyx_k_Format_string_allocated_too_shor), 0, 1, 0, 0},
   {&__pyx_kp_u_Format_string_allocated_too_shor_2, __pyx_k_Format_string_allocated_too_shor_2, sizeof(__pyx_k_Format_string_allocated_too_shor_2), 0, 1, 0, 0},
   {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
   {&__pyx_kp_s_Incompatible_checksums_s_vs_0xb0, __pyx_k_Incompatible_checksums_s_vs_0xb0, sizeof(__pyx_k_Incompatible_checksums_s_vs_0xb0), 0, 0, 1, 0},
@@ -19332,482 +19277,689 @@
   {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
   {&__pyx_kp_u_unknown_dtype_code_in_numpy_pxd, __pyx_k_unknown_dtype_code_in_numpy_pxd, sizeof(__pyx_k_unknown_dtype_code_in_numpy_pxd), 0, 1, 0, 0},
   {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
   {&__pyx_n_s_wth, __pyx_k_wth, sizeof(__pyx_k_wth), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
-static int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 235, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(1, 248, __pyx_L1_error)
-  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) __PYX_ERR(1, 823, __pyx_L1_error)
-  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(1, 1013, __pyx_L1_error)
-  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(2, 146, __pyx_L1_error)
-  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(2, 149, __pyx_L1_error)
+static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 272, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(1, 285, __pyx_L1_error)
+  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) __PYX_ERR(1, 856, __pyx_L1_error)
+  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(1, 1038, __pyx_L1_error)
+  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(2, 148, __pyx_L1_error)
+  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(2, 151, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(2, 2, __pyx_L1_error)
-  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(2, 398, __pyx_L1_error)
-  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(2, 601, __pyx_L1_error)
-  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(2, 820, __pyx_L1_error)
+  __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(2, 400, __pyx_L1_error)
+  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(2, 609, __pyx_L1_error)
+  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(2, 828, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
-static int __Pyx_InitCachedConstants(void) {
+static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":235
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":272
  *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
- *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_C_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not C contiguous")             # <<<<<<<<<<<<<<
  * 
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
  */
-  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_C_contiguous); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 235, __pyx_L1_error)
+  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_C_contiguous); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 272, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple_);
   __Pyx_GIVEREF(__pyx_tuple_);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":239
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":276
  *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
- *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
+ *                 and not PyArray_CHKFLAGS(self, NPY_ARRAY_F_CONTIGUOUS)):
  *                 raise ValueError(u"ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
  * 
  *             info.buf = PyArray_DATA(self)
  */
-  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_Fortran_contiguou); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 239, __pyx_L1_error)
+  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_ndarray_is_not_Fortran_contiguou); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 276, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__2);
   __Pyx_GIVEREF(__pyx_tuple__2);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":276
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":306
  *                 if ((descr.byteorder == c'>' and little_endian) or
  *                     (descr.byteorder == c'<' and not little_endian)):
  *                     raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *                 if   t == NPY_BYTE:        f = "b"
  *                 elif t == NPY_UBYTE:       f = "B"
  */
-  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 276, __pyx_L1_error)
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 306, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__3);
   __Pyx_GIVEREF(__pyx_tuple__3);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":823
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":856
  * 
  *         if (end - f) - <int>(new_offset - offset[0]) < 15:
  *             raise RuntimeError(u"Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
  * 
  *         if ((child.byteorder == c'>' and little_endian) or
  */
-  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 823, __pyx_L1_error)
+  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 856, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__4);
   __Pyx_GIVEREF(__pyx_tuple__4);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":827
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":860
  *         if ((child.byteorder == c'>' and little_endian) or
  *             (child.byteorder == c'<' and not little_endian)):
  *             raise ValueError(u"Non-native byte order not supported")             # <<<<<<<<<<<<<<
  *             # One could encode it in the format string and have Cython
  *             # complain instead, BUT: < and > in format strings also imply
  */
-  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 827, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
+  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_Non_native_byte_order_not_suppor); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 860, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__3);
+  __Pyx_GIVEREF(__pyx_tuple__3);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":847
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":880
  *             t = child.type_num
  *             if end - f < 5:
  *                 raise RuntimeError(u"Format string allocated too short.")             # <<<<<<<<<<<<<<
  * 
  *             # Until ticket #99 is fixed, use integers to avoid warnings
  */
-  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor_2); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 847, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__6);
-  __Pyx_GIVEREF(__pyx_tuple__6);
+  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_u_Format_string_allocated_too_shor_2); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(1, 880, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__5);
+  __Pyx_GIVEREF(__pyx_tuple__5);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1013
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1038
  *         _import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
-  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 1013, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__7);
-  __Pyx_GIVEREF(__pyx_tuple__7);
+  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 1038, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1019
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1044
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
-  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 1019, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
+  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 1044, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
 
-  /* ".eggs/Cython-0.27.3-py3.6-linux-x86_64.egg/Cython/Includes/numpy/__init__.pxd":1025
+  /* "../../AppData/Local/conda/conda/envs/py27/lib/site-packages/Cython/Includes/numpy/__init__.pxd":1050
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 1025, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__9);
-  __Pyx_GIVEREF(__pyx_tuple__9);
+  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 1050, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__7);
+  __Pyx_GIVEREF(__pyx_tuple__7);
 
-  /* "View.MemoryView":131
+  /* "View.MemoryView":133
  * 
  *         if not self.ndim:
  *             raise ValueError("Empty shape tuple for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if itemsize <= 0:
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(2, 131, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__10);
-  __Pyx_GIVEREF(__pyx_tuple__10);
+  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_Empty_shape_tuple_for_cython_arr); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(2, 133, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__8);
+  __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "View.MemoryView":134
+  /* "View.MemoryView":136
  * 
  *         if itemsize <= 0:
  *             raise ValueError("itemsize <= 0 for cython.array")             # <<<<<<<<<<<<<<
  * 
  *         if not isinstance(format, bytes):
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(2, 134, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__11);
-  __Pyx_GIVEREF(__pyx_tuple__11);
-
-  /* "View.MemoryView":137
- * 
- *         if not isinstance(format, bytes):
- *             format = format.encode('ASCII')             # <<<<<<<<<<<<<<
- *         self._format = format  # keep a reference to the byte string
- *         self.format = self._format
- */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_n_s_ASCII); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(2, 137, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__12);
-  __Pyx_GIVEREF(__pyx_tuple__12);
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_itemsize_0_for_cython_array); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(2, 136, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__9);
+  __Pyx_GIVEREF(__pyx_tuple__9);
 
-  /* "View.MemoryView":146
+  /* "View.MemoryView":148
  * 
  *         if not self._shape:
  *             raise MemoryError("unable to allocate shape and strides.")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(2, 146, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__13);
-  __Pyx_GIVEREF(__pyx_tuple__13);
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_shape_and_str); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(2, 148, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__10);
+  __Pyx_GIVEREF(__pyx_tuple__10);
 
-  /* "View.MemoryView":174
+  /* "View.MemoryView":176
  *             self.data = <char *>malloc(self.len)
  *             if not self.data:
  *                 raise MemoryError("unable to allocate array data.")             # <<<<<<<<<<<<<<
  * 
  *             if self.dtype_is_object:
  */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(2, 174, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_unable_to_allocate_array_data); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(2, 176, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__11);
+  __Pyx_GIVEREF(__pyx_tuple__11);
 
-  /* "View.MemoryView":190
+  /* "View.MemoryView":192
  *             bufmode = PyBUF_F_CONTIGUOUS | PyBUF_ANY_CONTIGUOUS
  *         if not (flags & bufmode):
  *             raise ValueError("Can only create a buffer that is contiguous in memory.")             # <<<<<<<<<<<<<<
  *         info.buf = self.data
  *         info.len = self.len
  */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(2, 190, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
+  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_Can_only_create_a_buffer_that_is); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(2, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__12);
+  __Pyx_GIVEREF(__pyx_tuple__12);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(2, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(2, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__13);
+  __Pyx_GIVEREF(__pyx_tuple__13);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(2, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
+  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
 
-  /* "View.MemoryView":486
+  /* "View.MemoryView":414
+ *     def __setitem__(memoryview self, object index, object value):
+ *         if self.view.readonly:
+ *             raise TypeError("Cannot assign to read-only memoryview")             # <<<<<<<<<<<<<<
+ * 
+ *         have_slices, index = _unellipsify(index, self.view.ndim)
+ */
+  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_Cannot_assign_to_read_only_memor); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(2, 414, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__15);
+  __Pyx_GIVEREF(__pyx_tuple__15);
+
+  /* "View.MemoryView":491
  *             result = struct.unpack(self.view.format, bytesitem)
  *         except struct.error:
  *             raise ValueError("Unable to convert item to object")             # <<<<<<<<<<<<<<
  *         else:
  *             if len(self.view.format) == 1:
  */
-  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(2, 486, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_Unable_to_convert_item_to_object); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(2, 491, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
 
-  /* "View.MemoryView":558
+  /* "View.MemoryView":516
+ *     def __getbuffer__(self, Py_buffer *info, int flags):
+ *         if flags & PyBUF_WRITABLE and self.view.readonly:
+ *             raise ValueError("Cannot create writable memory view from read-only memoryview")             # <<<<<<<<<<<<<<
+ * 
+ *         if flags & PyBUF_ND:
+ */
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_Cannot_create_writable_memory_vi); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(2, 516, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__17);
+  __Pyx_GIVEREF(__pyx_tuple__17);
+
+  /* "View.MemoryView":566
  *         if self.view.strides == NULL:
  * 
  *             raise ValueError("Buffer view does not expose strides")             # <<<<<<<<<<<<<<
  * 
  *         return tuple([stride for stride in self.view.strides[:self.view.ndim]])
  */
-  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(2, 558, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_Buffer_view_does_not_expose_stri); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(2, 566, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
 
-  /* "View.MemoryView":565
+  /* "View.MemoryView":573
  *     def suboffsets(self):
  *         if self.view.suboffsets == NULL:
  *             return (-1,) * self.view.ndim             # <<<<<<<<<<<<<<
  * 
  *         return tuple([suboffset for suboffset in self.view.suboffsets[:self.view.ndim]])
  */
-  __pyx_tuple__20 = PyTuple_New(1); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(2, 565, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__20);
+  __pyx_tuple__19 = PyTuple_New(1); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(2, 573, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__19);
   __Pyx_INCREF(__pyx_int_neg_1);
   __Pyx_GIVEREF(__pyx_int_neg_1);
-  PyTuple_SET_ITEM(__pyx_tuple__20, 0, __pyx_int_neg_1);
-  __Pyx_GIVEREF(__pyx_tuple__20);
+  PyTuple_SET_ITEM(__pyx_tuple__19, 0, __pyx_int_neg_1);
+  __Pyx_GIVEREF(__pyx_tuple__19);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(2, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
+  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(2, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(2, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__22);
-  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
 
-  /* "View.MemoryView":670
+  /* "View.MemoryView":678
  *         if item is Ellipsis:
  *             if not seen_ellipsis:
  *                 result.extend([slice(None)] * (ndim - len(tup) + 1))             # <<<<<<<<<<<<<<
  *                 seen_ellipsis = True
  *             else:
  */
-  __pyx_slice__23 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__23)) __PYX_ERR(2, 670, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__23);
-  __Pyx_GIVEREF(__pyx_slice__23);
+  __pyx_slice__22 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__22)) __PYX_ERR(2, 678, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__22);
+  __Pyx_GIVEREF(__pyx_slice__22);
 
-  /* "View.MemoryView":673
+  /* "View.MemoryView":681
  *                 seen_ellipsis = True
  *             else:
  *                 result.append(slice(None))             # <<<<<<<<<<<<<<
  *             have_slices = True
  *         else:
  */
-  __pyx_slice__24 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__24)) __PYX_ERR(2, 673, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__24);
-  __Pyx_GIVEREF(__pyx_slice__24);
+  __pyx_slice__22 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__22)) __PYX_ERR(2, 681, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__22);
+  __Pyx_GIVEREF(__pyx_slice__22);
 
-  /* "View.MemoryView":684
+  /* "View.MemoryView":692
  *     nslices = ndim - len(result)
  *     if nslices:
  *         result.extend([slice(None)] * nslices)             # <<<<<<<<<<<<<<
  * 
  *     return have_slices or nslices, tuple(result)
  */
-  __pyx_slice__25 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__25)) __PYX_ERR(2, 684, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_slice__25);
-  __Pyx_GIVEREF(__pyx_slice__25);
+  __pyx_slice__22 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__22)) __PYX_ERR(2, 692, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_slice__22);
+  __Pyx_GIVEREF(__pyx_slice__22);
 
-  /* "View.MemoryView":691
+  /* "View.MemoryView":699
  *     for suboffset in suboffsets[:ndim]:
  *         if suboffset >= 0:
  *             raise ValueError("Indirect dimensions not supported")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(2, 691, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__26);
-  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_Indirect_dimensions_not_supporte); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(2, 699, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
-  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(2, 2, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__27);
-  __Pyx_GIVEREF(__pyx_tuple__27);
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(2, 2, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
 
   /* "(tree fragment)":4
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
  */
-  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(2, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__28);
-  __Pyx_GIVEREF(__pyx_tuple__28);
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(2, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
 
-  /* "View.MemoryView":284
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(2, 284, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__29);
-  __Pyx_GIVEREF(__pyx_tuple__29);
+  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(2, 286, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
 
-  /* "View.MemoryView":285
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(2, 285, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__30);
-  __Pyx_GIVEREF(__pyx_tuple__30);
+  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(2, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__27);
+  __Pyx_GIVEREF(__pyx_tuple__27);
 
-  /* "View.MemoryView":286
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(2, 286, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__31);
-  __Pyx_GIVEREF(__pyx_tuple__31);
+  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(2, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__28);
+  __Pyx_GIVEREF(__pyx_tuple__28);
 
-  /* "View.MemoryView":289
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(2, 289, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__32);
-  __Pyx_GIVEREF(__pyx_tuple__32);
+  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(2, 291, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__29);
+  __Pyx_GIVEREF(__pyx_tuple__29);
 
-  /* "View.MemoryView":290
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(2, 290, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__33);
-  __Pyx_GIVEREF(__pyx_tuple__33);
+  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(2, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__30);
+  __Pyx_GIVEREF(__pyx_tuple__30);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
- *     if __pyx_checksum != 0xb068931:
- *         from pickle import PickleError as __pyx_PickleError
+ *     cdef object __pyx_PickleError
+ *     cdef object __pyx_result
  */
-  __pyx_tuple__34 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(2, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__34);
-  __Pyx_GIVEREF(__pyx_tuple__34);
-  __pyx_codeobj__35 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__34, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__35)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __pyx_tuple__31 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__31);
+  __Pyx_GIVEREF(__pyx_tuple__31);
+  __pyx_codeobj__32 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__31, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__32)) __PYX_ERR(2, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
-static int __Pyx_InitGlobals(void) {
+static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 
+static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
+static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/
+
+static int __Pyx_modinit_global_init_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
+  /*--- Global init code ---*/
+  generic = Py_None; Py_INCREF(Py_None);
+  strided = Py_None; Py_INCREF(Py_None);
+  indirect = Py_None; Py_INCREF(Py_None);
+  contiguous = Py_None; Py_INCREF(Py_None);
+  indirect_contiguous = Py_None; Py_INCREF(Py_None);
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_variable_export_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
+  /*--- Variable export code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_function_export_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
+  /*--- Function export code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_type_init_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
+  /*--- Type init code ---*/
+  __pyx_vtabptr_array = &__pyx_vtable_array;
+  __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
+  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(2, 105, __pyx_L1_error)
+  __pyx_type___pyx_array.tp_print = 0;
+  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(2, 105, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(2, 105, __pyx_L1_error)
+  __pyx_array_type = &__pyx_type___pyx_array;
+  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(2, 279, __pyx_L1_error)
+  __pyx_type___pyx_MemviewEnum.tp_print = 0;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_MemviewEnum.tp_dictoffset && __pyx_type___pyx_MemviewEnum.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_MemviewEnum.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(2, 279, __pyx_L1_error)
+  __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
+  __pyx_vtabptr_memoryview = &__pyx_vtable_memoryview;
+  __pyx_vtable_memoryview.get_item_pointer = (char *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_get_item_pointer;
+  __pyx_vtable_memoryview.is_slice = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_is_slice;
+  __pyx_vtable_memoryview.setitem_slice_assignment = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_slice_assignment;
+  __pyx_vtable_memoryview.setitem_slice_assign_scalar = (PyObject *(*)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_setitem_slice_assign_scalar;
+  __pyx_vtable_memoryview.setitem_indexed = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_indexed;
+  __pyx_vtable_memoryview.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryview_convert_item_to_object;
+  __pyx_vtable_memoryview.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryview_assign_item_from_object;
+  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(2, 330, __pyx_L1_error)
+  __pyx_type___pyx_memoryview.tp_print = 0;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryview.tp_dictoffset && __pyx_type___pyx_memoryview.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_memoryview.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(2, 330, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(2, 330, __pyx_L1_error)
+  __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
+  __pyx_vtabptr__memoryviewslice = &__pyx_vtable__memoryviewslice;
+  __pyx_vtable__memoryviewslice.__pyx_base = *__pyx_vtabptr_memoryview;
+  __pyx_vtable__memoryviewslice.__pyx_base.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryviewslice_convert_item_to_object;
+  __pyx_vtable__memoryviewslice.__pyx_base.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryviewslice_assign_item_from_object;
+  __pyx_type___pyx_memoryviewslice.tp_base = __pyx_memoryview_type;
+  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(2, 961, __pyx_L1_error)
+  __pyx_type___pyx_memoryviewslice.tp_print = 0;
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type___pyx_memoryviewslice.tp_dictoffset && __pyx_type___pyx_memoryviewslice.tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_type___pyx_memoryviewslice.tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(2, 961, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(2, 961, __pyx_L1_error)
+  __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_modinit_type_import_code(void) {
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
+  /*--- Type import code ---*/
+  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 9, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
+  sizeof(PyTypeObject),
+  #else
+  sizeof(PyHeapTypeObject),
+  #endif
+  __Pyx_ImportType_CheckSize_Warn);
+   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 206, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_ptype_5numpy_dtype = __Pyx_ImportType(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __Pyx_ImportType_CheckSize_Ignore);
+   if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(1, 206, __pyx_L1_error)
+  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __Pyx_ImportType_CheckSize_Warn);
+   if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(1, 229, __pyx_L1_error)
+  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __Pyx_ImportType_CheckSize_Warn);
+   if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(1, 233, __pyx_L1_error)
+  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __Pyx_ImportType_CheckSize_Ignore);
+   if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(1, 242, __pyx_L1_error)
+  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __Pyx_ImportType_CheckSize_Warn);
+   if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(1, 918, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_RefNannyFinishContext();
+  return 0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+}
+
+static int __Pyx_modinit_variable_import_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
+  /*--- Variable import code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+static int __Pyx_modinit_function_import_code(void) {
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
+  /*--- Function import code ---*/
+  __Pyx_RefNannyFinishContext();
+  return 0;
+}
+
+
+#if PY_MAJOR_VERSION < 3
+#ifdef CYTHON_NO_PYINIT_EXPORT
+#define __Pyx_PyMODINIT_FUNC void
+#else
+#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
+#endif
+#else
+#ifdef CYTHON_NO_PYINIT_EXPORT
+#define __Pyx_PyMODINIT_FUNC PyObject *
+#else
+#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
+#endif
+#endif
+
+
 #if PY_MAJOR_VERSION < 3
-PyMODINIT_FUNC init_lomb_scargle(void); /*proto*/
-PyMODINIT_FUNC init_lomb_scargle(void)
+__Pyx_PyMODINIT_FUNC init_lomb_scargle(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC init_lomb_scargle(void)
 #else
-PyMODINIT_FUNC PyInit__lomb_scargle(void); /*proto*/
-PyMODINIT_FUNC PyInit__lomb_scargle(void)
+__Pyx_PyMODINIT_FUNC PyInit__lomb_scargle(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC PyInit__lomb_scargle(void)
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 {
   return PyModuleDef_Init(&__pyx_moduledef);
 }
-static int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name) {
+static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
+    #if PY_VERSION_HEX >= 0x030700A1
+    static PY_INT64_T main_interpreter_id = -1;
+    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
+    if (main_interpreter_id == -1) {
+        main_interpreter_id = current_id;
+        return (unlikely(current_id == -1)) ? -1 : 0;
+    } else if (unlikely(main_interpreter_id != current_id))
+    #else
+    static PyInterpreterState *main_interpreter = NULL;
+    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
+    if (!main_interpreter) {
+        main_interpreter = current_interpreter;
+    } else if (unlikely(main_interpreter != current_interpreter))
+    #endif
+    {
+        PyErr_SetString(
+            PyExc_ImportError,
+            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
+        return -1;
+    }
+    return 0;
+}
+static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
     PyObject *value = PyObject_GetAttrString(spec, from_name);
     int result = 0;
     if (likely(value)) {
-        result = PyDict_SetItemString(moddict, to_name, value);
+        if (allow_none || value != Py_None) {
+            result = PyDict_SetItemString(moddict, to_name, value);
+        }
         Py_DECREF(value);
     } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
         PyErr_Clear();
     } else {
         result = -1;
     }
     return result;
 }
-static PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
+static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
     PyObject *module = NULL, *moddict, *modname;
+    if (__Pyx_check_single_interpreter())
+        return NULL;
     if (__pyx_m)
         return __Pyx_NewRef(__pyx_m);
     modname = PyObject_GetAttrString(spec, "name");
     if (unlikely(!modname)) goto bad;
     module = PyModule_NewObject(modname);
     Py_DECREF(modname);
     if (unlikely(!module)) goto bad;
     moddict = PyModule_GetDict(module);
     if (unlikely(!moddict)) goto bad;
-    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__") < 0)) goto bad;
-    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__") < 0)) goto bad;
-    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__") < 0)) goto bad;
-    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__") < 0)) goto bad;
+    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
+    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
+    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
+    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
     return module;
 bad:
     Py_XDECREF(module);
     return NULL;
 }
 
 
-static int __pyx_pymod_exec__lomb_scargle(PyObject *__pyx_pyinit_module)
+static CYTHON_SMALL_CODE int __pyx_pymod_exec__lomb_scargle(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
   PyObject *__pyx_t_1 = NULL;
   static PyThread_type_lock __pyx_t_2[8];
   __Pyx_RefNannyDeclarations
   #if CYTHON_PEP489_MULTI_PHASE_INIT
-  if (__pyx_m && __pyx_m == __pyx_pyinit_module) return 0;
-  #endif
-  #if CYTHON_REFNANNY
-  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
-  if (!__Pyx_RefNanny) {
-      PyErr_Clear();
-      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
-      if (!__Pyx_RefNanny)
-          Py_FatalError("failed to import 'refnanny' module");
+  if (__pyx_m) {
+    if (__pyx_m == __pyx_pyinit_module) return 0;
+    PyErr_SetString(PyExc_RuntimeError, "Module '_lomb_scargle' has already been imported. Re-initialisation is not supported.");
+    return -1;
   }
+  #elif PY_MAJOR_VERSION >= 3
+  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
   #endif
-  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit__lomb_scargle(void)", 0);
+  #if CYTHON_REFNANNY
+__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
+if (!__Pyx_RefNanny) {
+  PyErr_Clear();
+  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
+  if (!__Pyx_RefNanny)
+      Py_FatalError("failed to import 'refnanny' module");
+}
+#endif
+  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__lomb_scargle(void)", 0);
   if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  #ifdef __Pxy_PyFrame_Initialize_Offsets
+  __Pxy_PyFrame_Initialize_Offsets();
+  #endif
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pyx_CyFunction_USED
   if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   #ifdef __Pyx_FusedFunction_USED
@@ -19854,86 +20006,36 @@
   if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   /*--- Initialize various global constants etc. ---*/
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
   if (__pyx_module_is_main_cesium__features___lomb_scargle) {
-    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
     if (!PyDict_GetItemString(modules, "cesium.features._lomb_scargle")) {
       if (unlikely(PyDict_SetItemString(modules, "cesium.features._lomb_scargle", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
-  /*--- Global init code ---*/
-  generic = Py_None; Py_INCREF(Py_None);
-  strided = Py_None; Py_INCREF(Py_None);
-  indirect = Py_None; Py_INCREF(Py_None);
-  contiguous = Py_None; Py_INCREF(Py_None);
-  indirect_contiguous = Py_None; Py_INCREF(Py_None);
-  /*--- Variable export code ---*/
-  /*--- Function export code ---*/
-  /*--- Type init code ---*/
-  __pyx_vtabptr_array = &__pyx_vtable_array;
-  __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
-  if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(2, 103, __pyx_L1_error)
-  __pyx_type___pyx_array.tp_print = 0;
-  if (__Pyx_SetVtable(__pyx_type___pyx_array.tp_dict, __pyx_vtabptr_array) < 0) __PYX_ERR(2, 103, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_array) < 0) __PYX_ERR(2, 103, __pyx_L1_error)
-  __pyx_array_type = &__pyx_type___pyx_array;
-  if (PyType_Ready(&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(2, 277, __pyx_L1_error)
-  __pyx_type___pyx_MemviewEnum.tp_print = 0;
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_MemviewEnum) < 0) __PYX_ERR(2, 277, __pyx_L1_error)
-  __pyx_MemviewEnum_type = &__pyx_type___pyx_MemviewEnum;
-  __pyx_vtabptr_memoryview = &__pyx_vtable_memoryview;
-  __pyx_vtable_memoryview.get_item_pointer = (char *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_get_item_pointer;
-  __pyx_vtable_memoryview.is_slice = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_is_slice;
-  __pyx_vtable_memoryview.setitem_slice_assignment = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_slice_assignment;
-  __pyx_vtable_memoryview.setitem_slice_assign_scalar = (PyObject *(*)(struct __pyx_memoryview_obj *, struct __pyx_memoryview_obj *, PyObject *))__pyx_memoryview_setitem_slice_assign_scalar;
-  __pyx_vtable_memoryview.setitem_indexed = (PyObject *(*)(struct __pyx_memoryview_obj *, PyObject *, PyObject *))__pyx_memoryview_setitem_indexed;
-  __pyx_vtable_memoryview.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryview_convert_item_to_object;
-  __pyx_vtable_memoryview.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryview_assign_item_from_object;
-  if (PyType_Ready(&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(2, 328, __pyx_L1_error)
-  __pyx_type___pyx_memoryview.tp_print = 0;
-  if (__Pyx_SetVtable(__pyx_type___pyx_memoryview.tp_dict, __pyx_vtabptr_memoryview) < 0) __PYX_ERR(2, 328, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryview) < 0) __PYX_ERR(2, 328, __pyx_L1_error)
-  __pyx_memoryview_type = &__pyx_type___pyx_memoryview;
-  __pyx_vtabptr__memoryviewslice = &__pyx_vtable__memoryviewslice;
-  __pyx_vtable__memoryviewslice.__pyx_base = *__pyx_vtabptr_memoryview;
-  __pyx_vtable__memoryviewslice.__pyx_base.convert_item_to_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *))__pyx_memoryviewslice_convert_item_to_object;
-  __pyx_vtable__memoryviewslice.__pyx_base.assign_item_from_object = (PyObject *(*)(struct __pyx_memoryview_obj *, char *, PyObject *))__pyx_memoryviewslice_assign_item_from_object;
-  __pyx_type___pyx_memoryviewslice.tp_base = __pyx_memoryview_type;
-  if (PyType_Ready(&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(2, 953, __pyx_L1_error)
-  __pyx_type___pyx_memoryviewslice.tp_print = 0;
-  if (__Pyx_SetVtable(__pyx_type___pyx_memoryviewslice.tp_dict, __pyx_vtabptr__memoryviewslice) < 0) __PYX_ERR(2, 953, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type___pyx_memoryviewslice) < 0) __PYX_ERR(2, 953, __pyx_L1_error)
-  __pyx_memoryviewslice_type = &__pyx_type___pyx_memoryviewslice;
-  /*--- Type import code ---*/
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
-  #if CYTHON_COMPILING_IN_PYPY
-  sizeof(PyTypeObject),
-  #else
-  sizeof(PyHeapTypeObject),
-  #endif
-  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) __PYX_ERR(3, 9, __pyx_L1_error)
-  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr), 0); if (unlikely(!__pyx_ptype_5numpy_dtype)) __PYX_ERR(1, 163, __pyx_L1_error)
-  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_flatiter)) __PYX_ERR(1, 185, __pyx_L1_error)
-  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject), 0); if (unlikely(!__pyx_ptype_5numpy_broadcast)) __PYX_ERR(1, 189, __pyx_L1_error)
-  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject), 0); if (unlikely(!__pyx_ptype_5numpy_ndarray)) __PYX_ERR(1, 198, __pyx_L1_error)
-  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType("numpy", "ufunc", sizeof(PyUFuncObject), 0); if (unlikely(!__pyx_ptype_5numpy_ufunc)) __PYX_ERR(1, 885, __pyx_L1_error)
-  /*--- Variable import code ---*/
-  /*--- Function import code ---*/
+  /*--- Global type/function init code ---*/
+  (void)__Pyx_modinit_global_init_code();
+  (void)__Pyx_modinit_variable_export_code();
+  (void)__Pyx_modinit_function_export_code();
+  if (unlikely(__Pyx_modinit_type_init_code() != 0)) goto __pyx_L1_error;
+  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;
+  (void)__Pyx_modinit_variable_import_code();
+  (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
   /* "cesium/features/_lomb_scargle.pyx":4
  * 
@@ -19953,107 +20055,107 @@
  * cimport numpy as cnp
  */
   __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "View.MemoryView":207
+  /* "View.MemoryView":209
  *         info.obj = self
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_array_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  *     def __dealloc__(array self):
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 207, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 209, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 207, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 209, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_array_type);
 
-  /* "View.MemoryView":284
+  /* "View.MemoryView":286
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__29, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 284, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 286, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(generic);
   __Pyx_DECREF_SET(generic, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":285
+  /* "View.MemoryView":287
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 285, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 287, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(strided);
   __Pyx_DECREF_SET(strided, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":286
+  /* "View.MemoryView":288
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 286, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect);
   __Pyx_DECREF_SET(indirect, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":289
+  /* "View.MemoryView":291
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__32, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 289, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__29, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 291, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(contiguous);
   __Pyx_DECREF_SET(contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":290
+  /* "View.MemoryView":292
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__33, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 290, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 292, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect_contiguous);
   __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "View.MemoryView":314
+  /* "View.MemoryView":316
  * 
  * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0             # <<<<<<<<<<<<<<
  * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [
  *     PyThread_allocate_lock(),
  */
   __pyx_memoryview_thread_locks_used = 0;
 
-  /* "View.MemoryView":315
+  /* "View.MemoryView":317
  * DEF THREAD_LOCKS_PREALLOCATED = 8
  * cdef int __pyx_memoryview_thread_locks_used = 0
  * cdef PyThread_type_lock[THREAD_LOCKS_PREALLOCATED] __pyx_memoryview_thread_locks = [             # <<<<<<<<<<<<<<
  *     PyThread_allocate_lock(),
  *     PyThread_allocate_lock(),
  */
   __pyx_t_2[0] = PyThread_allocate_lock();
@@ -20062,68 +20164,68 @@
   __pyx_t_2[3] = PyThread_allocate_lock();
   __pyx_t_2[4] = PyThread_allocate_lock();
   __pyx_t_2[5] = PyThread_allocate_lock();
   __pyx_t_2[6] = PyThread_allocate_lock();
   __pyx_t_2[7] = PyThread_allocate_lock();
   memcpy(&(__pyx_memoryview_thread_locks[0]), __pyx_t_2, sizeof(__pyx_memoryview_thread_locks[0]) * (8));
 
-  /* "View.MemoryView":537
+  /* "View.MemoryView":545
  *         info.obj = self
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 537, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 545, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 537, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 545, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryview_type);
 
-  /* "View.MemoryView":983
+  /* "View.MemoryView":991
  *         return self.from_object
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 983, __pyx_L1_error)
+  __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 991, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 983, __pyx_L1_error)
+  if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 991, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryviewslice_type);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
- *     if __pyx_checksum != 0xb068931:
- *         from pickle import PickleError as __pyx_PickleError
+ *     cdef object __pyx_PickleError
+ *     cdef object __pyx_result
  */
   __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_1) < 0) __PYX_ERR(2, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "(tree fragment)":9
+  /* "(tree fragment)":11
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
  * cdef __pyx_unpickle_Enum__set_state(Enum __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_result.name = __pyx_state[0]
  *     if len(__pyx_state) > 1 and hasattr(__pyx_result, '__dict__'):
  */
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   if (__pyx_m) {
     if (__pyx_d) {
-      __Pyx_AddTraceback("init cesium.features._lomb_scargle", 0, __pyx_lineno, __pyx_filename);
+      __Pyx_AddTraceback("init cesium.features._lomb_scargle", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
-    Py_DECREF(__pyx_m); __pyx_m = 0;
+    Py_CLEAR(__pyx_m);
   } else if (!PyErr_Occurred()) {
     PyErr_SetString(PyExc_ImportError, "init cesium.features._lomb_scargle");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
@@ -20136,17 +20238,17 @@
 
 /* --- Runtime support code --- */
 /* Refnanny */
 #if CYTHON_REFNANNY
 static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
     PyObject *m = NULL, *p = NULL;
     void *r = NULL;
-    m = PyImport_ImportModule((char *)modname);
+    m = PyImport_ImportModule(modname);
     if (!m) goto end;
-    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
+    p = PyObject_GetAttrString(m, "RefNannyAPI");
     if (!p) goto end;
     r = PyLong_AsVoidPtr(p);
 end:
     Py_XDECREF(p);
     Py_XDECREF(m);
     return (__Pyx_RefNannyAPIStruct *)r;
 }
@@ -20782,26 +20884,28 @@
       case 'Z':
         got_Z = 1;
         ++ts;
         if (*ts != 'f' && *ts != 'd' && *ts != 'g') {
           __Pyx_BufFmt_RaiseUnexpectedChar('Z');
           return NULL;
         }
+        CYTHON_FALLTHROUGH;
       case 'c': case 'b': case 'B': case 'h': case 'H': case 'i': case 'I':
       case 'l': case 'L': case 'q': case 'Q':
       case 'f': case 'd': case 'g':
       case 'O': case 'p':
         if (ctx->enc_type == *ts && got_Z == ctx->is_complex &&
             ctx->enc_packmode == ctx->new_packmode) {
           ctx->enc_count += ctx->new_count;
           ctx->new_count = 1;
           got_Z = 0;
           ++ts;
           break;
         }
+        CYTHON_FALLTHROUGH;
       case 's':
         if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
         ctx->enc_count = ctx->new_count;
         ctx->enc_packmode = ctx->new_packmode;
         ctx->enc_type = *ts;
         ctx->is_complex = got_Z;
         ++ts;
@@ -20869,14 +20973,28 @@
   if (buf->suboffsets == NULL) buf->suboffsets = __Pyx_minusones;
   return 0;
 fail:;
   __Pyx_SafeReleaseBuffer(buf);
   return -1;
 }
 
+/* PyObjectGetAttrStr */
+  #if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_getattro))
+        return tp->tp_getattro(obj, attr_name);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_getattr))
+        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
+#endif
+    return PyObject_GetAttr(obj, attr_name);
+}
+#endif
+
 /* GetBuiltinName */
   static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
     PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
     if (unlikely(!result)) {
         PyErr_Format(PyExc_NameError,
 #if PY_MAJOR_VERSION >= 3
             "name '%U' is not defined", name);
@@ -20884,39 +21002,56 @@
             "name '%.200s' is not defined", PyString_AS_STRING(name));
 #endif
     }
     return result;
 }
 
 /* GetModuleGlobalName */
-  static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
+  #if CYTHON_USE_DICT_VERSIONS
+static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
+#else
+static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
+#endif
+{
     PyObject *result;
 #if !CYTHON_AVOID_BORROWED_REFS
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
+    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    } else if (unlikely(PyErr_Occurred())) {
+        return NULL;
+    }
+#else
     result = PyDict_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
     if (likely(result)) {
-        Py_INCREF(result);
-    } else {
+        return __Pyx_NewRef(result);
+    }
+#endif
 #else
     result = PyObject_GetItem(__pyx_d, name);
-    if (!result) {
-        PyErr_Clear();
-#endif
-        result = __Pyx_GetBuiltinName(name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
     }
-    return result;
+    PyErr_Clear();
+#endif
+    return __Pyx_GetBuiltinName(name);
 }
 
 /* BufferIndexError */
-    static void __Pyx_RaiseBufferIndexError(int axis) {
+  static void __Pyx_RaiseBufferIndexError(int axis) {
   PyErr_Format(PyExc_IndexError,
      "Out of bounds on buffer access (axis %d)", axis);
 }
 
 /* PyErrFetchRestore */
-    #if CYTHON_FAST_THREAD_STATE
+  #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     tmp_type = tstate->curexc_type;
     tmp_value = tstate->curexc_value;
     tmp_tb = tstate->curexc_traceback;
     tstate->curexc_type = type;
     tstate->curexc_value = value;
@@ -20932,15 +21067,15 @@
     tstate->curexc_type = 0;
     tstate->curexc_value = 0;
     tstate->curexc_traceback = 0;
 }
 #endif
 
 /* MemviewSliceInit */
-    static int
+  static int
 __Pyx_init_memviewslice(struct __pyx_memoryview_obj *memview,
                         int ndim,
                         __Pyx_memviewslice *memviewslice,
                         int memview_is_new_reference)
 {
     __Pyx_RefNannyDeclarations
     int i, retval=-1;
@@ -21070,15 +21205,15 @@
         }
     } else {
         memslice->memview = NULL;
     }
 }
 
 /* PyObjectCall */
-    #if CYTHON_COMPILING_IN_CPYTHON
+  #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
     PyObject *result;
     ternaryfunc call = func->ob_type->tp_call;
     if (unlikely(!call))
         return PyObject_Call(func, arg, kw);
     if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
         return NULL;
@@ -21090,15 +21225,15 @@
             "NULL result without error in PyObject_Call");
     }
     return result;
 }
 #endif
 
 /* RaiseException */
-    #if PY_MAJOR_VERSION < 3
+  #if PY_MAJOR_VERSION < 3
 static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                         CYTHON_UNUSED PyObject *cause) {
     __Pyx_PyThreadState_declare
     Py_XINCREF(type);
     if (!value || value == Py_None)
         value = NULL;
     else
@@ -21248,70 +21383,313 @@
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
 
+/* PyCFunctionFastCall */
+  #if CYTHON_FAST_PYCCALL
+static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
+    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
+    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
+    PyObject *self = PyCFunction_GET_SELF(func);
+    int flags = PyCFunction_GET_FLAGS(func);
+    assert(PyCFunction_Check(func));
+    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
+    assert(nargs >= 0);
+    assert(nargs == 0 || args != NULL);
+    /* _PyCFunction_FastCallDict() must not be called with an exception set,
+       because it may clear it (directly or indirectly) and so the
+       caller loses its exception */
+    assert(!PyErr_Occurred());
+    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
+        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
+    } else {
+        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
+    }
+}
+#endif
+
+/* PyFunctionFastCall */
+  #if CYTHON_FAST_PYCALL
+static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
+                                               PyObject *globals) {
+    PyFrameObject *f;
+    PyThreadState *tstate = __Pyx_PyThreadState_Current;
+    PyObject **fastlocals;
+    Py_ssize_t i;
+    PyObject *result;
+    assert(globals != NULL);
+    /* XXX Perhaps we should create a specialized
+       PyFrame_New() that doesn't take locals, but does
+       take builtins without sanity checking them.
+       */
+    assert(tstate != NULL);
+    f = PyFrame_New(tstate, co, globals, NULL);
+    if (f == NULL) {
+        return NULL;
+    }
+    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
+    for (i = 0; i < na; i++) {
+        Py_INCREF(*args);
+        fastlocals[i] = *args++;
+    }
+    result = PyEval_EvalFrameEx(f,0);
+    ++tstate->recursion_depth;
+    Py_DECREF(f);
+    --tstate->recursion_depth;
+    return result;
+}
+#if 1 || PY_VERSION_HEX < 0x030600B1
+static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs) {
+    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
+    PyObject *globals = PyFunction_GET_GLOBALS(func);
+    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
+    PyObject *closure;
+#if PY_MAJOR_VERSION >= 3
+    PyObject *kwdefs;
+#endif
+    PyObject *kwtuple, **k;
+    PyObject **d;
+    Py_ssize_t nd;
+    Py_ssize_t nk;
+    PyObject *result;
+    assert(kwargs == NULL || PyDict_Check(kwargs));
+    nk = kwargs ? PyDict_Size(kwargs) : 0;
+    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
+        return NULL;
+    }
+    if (
+#if PY_MAJOR_VERSION >= 3
+            co->co_kwonlyargcount == 0 &&
+#endif
+            likely(kwargs == NULL || nk == 0) &&
+            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
+        if (argdefs == NULL && co->co_argcount == nargs) {
+            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
+            goto done;
+        }
+        else if (nargs == 0 && argdefs != NULL
+                 && co->co_argcount == Py_SIZE(argdefs)) {
+            /* function called with no arguments, but all parameters have
+               a default value: use default values as arguments .*/
+            args = &PyTuple_GET_ITEM(argdefs, 0);
+            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
+            goto done;
+        }
+    }
+    if (kwargs != NULL) {
+        Py_ssize_t pos, i;
+        kwtuple = PyTuple_New(2 * nk);
+        if (kwtuple == NULL) {
+            result = NULL;
+            goto done;
+        }
+        k = &PyTuple_GET_ITEM(kwtuple, 0);
+        pos = i = 0;
+        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
+            Py_INCREF(k[i]);
+            Py_INCREF(k[i+1]);
+            i += 2;
+        }
+        nk = i / 2;
+    }
+    else {
+        kwtuple = NULL;
+        k = NULL;
+    }
+    closure = PyFunction_GET_CLOSURE(func);
+#if PY_MAJOR_VERSION >= 3
+    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
+#endif
+    if (argdefs != NULL) {
+        d = &PyTuple_GET_ITEM(argdefs, 0);
+        nd = Py_SIZE(argdefs);
+    }
+    else {
+        d = NULL;
+        nd = 0;
+    }
+#if PY_MAJOR_VERSION >= 3
+    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
+                               args, nargs,
+                               k, (int)nk,
+                               d, (int)nd, kwdefs, closure);
+#else
+    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
+                               args, nargs,
+                               k, (int)nk,
+                               d, (int)nd, closure);
+#endif
+    Py_XDECREF(kwtuple);
+done:
+    Py_LeaveRecursiveCall();
+    return result;
+}
+#endif
+#endif
+
+/* PyObjectCallMethO */
+  #if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
+    PyObject *self, *result;
+    PyCFunction cfunc;
+    cfunc = PyCFunction_GET_FUNCTION(func);
+    self = PyCFunction_GET_SELF(func);
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    result = cfunc(self, arg);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
+}
+#endif
+
+/* PyObjectCallOneArg */
+  #if CYTHON_COMPILING_IN_CPYTHON
+static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_New(1);
+    if (unlikely(!args)) return NULL;
+    Py_INCREF(arg);
+    PyTuple_SET_ITEM(args, 0, arg);
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
+    return result;
+}
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+#if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(func)) {
+        return __Pyx_PyFunction_FastCall(func, &arg, 1);
+    }
+#endif
+    if (likely(PyCFunction_Check(func))) {
+        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
+            return __Pyx_PyObject_CallMethO(func, arg);
+#if CYTHON_FAST_PYCCALL
+        } else if (PyCFunction_GET_FLAGS(func) & METH_FASTCALL) {
+            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
+#endif
+        }
+    }
+    return __Pyx__PyObject_CallOneArg(func, arg);
+}
+#else
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
+    PyObject *result;
+    PyObject *args = PyTuple_Pack(1, arg);
+    if (unlikely(!args)) return NULL;
+    result = __Pyx_PyObject_Call(func, args, NULL);
+    Py_DECREF(args);
+    return result;
+}
+#endif
+
+/* DictGetItem */
+  #if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
+static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
+    PyObject *value;
+    value = PyDict_GetItemWithError(d, key);
+    if (unlikely(!value)) {
+        if (!PyErr_Occurred()) {
+            if (unlikely(PyTuple_Check(key))) {
+                PyObject* args = PyTuple_Pack(1, key);
+                if (likely(args)) {
+                    PyErr_SetObject(PyExc_KeyError, args);
+                    Py_DECREF(args);
+                }
+            } else {
+                PyErr_SetObject(PyExc_KeyError, key);
+            }
+        }
+        return NULL;
+    }
+    Py_INCREF(value);
+    return value;
+}
+#endif
+
 /* RaiseTooManyValuesToUnpack */
-    static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
+  static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
     PyErr_Format(PyExc_ValueError,
                  "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
 }
 
 /* RaiseNeedMoreValuesToUnpack */
-    static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
+  static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
     PyErr_Format(PyExc_ValueError,
                  "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                  index, (index == 1) ? "" : "s");
 }
 
 /* RaiseNoneIterError */
-    static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
+  static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
 }
 
 /* ExtTypeTest */
-    static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+  static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
     if (unlikely(!type)) {
         PyErr_SetString(PyExc_SystemError, "Missing type object");
         return 0;
     }
     if (likely(__Pyx_TypeCheck(obj, type)))
         return 1;
     PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                  Py_TYPE(obj)->tp_name, type->tp_name);
     return 0;
 }
 
+/* GetTopmostException */
+  #if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem *
+__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
+{
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
+           exc_info->previous_item != NULL)
+    {
+        exc_info = exc_info->previous_item;
+    }
+    return exc_info;
+}
+#endif
+
 /* SaveResetException */
-    #if CYTHON_FAST_THREAD_STATE
+  #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-    #if PY_VERSION_HEX >= 0x030700A2
-    *type = tstate->exc_state.exc_type;
-    *value = tstate->exc_state.exc_value;
-    *tb = tstate->exc_state.exc_traceback;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+    *type = exc_info->exc_type;
+    *value = exc_info->exc_value;
+    *tb = exc_info->exc_traceback;
     #else
     *type = tstate->exc_type;
     *value = tstate->exc_value;
     *tb = tstate->exc_traceback;
     #endif
     Py_XINCREF(*type);
     Py_XINCREF(*value);
     Py_XINCREF(*tb);
 }
 static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
-    #if PY_VERSION_HEX >= 0x030700A2
-    tmp_type = tstate->exc_state.exc_type;
-    tmp_value = tstate->exc_state.exc_value;
-    tmp_tb = tstate->exc_state.exc_traceback;
-    tstate->exc_state.exc_type = type;
-    tstate->exc_state.exc_value = value;
-    tstate->exc_state.exc_traceback = tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    tmp_type = exc_info->exc_type;
+    tmp_value = exc_info->exc_value;
+    tmp_tb = exc_info->exc_traceback;
+    exc_info->exc_type = type;
+    exc_info->exc_value = value;
+    exc_info->exc_traceback = tb;
     #else
     tmp_type = tstate->exc_type;
     tmp_value = tstate->exc_value;
     tmp_tb = tstate->exc_traceback;
     tstate->exc_type = type;
     tstate->exc_value = value;
     tstate->exc_traceback = tb;
@@ -21319,15 +21697,15 @@
     Py_XDECREF(tmp_type);
     Py_XDECREF(tmp_value);
     Py_XDECREF(tmp_tb);
 }
 #endif
 
 /* PyErrExceptionMatches */
-    #if CYTHON_FAST_THREAD_STATE
+  #if CYTHON_FAST_THREAD_STATE
 static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
     Py_ssize_t i, n;
     n = PyTuple_GET_SIZE(tuple);
 #if PY_MAJOR_VERSION >= 3
     for (i=0; i<n; i++) {
         if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
     }
@@ -21344,19 +21722,20 @@
     if (unlikely(PyTuple_Check(err)))
         return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
     return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
 }
 #endif
 
 /* GetException */
-    #if CYTHON_FAST_THREAD_STATE
-static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+  #if CYTHON_FAST_THREAD_STATE
+static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
 #else
-static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
 #endif
+{
     PyObject *local_type, *local_value, *local_tb;
 #if CYTHON_FAST_THREAD_STATE
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     local_type = tstate->curexc_type;
     local_value = tstate->curexc_value;
     local_tb = tstate->curexc_traceback;
     tstate->curexc_type = 0;
@@ -21381,21 +21760,24 @@
     Py_XINCREF(local_tb);
     Py_XINCREF(local_type);
     Py_XINCREF(local_value);
     *type = local_type;
     *value = local_value;
     *tb = local_tb;
 #if CYTHON_FAST_THREAD_STATE
-    #if PY_VERSION_HEX >= 0x030700A2
-    tmp_type = tstate->exc_state.exc_type;
-    tmp_value = tstate->exc_state.exc_value;
-    tmp_tb = tstate->exc_state.exc_traceback;
-    tstate->exc_state.exc_type = local_type;
-    tstate->exc_state.exc_value = local_value;
-    tstate->exc_state.exc_traceback = local_tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    {
+        _PyErr_StackItem *exc_info = tstate->exc_info;
+        tmp_type = exc_info->exc_type;
+        tmp_value = exc_info->exc_value;
+        tmp_tb = exc_info->exc_traceback;
+        exc_info->exc_type = local_type;
+        exc_info->exc_value = local_value;
+        exc_info->exc_traceback = local_tb;
+    }
     #else
     tmp_type = tstate->exc_type;
     tmp_value = tstate->exc_value;
     tmp_tb = tstate->exc_traceback;
     tstate->exc_type = local_type;
     tstate->exc_value = local_value;
     tstate->exc_traceback = local_tb;
@@ -21413,16 +21795,45 @@
     *tb = 0;
     Py_XDECREF(local_type);
     Py_XDECREF(local_value);
     Py_XDECREF(local_tb);
     return -1;
 }
 
+/* PyObjectCall2Args */
+  static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
+    PyObject *args, *result = NULL;
+    #if CYTHON_FAST_PYCALL
+    if (PyFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyFunction_FastCall(function, args, 2);
+    }
+    #endif
+    #if CYTHON_FAST_PYCCALL
+    if (__Pyx_PyFastCFunction_Check(function)) {
+        PyObject *args[2] = {arg1, arg2};
+        return __Pyx_PyCFunction_FastCall(function, args, 2);
+    }
+    #endif
+    args = PyTuple_New(2);
+    if (unlikely(!args)) goto done;
+    Py_INCREF(arg1);
+    PyTuple_SET_ITEM(args, 0, arg1);
+    Py_INCREF(arg2);
+    PyTuple_SET_ITEM(args, 1, arg2);
+    Py_INCREF(function);
+    result = __Pyx_PyObject_Call(function, args, NULL);
+    Py_DECREF(args);
+    Py_DECREF(function);
+done:
+    return result;
+}
+
 /* BytesEquals */
-      static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
+  static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
 #if CYTHON_COMPILING_IN_PYPY
     return PyObject_RichCompareBool(s1, s2, equals);
 #else
     if (s1 == s2) {
         return (equals == Py_EQ);
     } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
         const char *ps1, *ps2;
@@ -21461,15 +21872,15 @@
         Py_DECREF(py_result);
         return result;
     }
 #endif
 }
 
 /* UnicodeEquals */
-      static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
+  static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
 #if CYTHON_COMPILING_IN_PYPY
     return PyObject_RichCompareBool(s1, s2, equals);
 #else
 #if PY_MAJOR_VERSION < 3
     PyObject* owned_ref = NULL;
 #endif
     int s1_is_unicode, s2_is_unicode;
@@ -21540,14 +21951,17 @@
     } else if ((s1 == Py_None) & s2_is_unicode) {
         goto return_ne;
     } else if ((s2 == Py_None) & s1_is_unicode) {
         goto return_ne;
     } else {
         int result;
         PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
+        #if PY_MAJOR_VERSION < 3
+        Py_XDECREF(owned_ref);
+        #endif
         if (!py_result)
             return -1;
         result = __Pyx_PyObject_IsTrue(py_result);
         Py_DECREF(py_result);
         return result;
     }
 return_eq:
@@ -21560,36 +21974,152 @@
     Py_XDECREF(owned_ref);
     #endif
     return (equals == Py_NE);
 #endif
 }
 
 /* None */
-      static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
+  static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
     Py_ssize_t q = a / b;
     Py_ssize_t r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
 /* GetAttr */
-      static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
+  static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
 #if CYTHON_USE_TYPE_SLOTS
 #if PY_MAJOR_VERSION >= 3
     if (likely(PyUnicode_Check(n)))
 #else
     if (likely(PyString_Check(n)))
 #endif
         return __Pyx_PyObject_GetAttrStr(o, n);
 #endif
     return PyObject_GetAttr(o, n);
 }
 
+/* GetItemInt */
+  static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyList_GET_SIZE(o);
+    }
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
+        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
+                                                              CYTHON_NCP_UNUSED int wraparound,
+                                                              CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    Py_ssize_t wrapped_i = i;
+    if (wraparound & unlikely(i < 0)) {
+        wrapped_i += PyTuple_GET_SIZE(o);
+    }
+    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
+        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
+        Py_INCREF(r);
+        return r;
+    }
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+#else
+    return PySequence_GetItem(o, i);
+#endif
+}
+static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
+                                                     CYTHON_NCP_UNUSED int wraparound,
+                                                     CYTHON_NCP_UNUSED int boundscheck) {
+#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
+    if (is_list || PyList_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
+        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
+            PyObject *r = PyList_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    else if (PyTuple_CheckExact(o)) {
+        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
+        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, n);
+            Py_INCREF(r);
+            return r;
+        }
+    } else {
+        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
+        if (likely(m && m->sq_item)) {
+            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
+                Py_ssize_t l = m->sq_length(o);
+                if (likely(l >= 0)) {
+                    i += l;
+                } else {
+                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
+                        return NULL;
+                    PyErr_Clear();
+                }
+            }
+            return m->sq_item(o, i);
+        }
+    }
+#else
+    if (is_list || PySequence_Check(o)) {
+        return PySequence_GetItem(o, i);
+    }
+#endif
+    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+}
+
+/* ObjectGetItem */
+  #if CYTHON_USE_TYPE_SLOTS
+static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
+    PyObject *runerr;
+    Py_ssize_t key_value;
+    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
+    if (unlikely(!(m && m->sq_item))) {
+        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
+        return NULL;
+    }
+    key_value = __Pyx_PyIndex_AsSsize_t(index);
+    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
+        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
+    }
+    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
+        PyErr_Clear();
+        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
+    }
+    return NULL;
+}
+static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
+    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
+    if (likely(m && m->mp_subscript)) {
+        return m->mp_subscript(obj, key);
+    }
+    return __Pyx_PyObject_GetIndex(obj, key);
+}
+#endif
+
 /* decode_c_string */
-      static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
+  static CYTHON_INLINE PyObject* __Pyx_decode_c_string(
          const char* cstring, Py_ssize_t start, Py_ssize_t stop,
          const char* encoding, const char* errors,
          PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {
     Py_ssize_t length;
     if (unlikely((start < 0) | (stop < 0))) {
         size_t slen = strlen(cstring);
         if (unlikely(slen > (size_t) PY_SSIZE_T_MAX)) {
@@ -21614,39 +22144,40 @@
         return decode_func(cstring, length, errors);
     } else {
         return PyUnicode_Decode(cstring, length, encoding, errors);
     }
 }
 
 /* GetAttr3 */
-      static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
+  static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
     __Pyx_PyThreadState_declare
     __Pyx_PyThreadState_assign
     if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
         return NULL;
     __Pyx_PyErr_Clear();
     Py_INCREF(d);
     return d;
 }
 static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
     PyObject *r = __Pyx_GetAttr(o, n);
     return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
 }
 
 /* SwapException */
-      #if CYTHON_FAST_THREAD_STATE
+  #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
-    #if PY_VERSION_HEX >= 0x030700A2
-    tmp_type = tstate->exc_state.exc_type;
-    tmp_value = tstate->exc_state.exc_value;
-    tmp_tb = tstate->exc_state.exc_traceback;
-    tstate->exc_state.exc_type = *type;
-    tstate->exc_state.exc_value = *value;
-    tstate->exc_state.exc_traceback = *tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    tmp_type = exc_info->exc_type;
+    tmp_value = exc_info->exc_value;
+    tmp_tb = exc_info->exc_traceback;
+    exc_info->exc_type = *type;
+    exc_info->exc_value = *value;
+    exc_info->exc_traceback = *tb;
     #else
     tmp_type = tstate->exc_type;
     tmp_value = tstate->exc_value;
     tmp_tb = tstate->exc_traceback;
     tstate->exc_type = *type;
     tstate->exc_value = *value;
     tstate->exc_traceback = *tb;
@@ -21663,15 +22194,15 @@
     *type = tmp_type;
     *value = tmp_value;
     *tb = tmp_tb;
 }
 #endif
 
 /* Import */
-      static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
+  static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
     PyObject *empty_list = 0;
     PyObject *module = 0;
     PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
     PyObject *list;
     #if PY_MAJOR_VERSION < 3
     PyObject *py_import;
@@ -21710,15 +22241,15 @@
         #endif
         if (!module) {
             #if PY_MAJOR_VERSION < 3
             PyObject *py_level = PyInt_FromLong(level);
             if (!py_level)
                 goto bad;
             module = PyObject_CallFunctionObjArgs(py_import,
-                name, global_dict, empty_dict, list, py_level, NULL);
+                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
             Py_DECREF(py_level);
             #else
             module = PyImport_ImportModuleLevelObject(
                 name, global_dict, empty_dict, list, level);
             #endif
         }
     }
@@ -21727,246 +22258,116 @@
     Py_XDECREF(py_import);
     #endif
     Py_XDECREF(empty_list);
     Py_XDECREF(empty_dict);
     return module;
 }
 
-/* PyFunctionFastCall */
-      #if CYTHON_FAST_PYCALL
-#include "frameobject.h"
-static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
-                                               PyObject *globals) {
-    PyFrameObject *f;
-    PyThreadState *tstate = __Pyx_PyThreadState_Current;
-    PyObject **fastlocals;
-    Py_ssize_t i;
-    PyObject *result;
-    assert(globals != NULL);
-    /* XXX Perhaps we should create a specialized
-       PyFrame_New() that doesn't take locals, but does
-       take builtins without sanity checking them.
-       */
-    assert(tstate != NULL);
-    f = PyFrame_New(tstate, co, globals, NULL);
-    if (f == NULL) {
-        return NULL;
-    }
-    fastlocals = f->f_localsplus;
-    for (i = 0; i < na; i++) {
-        Py_INCREF(*args);
-        fastlocals[i] = *args++;
+/* FastTypeChecks */
+  #if CYTHON_COMPILING_IN_CPYTHON
+static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
+    while (a) {
+        a = a->tp_base;
+        if (a == b)
+            return 1;
     }
-    result = PyEval_EvalFrameEx(f,0);
-    ++tstate->recursion_depth;
-    Py_DECREF(f);
-    --tstate->recursion_depth;
-    return result;
+    return b == &PyBaseObject_Type;
 }
-#if 1 || PY_VERSION_HEX < 0x030600B1
-static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs) {
-    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
-    PyObject *globals = PyFunction_GET_GLOBALS(func);
-    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
-    PyObject *closure;
-#if PY_MAJOR_VERSION >= 3
-    PyObject *kwdefs;
-#endif
-    PyObject *kwtuple, **k;
-    PyObject **d;
-    Py_ssize_t nd;
-    Py_ssize_t nk;
-    PyObject *result;
-    assert(kwargs == NULL || PyDict_Check(kwargs));
-    nk = kwargs ? PyDict_Size(kwargs) : 0;
-    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
-        return NULL;
-    }
-    if (
-#if PY_MAJOR_VERSION >= 3
-            co->co_kwonlyargcount == 0 &&
-#endif
-            likely(kwargs == NULL || nk == 0) &&
-            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
-        if (argdefs == NULL && co->co_argcount == nargs) {
-            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
-            goto done;
-        }
-        else if (nargs == 0 && argdefs != NULL
-                 && co->co_argcount == Py_SIZE(argdefs)) {
-            /* function called with no arguments, but all parameters have
-               a default value: use default values as arguments .*/
-            args = &PyTuple_GET_ITEM(argdefs, 0);
-            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
-            goto done;
-        }
-    }
-    if (kwargs != NULL) {
-        Py_ssize_t pos, i;
-        kwtuple = PyTuple_New(2 * nk);
-        if (kwtuple == NULL) {
-            result = NULL;
-            goto done;
-        }
-        k = &PyTuple_GET_ITEM(kwtuple, 0);
-        pos = i = 0;
-        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
-            Py_INCREF(k[i]);
-            Py_INCREF(k[i+1]);
-            i += 2;
+static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
+    PyObject *mro;
+    if (a == b) return 1;
+    mro = a->tp_mro;
+    if (likely(mro)) {
+        Py_ssize_t i, n;
+        n = PyTuple_GET_SIZE(mro);
+        for (i = 0; i < n; i++) {
+            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
+                return 1;
         }
-        nk = i / 2;
-    }
-    else {
-        kwtuple = NULL;
-        k = NULL;
+        return 0;
     }
-    closure = PyFunction_GET_CLOSURE(func);
-#if PY_MAJOR_VERSION >= 3
-    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
-#endif
-    if (argdefs != NULL) {
-        d = &PyTuple_GET_ITEM(argdefs, 0);
-        nd = Py_SIZE(argdefs);
+    return __Pyx_InBases(a, b);
+}
+#if PY_MAJOR_VERSION == 2
+static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
+    PyObject *exception, *value, *tb;
+    int res;
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    __Pyx_ErrFetch(&exception, &value, &tb);
+    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
+    if (unlikely(res == -1)) {
+        PyErr_WriteUnraisable(err);
+        res = 0;
     }
-    else {
-        d = NULL;
-        nd = 0;
+    if (!res) {
+        res = PyObject_IsSubclass(err, exc_type2);
+        if (unlikely(res == -1)) {
+            PyErr_WriteUnraisable(err);
+            res = 0;
+        }
     }
-#if PY_MAJOR_VERSION >= 3
-    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
-                               args, nargs,
-                               k, (int)nk,
-                               d, (int)nd, kwdefs, closure);
-#else
-    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
-                               args, nargs,
-                               k, (int)nk,
-                               d, (int)nd, closure);
-#endif
-    Py_XDECREF(kwtuple);
-done:
-    Py_LeaveRecursiveCall();
-    return result;
+    __Pyx_ErrRestore(exception, value, tb);
+    return res;
 }
-#endif
-#endif
-
-/* PyCFunctionFastCall */
-      #if CYTHON_FAST_PYCCALL
-static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
-    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
-    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
-    PyObject *self = PyCFunction_GET_SELF(func);
-    int flags = PyCFunction_GET_FLAGS(func);
-    assert(PyCFunction_Check(func));
-    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS)));
-    assert(nargs >= 0);
-    assert(nargs == 0 || args != NULL);
-    /* _PyCFunction_FastCallDict() must not be called with an exception set,
-       because it may clear it (directly or indirectly) and so the
-       caller loses its exception */
-    assert(!PyErr_Occurred());
-    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
-        return (*((__Pyx_PyCFunctionFastWithKeywords)meth)) (self, args, nargs, NULL);
-    } else {
-        return (*((__Pyx_PyCFunctionFast)meth)) (self, args, nargs);
+#else
+static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
+    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
+    if (!res) {
+        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
     }
+    return res;
 }
 #endif
-
-/* GetItemInt */
-      static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
-    PyObject *r;
-    if (!j) return NULL;
-    r = PyObject_GetItem(o, j);
-    Py_DECREF(j);
-    return r;
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyList_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely((0 <= wrapped_i) & (wrapped_i < PyList_GET_SIZE(o)))) {
-        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
-    }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
-#endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
-                                                              CYTHON_NCP_UNUSED int wraparound,
-                                                              CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    Py_ssize_t wrapped_i = i;
-    if (wraparound & unlikely(i < 0)) {
-        wrapped_i += PyTuple_GET_SIZE(o);
-    }
-    if ((!boundscheck) || likely((0 <= wrapped_i) & (wrapped_i < PyTuple_GET_SIZE(o)))) {
-        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
-        Py_INCREF(r);
-        return r;
+static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
+    Py_ssize_t i, n;
+    assert(PyExceptionClass_Check(exc_type));
+    n = PyTuple_GET_SIZE(tuple);
+#if PY_MAJOR_VERSION >= 3
+    for (i=0; i<n; i++) {
+        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
     }
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
-#else
-    return PySequence_GetItem(o, i);
 #endif
-}
-static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
-                                                     CYTHON_NCP_UNUSED int wraparound,
-                                                     CYTHON_NCP_UNUSED int boundscheck) {
-#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
-    if (is_list || PyList_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
-        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
-            PyObject *r = PyList_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
+    for (i=0; i<n; i++) {
+        PyObject *t = PyTuple_GET_ITEM(tuple, i);
+        #if PY_MAJOR_VERSION < 3
+        if (likely(exc_type == t)) return 1;
+        #endif
+        if (likely(PyExceptionClass_Check(t))) {
+            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
+        } else {
         }
     }
-    else if (PyTuple_CheckExact(o)) {
-        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
-        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
-            PyObject *r = PyTuple_GET_ITEM(o, n);
-            Py_INCREF(r);
-            return r;
-        }
-    } else {
-        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
-        if (likely(m && m->sq_item)) {
-            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
-                Py_ssize_t l = m->sq_length(o);
-                if (likely(l >= 0)) {
-                    i += l;
-                } else {
-                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
-                        return NULL;
-                    PyErr_Clear();
-                }
-            }
-            return m->sq_item(o, i);
+    return 0;
+}
+static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
+    if (likely(err == exc_type)) return 1;
+    if (likely(PyExceptionClass_Check(err))) {
+        if (likely(PyExceptionClass_Check(exc_type))) {
+            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
+        } else if (likely(PyTuple_Check(exc_type))) {
+            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
+        } else {
         }
     }
-#else
-    if (is_list || PySequence_Check(o)) {
-        return PySequence_GetItem(o, i);
+    return PyErr_GivenExceptionMatches(err, exc_type);
+}
+static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
+    assert(PyExceptionClass_Check(exc_type1));
+    assert(PyExceptionClass_Check(exc_type2));
+    if (likely(err == exc_type1 || err == exc_type2)) return 1;
+    if (likely(PyExceptionClass_Check(err))) {
+        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
     }
-#endif
-    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
+    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
 }
+#endif
 
 /* PyIntBinop */
-      #if !CYTHON_COMPILING_IN_PYPY
+  #if !CYTHON_COMPILING_IN_PYPY
 static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
     #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_CheckExact(op1))) {
         const long b = intval;
         long x;
         long a = PyInt_AS_LONG(op1);
             x = (long)((unsigned long)a + b);
@@ -21996,64 +22397,70 @@
                         break;
 #ifdef HAVE_LONG_LONG
                     } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                         lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         goto long_long;
 #endif
                     }
+                    CYTHON_FALLTHROUGH;
                 case 2:
                     if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                         a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         break;
 #ifdef HAVE_LONG_LONG
                     } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                         lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         goto long_long;
 #endif
                     }
+                    CYTHON_FALLTHROUGH;
                 case -3:
                     if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                         a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         break;
 #ifdef HAVE_LONG_LONG
                     } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                         lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         goto long_long;
 #endif
                     }
+                    CYTHON_FALLTHROUGH;
                 case 3:
                     if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                         a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         break;
 #ifdef HAVE_LONG_LONG
                     } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                         lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         goto long_long;
 #endif
                     }
+                    CYTHON_FALLTHROUGH;
                 case -4:
                     if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                         a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         break;
 #ifdef HAVE_LONG_LONG
                     } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                         lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         goto long_long;
 #endif
                     }
+                    CYTHON_FALLTHROUGH;
                 case 4:
                     if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                         a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                         break;
 #ifdef HAVE_LONG_LONG
                     } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                         lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                         goto long_long;
 #endif
                     }
+                    CYTHON_FALLTHROUGH;
                 default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
             }
         }
                 x = a + b;
             return PyLong_FromLong(x);
 #ifdef HAVE_LONG_LONG
         long_long:
@@ -22074,28 +22481,28 @@
             return PyFloat_FromDouble(result);
     }
     return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
 }
 #endif
 
 /* None */
-      static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
+  static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
     PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
 }
 
 /* None */
-      static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
+  static CYTHON_INLINE long __Pyx_div_long(long a, long b) {
     long q = a / b;
     long r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
 /* WriteUnraisableException */
-      static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
+  static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                   CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                   int full_traceback, CYTHON_UNUSED int nogil) {
     PyObject *old_exc, *old_val, *old_tb;
     PyObject *ctx;
     __Pyx_PyThreadState_declare
 #ifdef WITH_THREAD
     PyGILState_STATE state;
@@ -22128,90 +22535,30 @@
     }
 #ifdef WITH_THREAD
     if (nogil)
         PyGILState_Release(state);
 #endif
 }
 
-/* PyObjectCallMethO */
-      #if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
-    PyObject *self, *result;
-    PyCFunction cfunc;
-    cfunc = PyCFunction_GET_FUNCTION(func);
-    self = PyCFunction_GET_SELF(func);
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
-        return NULL;
-    result = cfunc(self, arg);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
-    }
-    return result;
-}
-#endif
-
-/* PyObjectCallOneArg */
-      #if CYTHON_COMPILING_IN_CPYTHON
-static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *result;
-    PyObject *args = PyTuple_New(1);
-    if (unlikely(!args)) return NULL;
-    Py_INCREF(arg);
-    PyTuple_SET_ITEM(args, 0, arg);
-    result = __Pyx_PyObject_Call(func, args, NULL);
-    Py_DECREF(args);
-    return result;
-}
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-#if CYTHON_FAST_PYCALL
-    if (PyFunction_Check(func)) {
-        return __Pyx_PyFunction_FastCall(func, &arg, 1);
-    }
-#endif
-    if (likely(PyCFunction_Check(func))) {
-        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
-            return __Pyx_PyObject_CallMethO(func, arg);
-#if CYTHON_FAST_PYCCALL
-        } else if (PyCFunction_GET_FLAGS(func) & METH_FASTCALL) {
-            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
-#endif
-        }
-    }
-    return __Pyx__PyObject_CallOneArg(func, arg);
-}
-#else
-static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
-    PyObject *result;
-    PyObject *args = PyTuple_Pack(1, arg);
-    if (unlikely(!args)) return NULL;
-    result = __Pyx_PyObject_Call(func, args, NULL);
-    Py_DECREF(args);
-    return result;
-}
-#endif
-
 /* ImportFrom */
-      static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
+  static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
     PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
     if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
         PyErr_Format(PyExc_ImportError,
         #if PY_MAJOR_VERSION < 3
             "cannot import name %.230s", PyString_AS_STRING(name));
         #else
             "cannot import name %S", name);
         #endif
     }
     return value;
 }
 
 /* HasAttr */
-      static CYTHON_INLINE int __Pyx_HasAttr(PyObject *o, PyObject *n) {
+  static CYTHON_INLINE int __Pyx_HasAttr(PyObject *o, PyObject *n) {
     PyObject *r;
     if (unlikely(!__Pyx_PyBaseString_Check(n))) {
         PyErr_SetString(PyExc_TypeError,
                         "hasattr(): attribute name must be string");
         return -1;
     }
     r = __Pyx_GetAttr(o, n);
@@ -22220,16 +22567,66 @@
         return 0;
     } else {
         Py_DECREF(r);
         return 1;
     }
 }
 
+/* PyObject_GenericGetAttrNoDict */
+  #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
+    PyErr_Format(PyExc_AttributeError,
+#if PY_MAJOR_VERSION >= 3
+                 "'%.50s' object has no attribute '%U'",
+                 tp->tp_name, attr_name);
+#else
+                 "'%.50s' object has no attribute '%.400s'",
+                 tp->tp_name, PyString_AS_STRING(attr_name));
+#endif
+    return NULL;
+}
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
+    PyObject *descr;
+    PyTypeObject *tp = Py_TYPE(obj);
+    if (unlikely(!PyString_Check(attr_name))) {
+        return PyObject_GenericGetAttr(obj, attr_name);
+    }
+    assert(!tp->tp_dictoffset);
+    descr = _PyType_Lookup(tp, attr_name);
+    if (unlikely(!descr)) {
+        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
+    }
+    Py_INCREF(descr);
+    #if PY_MAJOR_VERSION < 3
+    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
+    #endif
+    {
+        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
+        if (unlikely(f)) {
+            PyObject *res = f(descr, obj, (PyObject *)tp);
+            Py_DECREF(descr);
+            return res;
+        }
+    }
+    return descr;
+}
+#endif
+
+/* PyObject_GenericGetAttr */
+  #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
+    if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
+        return PyObject_GenericGetAttr(obj, attr_name);
+    }
+    return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
+}
+#endif
+
 /* SetVTable */
-      static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
+  static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
 #if PY_VERSION_HEX >= 0x02070000
     PyObject *ob = PyCapsule_New(vtable, 0, 0);
 #else
     PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
 #endif
     if (!ob)
         goto bad;
@@ -22239,15 +22636,15 @@
     return 0;
 bad:
     Py_XDECREF(ob);
     return -1;
 }
 
 /* SetupReduce */
-      static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
+  static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
   int ret;
   PyObject *name_attr;
   name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name_2);
   if (likely(name_attr)) {
       ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
   } else {
       ret = -1;
@@ -22314,27 +22711,93 @@
     Py_XDECREF(reduce_ex);
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 
+/* TypeImport */
+  #ifndef __PYX_HAVE_RT_ImportType
+#define __PYX_HAVE_RT_ImportType
+static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+{
+    PyObject *result = 0;
+    char warning[200];
+    Py_ssize_t basicsize;
+#ifdef Py_LIMITED_API
+    PyObject *py_basicsize;
+#endif
+    result = PyObject_GetAttrString(module, class_name);
+    if (!result)
+        goto bad;
+    if (!PyType_Check(result)) {
+        PyErr_Format(PyExc_TypeError,
+            "%.200s.%.200s is not a type object",
+            module_name, class_name);
+        goto bad;
+    }
+#ifndef Py_LIMITED_API
+    basicsize = ((PyTypeObject *)result)->tp_basicsize;
+#else
+    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
+    if (!py_basicsize)
+        goto bad;
+    basicsize = PyLong_AsSsize_t(py_basicsize);
+    Py_DECREF(py_basicsize);
+    py_basicsize = 0;
+    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
+#endif
+    if ((size_t)basicsize < size) {
+        PyErr_Format(PyExc_ValueError,
+            "%.200s.%.200s size changed, may indicate binary incompatibility. "
+            "Expected %zd from C header, got %zd from PyObject",
+            module_name, class_name, size, basicsize);
+        goto bad;
+    }
+    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+        PyErr_Format(PyExc_ValueError,
+            "%.200s.%.200s size changed, may indicate binary incompatibility. "
+            "Expected %zd from C header, got %zd from PyObject",
+            module_name, class_name, size, basicsize);
+        goto bad;
+    }
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+        PyOS_snprintf(warning, sizeof(warning),
+            "%s.%s size changed, may indicate binary incompatibility. "
+            "Expected %zd from C header, got %zd from PyObject",
+            module_name, class_name, size, basicsize);
+        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
+    }
+    return (PyTypeObject *)result;
+bad:
+    Py_XDECREF(result);
+    return NULL;
+}
+#endif
+
 /* CLineInTraceback */
-      #ifndef CYTHON_CLINE_IN_TRACEBACK
-static int __Pyx_CLineForTraceback(CYTHON_UNUSED PyThreadState *tstate, int c_line) {
+  #ifndef CYTHON_CLINE_IN_TRACEBACK
+static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
 #endif
+    if (unlikely(!__pyx_cython_runtime)) {
+        return c_line;
+    }
     __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
 #if CYTHON_COMPILING_IN_CPYTHON
     cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
     if (likely(cython_runtime_dict)) {
-      use_cline = PyDict_GetItem(*cython_runtime_dict, __pyx_n_s_cline_in_traceback);
+        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
+            use_cline, *cython_runtime_dict,
+            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
     } else
 #endif
     {
       PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
       if (use_cline_obj) {
         use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
         Py_DECREF(use_cline_obj);
@@ -22343,24 +22806,24 @@
         use_cline = NULL;
       }
     }
     if (!use_cline) {
         c_line = 0;
         PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
     }
-    else if (PyObject_Not(use_cline) != 0) {
+    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
         c_line = 0;
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
 #endif
 
 /* CodeObjectCache */
-      static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
+  static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
     int start = 0, mid = 0, end = count - 1;
     if (end >= 0 && code_line > entries[end].code_line) {
         return count;
     }
     while (start < end) {
         mid = start + (end - start) / 2;
         if (code_line < entries[mid].code_line) {
@@ -22432,15 +22895,15 @@
     entries[pos].code_line = code_line;
     entries[pos].code_object = code_object;
     __pyx_code_cache.count++;
     Py_INCREF(code_object);
 }
 
 /* AddTraceback */
-      #include "compile.h"
+  #include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
 static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
             const char *funcname, int c_line,
             int py_line, const char *filename) {
     PyCodeObject *py_code = 0;
     PyObject *py_srcfile = 0;
@@ -22540,16 +23003,16 @@
         else if (__Pyx_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) __pyx_pw_5numpy_7ndarray_3__releasebuffer__(obj, view);
     view->obj = NULL;
     Py_DECREF(obj);
 }
 #endif
 
 
-      /* MemviewSliceIsContig */
-      static int
+  /* MemviewSliceIsContig */
+  static int
 __pyx_memviewslice_is_contig(const __Pyx_memviewslice mvs, char order, int ndim)
 {
     int i, index, step, start;
     Py_ssize_t itemsize = mvs.memview->view.itemsize;
     if (order == 'F') {
         step = 1;
         start = 0;
@@ -22563,15 +23026,15 @@
             return 0;
         itemsize *= mvs.shape[index];
     }
     return 1;
 }
 
 /* OverlappingSlices */
-      static void
+  static void
 __pyx_get_array_memory_extents(__Pyx_memviewslice *slice,
                                void **out_start, void **out_end,
                                int ndim, size_t itemsize)
 {
     char *start, *end;
     int i;
     start = end = slice->data;
@@ -22599,28 +23062,28 @@
     void *start1, *end1, *start2, *end2;
     __pyx_get_array_memory_extents(slice1, &start1, &end1, ndim, itemsize);
     __pyx_get_array_memory_extents(slice2, &start2, &end2, ndim, itemsize);
     return (start1 < end2) && (start2 < end1);
 }
 
 /* Capsule */
-      static CYTHON_INLINE PyObject *
+  static CYTHON_INLINE PyObject *
 __pyx_capsule_create(void *p, CYTHON_UNUSED const char *sig)
 {
     PyObject *cobj;
 #if PY_VERSION_HEX >= 0x02070000
     cobj = PyCapsule_New(p, sig, NULL);
 #else
     cobj = PyCObject_FromVoidPtr(p, NULL);
 #endif
     return cobj;
 }
 
 /* CIntFromPyVerify */
-      #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
+  #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
 #define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
 #define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
     {\
         func_type value = func_value;\
         if (sizeof(target_type) < sizeof(func_type)) {\
@@ -22634,15 +23097,15 @@
                     goto raise_overflow;\
             }\
         }\
         return (target_type) value;\
     }
 
 /* TypeInfoCompare */
-      static int
+  static int
 __pyx_typeinfo_cmp(__Pyx_TypeInfo *a, __Pyx_TypeInfo *b)
 {
     int i;
     if (!a || !b)
         return 0;
     if (a == b)
         return 1;
@@ -22675,15 +23138,15 @@
             return !a->fields[i].type && !b->fields[i].type;
         }
     }
     return 1;
 }
 
 /* MemviewSliceValidateAndInit */
-      static int
+  static int
 __pyx_check_strides(Py_buffer *buf, int dim, int ndim, int spec)
 {
     if (buf->shape[dim] <= 1)
         return 1;
     if (buf->strides) {
         if (spec & __Pyx_MEMVIEW_CONTIG) {
             if (spec & (__Pyx_MEMVIEW_PTR|__Pyx_MEMVIEW_FULL)) {
@@ -22857,61 +23320,61 @@
     retval = -1;
 no_fail:
     __Pyx_RefNannyFinishContext();
     return retval;
 }
 
 /* ObjectToMemviewSlice */
-      static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_double(PyObject *obj) {
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_double(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
     int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_STRIDED) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
         return result;
     }
     retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, 0,
-                                                 PyBUF_RECORDS, 1,
+                                                 PyBUF_RECORDS_RO | writable_flag, 1,
                                                  &__Pyx_TypeInfo_double, stack,
                                                  &result, obj);
     if (unlikely(retcode == -1))
         goto __pyx_fail;
     return result;
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
     return result;
 }
 
 /* ObjectToMemviewSlice */
-      static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dsds_double(PyObject *obj) {
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dsds_double(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
     int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_STRIDED), (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_STRIDED) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
         return result;
     }
     retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, 0,
-                                                 PyBUF_RECORDS, 2,
+                                                 PyBUF_RECORDS_RO | writable_flag, 2,
                                                  &__Pyx_TypeInfo_double, stack,
                                                  &result, obj);
     if (unlikely(retcode == -1))
         goto __pyx_fail;
     return result;
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
     return result;
 }
 
 /* Declarations */
-      #if CYTHON_CCOMPLEX
+  #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
       return ::std::complex< float >(x, y);
     }
   #else
     static CYTHON_INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
       return x + y*(__pyx_t_float_complex)_Complex_I;
@@ -22923,15 +23386,15 @@
       z.real = x;
       z.imag = y;
       return z;
     }
 #endif
 
 /* Arithmetic */
-      #if CYTHON_CCOMPLEX
+  #if CYTHON_CCOMPLEX
 #else
     static CYTHON_INLINE int __Pyx_c_eq_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
        return (a.real == b.real) && (a.imag == b.imag);
     }
     static CYTHON_INLINE __pyx_t_float_complex __Pyx_c_sum_float(__pyx_t_float_complex a, __pyx_t_float_complex b) {
         __pyx_t_float_complex z;
         z.real = a.real + b.real;
@@ -23058,15 +23521,15 @@
             z.imag = z_r * sinf(z_theta);
             return z;
         }
     #endif
 #endif
 
 /* Declarations */
-      #if CYTHON_CCOMPLEX
+  #if CYTHON_CCOMPLEX
   #ifdef __cplusplus
     static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
       return ::std::complex< double >(x, y);
     }
   #else
     static CYTHON_INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
       return x + y*(__pyx_t_double_complex)_Complex_I;
@@ -23078,15 +23541,15 @@
       z.real = x;
       z.imag = y;
       return z;
     }
 #endif
 
 /* Arithmetic */
-      #if CYTHON_CCOMPLEX
+  #if CYTHON_CCOMPLEX
 #else
     static CYTHON_INLINE int __Pyx_c_eq_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
        return (a.real == b.real) && (a.imag == b.imag);
     }
     static CYTHON_INLINE __pyx_t_double_complex __Pyx_c_sum_double(__pyx_t_double_complex a, __pyx_t_double_complex b) {
         __pyx_t_double_complex z;
         z.real = a.real + b.real;
@@ -23213,16 +23676,16 @@
             z.imag = z_r * sin(z_theta);
             return z;
         }
     #endif
 #endif
 
 /* CIntToPy */
-      static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
-    const int neg_one = (int) -1, const_zero = (int) 0;
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
+    const int neg_one = (int) ((int) 0 - (int) 1), const_zero = (int) 0;
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
         if (sizeof(int) < sizeof(long)) {
             return PyInt_FromLong((long) value);
         } else if (sizeof(int) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
@@ -23244,16 +23707,16 @@
         unsigned char *bytes = (unsigned char *)&value;
         return _PyLong_FromByteArray(bytes, sizeof(int),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntToPy */
-      static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__NPY_TYPES(enum NPY_TYPES value) {
-    const enum NPY_TYPES neg_one = (enum NPY_TYPES) -1, const_zero = (enum NPY_TYPES) 0;
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__NPY_TYPES(enum NPY_TYPES value) {
+    const enum NPY_TYPES neg_one = (enum NPY_TYPES) ((enum NPY_TYPES) 0 - (enum NPY_TYPES) 1), const_zero = (enum NPY_TYPES) 0;
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
         if (sizeof(enum NPY_TYPES) < sizeof(long)) {
             return PyInt_FromLong((long) value);
         } else if (sizeof(enum NPY_TYPES) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
@@ -23275,15 +23738,15 @@
         unsigned char *bytes = (unsigned char *)&value;
         return _PyLong_FromByteArray(bytes, sizeof(enum NPY_TYPES),
                                      little, !is_unsigned);
     }
 }
 
 /* MemviewSliceCopyTemplate */
-      static __Pyx_memviewslice
+  static __Pyx_memviewslice
 __pyx_memoryview_copy_new_contig(const __Pyx_memviewslice *from_mvs,
                                  const char *mode, int ndim,
                                  size_t sizeof_dtype, int contig_flag,
                                  int dtype_is_object)
 {
     __Pyx_RefNannyDeclarations
     int i;
@@ -23342,16 +23805,16 @@
     __Pyx_XDECREF(temp_int);
     __Pyx_XDECREF(array_obj);
     __Pyx_RefNannyFinishContext();
     return new_mvs;
 }
 
 /* CIntFromPy */
-      static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
-    const int neg_one = (int) -1, const_zero = (int) 0;
+  static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
+    const int neg_one = (int) ((int) 0 - (int) 1), const_zero = (int) 0;
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
         if (sizeof(int) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
@@ -23531,16 +23994,16 @@
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to int");
     return (int) -1;
 }
 
 /* CIntFromPy */
-      static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
-    const long neg_one = (long) -1, const_zero = (long) 0;
+  static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
+    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
         if (sizeof(long) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
@@ -23720,16 +24183,16 @@
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to long");
     return (long) -1;
 }
 
 /* CIntToPy */
-      static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-    const long neg_one = (long) -1, const_zero = (long) 0;
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
+    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;
     const int is_unsigned = neg_one > const_zero;
     if (is_unsigned) {
         if (sizeof(long) < sizeof(long)) {
             return PyInt_FromLong((long) value);
         } else if (sizeof(long) <= sizeof(unsigned long)) {
             return PyLong_FromUnsignedLong((unsigned long) value);
 #ifdef HAVE_LONG_LONG
@@ -23751,16 +24214,16 @@
         unsigned char *bytes = (unsigned char *)&value;
         return _PyLong_FromByteArray(bytes, sizeof(long),
                                      little, !is_unsigned);
     }
 }
 
 /* CIntFromPy */
-      static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *x) {
-    const char neg_one = (char) -1, const_zero = (char) 0;
+  static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *x) {
+    const char neg_one = (char) ((char) 0 - (char) 1), const_zero = (char) 0;
     const int is_unsigned = neg_one > const_zero;
 #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_Check(x))) {
         if (sizeof(char) < sizeof(long)) {
             __PYX_VERIFY_RETURN_INT(char, long, PyInt_AS_LONG(x))
         } else {
             long val = PyInt_AS_LONG(x);
@@ -23939,187 +24402,32 @@
     return (char) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to char");
     return (char) -1;
 }
 
-/* FastTypeChecks */
-      #if CYTHON_COMPILING_IN_CPYTHON
-static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
-    while (a) {
-        a = a->tp_base;
-        if (a == b)
-            return 1;
-    }
-    return b == &PyBaseObject_Type;
-}
-static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
-    PyObject *mro;
-    if (a == b) return 1;
-    mro = a->tp_mro;
-    if (likely(mro)) {
-        Py_ssize_t i, n;
-        n = PyTuple_GET_SIZE(mro);
-        for (i = 0; i < n; i++) {
-            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
-                return 1;
-        }
-        return 0;
-    }
-    return __Pyx_InBases(a, b);
-}
-#if PY_MAJOR_VERSION == 2
-static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
-    PyObject *exception, *value, *tb;
-    int res;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&exception, &value, &tb);
-    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
-    if (unlikely(res == -1)) {
-        PyErr_WriteUnraisable(err);
-        res = 0;
-    }
-    if (!res) {
-        res = PyObject_IsSubclass(err, exc_type2);
-        if (unlikely(res == -1)) {
-            PyErr_WriteUnraisable(err);
-            res = 0;
-        }
-    }
-    __Pyx_ErrRestore(exception, value, tb);
-    return res;
-}
-#else
-static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
-    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
-    if (!res) {
-        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
-    }
-    return res;
-}
-#endif
-static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
-    if (likely(err == exc_type)) return 1;
-    if (likely(PyExceptionClass_Check(err))) {
-        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
-    }
-    return PyErr_GivenExceptionMatches(err, exc_type);
-}
-static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
-    if (likely(err == exc_type1 || err == exc_type2)) return 1;
-    if (likely(PyExceptionClass_Check(err))) {
-        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
-    }
-    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
-}
-#endif
-
 /* CheckBinaryVersion */
-      static int __Pyx_check_binary_version(void) {
+  static int __Pyx_check_binary_version(void) {
     char ctversion[4], rtversion[4];
     PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
     PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
     if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
         char message[200];
         PyOS_snprintf(message, sizeof(message),
                       "compiletime version %s of module '%.100s' "
                       "does not match runtime version %s",
                       ctversion, __Pyx_MODULE_NAME, rtversion);
         return PyErr_WarnEx(NULL, message, 1);
     }
     return 0;
 }
 
-/* ModuleImport */
-      #ifndef __PYX_HAVE_RT_ImportModule
-#define __PYX_HAVE_RT_ImportModule
-static PyObject *__Pyx_ImportModule(const char *name) {
-    PyObject *py_name = 0;
-    PyObject *py_module = 0;
-    py_name = __Pyx_PyIdentifier_FromString(name);
-    if (!py_name)
-        goto bad;
-    py_module = PyImport_Import(py_name);
-    Py_DECREF(py_name);
-    return py_module;
-bad:
-    Py_XDECREF(py_name);
-    return 0;
-}
-#endif
-
-/* TypeImport */
-      #ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
-    size_t size, int strict)
-{
-    PyObject *py_module = 0;
-    PyObject *result = 0;
-    PyObject *py_name = 0;
-    char warning[200];
-    Py_ssize_t basicsize;
-#ifdef Py_LIMITED_API
-    PyObject *py_basicsize;
-#endif
-    py_module = __Pyx_ImportModule(module_name);
-    if (!py_module)
-        goto bad;
-    py_name = __Pyx_PyIdentifier_FromString(class_name);
-    if (!py_name)
-        goto bad;
-    result = PyObject_GetAttr(py_module, py_name);
-    Py_DECREF(py_name);
-    py_name = 0;
-    Py_DECREF(py_module);
-    py_module = 0;
-    if (!result)
-        goto bad;
-    if (!PyType_Check(result)) {
-        PyErr_Format(PyExc_TypeError,
-            "%.200s.%.200s is not a type object",
-            module_name, class_name);
-        goto bad;
-    }
-#ifndef Py_LIMITED_API
-    basicsize = ((PyTypeObject *)result)->tp_basicsize;
-#else
-    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
-    if (!py_basicsize)
-        goto bad;
-    basicsize = PyLong_AsSsize_t(py_basicsize);
-    Py_DECREF(py_basicsize);
-    py_basicsize = 0;
-    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
-        goto bad;
-#endif
-    if (!strict && (size_t)basicsize > size) {
-        PyOS_snprintf(warning, sizeof(warning),
-            "%s.%s size changed, may indicate binary incompatibility. Expected %zd, got %zd",
-            module_name, class_name, basicsize, size);
-        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
-    }
-    else if ((size_t)basicsize != size) {
-        PyErr_Format(PyExc_ValueError,
-            "%.200s.%.200s has the wrong size, try recompiling. Expected %zd, got %zd",
-            module_name, class_name, basicsize, size);
-        goto bad;
-    }
-    return (PyTypeObject *)result;
-bad:
-    Py_XDECREF(py_module);
-    Py_XDECREF(result);
-    return NULL;
-}
-#endif
-
 /* InitStrings */
-      static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+  static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
     while (t->p) {
         #if PY_MAJOR_VERSION < 3
         if (t->is_unicode) {
             *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
         } else if (t->intern) {
             *t->p = PyString_InternFromString(t->s);
         } else {
@@ -24137,15 +24445,15 @@
         } else {
             *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
         }
         #endif
         if (!*t->p)
             return -1;
         if (PyObject_Hash(*t->p) == -1)
-            PyErr_Clear();
+            return -1;
         ++t;
     }
     return 0;
 }
 
 static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
     return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
@@ -24220,14 +24528,21 @@
     }
 }
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
    int is_true = x == Py_True;
    if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
    else return PyObject_IsTrue(x);
 }
+static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
+    int retval;
+    if (unlikely(!x)) return -1;
+    retval = __Pyx_PyObject_IsTrue(x);
+    Py_DECREF(x);
+    return retval;
+}
 static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
 #if PY_MAJOR_VERSION >= 3
     if (PyLong_Check(result)) {
         if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
                 "__int__ returned non-int (type %.200s).  "
                 "The ability to return an instance of a strict subclass of int "
                 "is deprecated, and may be removed in a future version of Python.",
@@ -24297,15 +24612,15 @@
   Py_ssize_t ival;
   PyObject *x;
 #if PY_MAJOR_VERSION < 3
   if (likely(PyInt_CheckExact(b))) {
     if (sizeof(Py_ssize_t) >= sizeof(long))
         return PyInt_AS_LONG(b);
     else
-        return PyInt_AsSsize_t(x);
+        return PyInt_AsSsize_t(b);
   }
 #endif
   if (likely(PyLong_CheckExact(b))) {
     #if CYTHON_USE_PYLONG_INTERNALS
     const digit* digits = ((PyLongObject*)b)->ob_digit;
     const Py_ssize_t size = Py_SIZE(b);
     if (likely(__Pyx_sst_abs(size) <= 1)) {
@@ -24351,13 +24666,16 @@
   }
   x = PyNumber_Index(b);
   if (!x) return -1;
   ival = PyInt_AsSsize_t(x);
   Py_DECREF(x);
   return ival;
 }
+static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
+  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
+}
 static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
     return PyInt_FromSize_t(ival);
 }
 
 
 #endif /* Py_PYTHON_H */
```

### Comparing `cesium-0.9.7/cesium/features/amplitude.py` & `cesium-0.9.9/cesium/features/amplitude.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-import numpy as np
-
-
-def amplitude(x):
-    """Half the difference between the maximum and minimum magnitude."""
-    return (np.max(x) - np.min(x)) / 2.0
-
-
-# TODO old comment did not match code; is this the quantity we want to compute?
-def percent_amplitude(x, base=10., exponent=-0.4):
-    """Returns the largest distance from the median value, measured
-    as a percentage of the median.
-
-    Assumes data is log-scaled; by default we assume inputs are scaled as
-    x=10^(-0.4*y), corresponding to units of magnitudes. Computations are
-    performed on the corresponding linear-scale values.
-    """
-    linear_scale_data = base ** (exponent * x)
-    y_max = np.max(linear_scale_data)
-    y_min = np.min(linear_scale_data)
-    y_med = np.median(linear_scale_data)
-    return max(abs((y_max - y_med) / y_med), abs((y_med - y_min) / y_med))
-
-
-def percent_difference_flux_percentile(x, base=10., exponent=-0.4):
-    """Difference between the 95th and 5th percentiles of the data, expressed
-    as a percentage of the median value.
-    See Eyer (2005) arXiv:astro-ph/0511458v1, Evans & Belokurov (2005) (there
-    the 98th and 2nd percentiles are used).
-
-    Assumes data is log-scaled; by default we assume inputs are scaled as
-    x=10^(-0.4*y), corresponding to units of magnitudes. Computations are
-    performed on the corresponding linear-scale values.
-    """
-    linear_scale_data = base ** (exponent * x)
-    y_95, y_50, y_5 = np.percentile(linear_scale_data, [95, 50, 5])
-    return (y_95 - y_5) / y_50
-
-
-def flux_percentile_ratio(x, percentile_range, base=10., exponent=-0.4):
-    """A ratio of ((50+x) flux percentile - (50-x) flux percentile) /
-    (95 flux percentile - 5 flux percentile), where x = percentile_range/2.
-
-    Assumes data is log-scaled; by default we assume inputs are scaled as
-    x=10^(-0.4*y), corresponding to units of magnitudes. Computations are
-    performed on the corresponding linear-scale values.
-    """
-    linear_scale_data = base ** (exponent * x)
-    y_high, y_low, y_95, y_5 = np.percentile(linear_scale_data,
-            [50 + percentile_range / 2., 50 - percentile_range / 2., 95, 5])
-    return (y_high - y_low) / (y_95 - y_5)
+import numpy as np
+
+
+def amplitude(x):
+    """Half the difference between the maximum and minimum magnitude."""
+    return (np.max(x) - np.min(x)) / 2.0
+
+
+# TODO old comment did not match code; is this the quantity we want to compute?
+def percent_amplitude(x, base=10., exponent=-0.4):
+    """Returns the largest distance from the median value, measured
+    as a percentage of the median.
+
+    Assumes data is log-scaled; by default we assume inputs are scaled as
+    x=10^(-0.4*y), corresponding to units of magnitudes. Computations are
+    performed on the corresponding linear-scale values.
+    """
+    linear_scale_data = base ** (exponent * x)
+    y_max = np.max(linear_scale_data)
+    y_min = np.min(linear_scale_data)
+    y_med = np.median(linear_scale_data)
+    return max(abs((y_max - y_med) / y_med), abs((y_med - y_min) / y_med))
+
+
+def percent_difference_flux_percentile(x, base=10., exponent=-0.4):
+    """Difference between the 95th and 5th percentiles of the data, expressed
+    as a percentage of the median value.
+    See Eyer (2005) arXiv:astro-ph/0511458v1, Evans & Belokurov (2005) (there
+    the 98th and 2nd percentiles are used).
+
+    Assumes data is log-scaled; by default we assume inputs are scaled as
+    x=10^(-0.4*y), corresponding to units of magnitudes. Computations are
+    performed on the corresponding linear-scale values.
+    """
+    linear_scale_data = base ** (exponent * x)
+    y_95, y_50, y_5 = np.percentile(linear_scale_data, [95, 50, 5])
+    return (y_95 - y_5) / y_50
+
+
+def flux_percentile_ratio(x, percentile_range, base=10., exponent=-0.4):
+    """A ratio of ((50+x) flux percentile - (50-x) flux percentile) /
+    (95 flux percentile - 5 flux percentile), where x = percentile_range/2.
+
+    Assumes data is log-scaled; by default we assume inputs are scaled as
+    x=10^(-0.4*y), corresponding to units of magnitudes. Computations are
+    performed on the corresponding linear-scale values.
+    """
+    linear_scale_data = base ** (exponent * x)
+    y_high, y_low, y_95, y_5 = np.percentile(linear_scale_data,
+            [50 + percentile_range / 2., 50 - percentile_range / 2., 95, 5])
+    return (y_high - y_low) / (y_95 - y_5)
```

### Comparing `cesium-0.9.7/cesium/features/lomb_scargle.py` & `cesium-0.9.9/cesium/features/lomb_scargle.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,360 +1,360 @@
-import numpy as np
-import scipy.stats as stats
-from ._lomb_scargle import lomb_scargle
-
-
-def lomb_scargle_model(time, signal, error, sys_err=0.05, nharm=8, nfreq=3, tone_control=5.0):
-    """Simultaneous fit of a sum of sinusoids by weighted least squares:
-           y(t) = Sum_k Ck*t^k + Sum_i Sum_j A_ij sin(2*pi*j*fi*(t-t0)+phi_j),
-           i=[1,nfreq], j=[1,nharm]
-
-    Parameters
-    ----------
-    time : array_like
-        Array containing time values.
-
-    signal : array_like
-        Array containing data values.
-
-    error : array_like
-        Array containing measurement error values.
-
-    nharm : int
-        Number of harmonics to fit for each frequency.
-
-    nfreq : int
-        Number of frequencies to fit.
-
-    Returns
-    -------
-    dict
-        Dictionary containing fitted parameter values. Parameters specific to
-        a specific fitted frequency are stored in a list of dicts at
-        model_dict['freq_fits'], each of which contains the output of
-        fit_lomb_scargle(...)
-
-    """
-
-    dy0 = np.sqrt(error**2 + sys_err**2)
-
-    wt = 1. / dy0**2
-    time = time.copy() - min(time) # speeds up lomb_scargle code to have min(time)==0
-    signal = signal.copy()
-
-    chi0 = np.dot(signal**2, wt)
-
-# TODO parametrize?
-    f0 = 1. / max(time)
-    df = 0.8 / max(time) # 20120202 :    0.1/Xmax
-    fmax = 33. #pre 20120126: 10. # 25
-    numf = int((fmax - f0) / df) # TODO !!! this is off by 1 point, fix?
-
-    model_dict = {'freq_fits' : []}
-    lambda0_range = [-np.log10(len(time)), 8] # these numbers "fix" the strange-amplitude effect
-    for i in range(nfreq):
-        if i == 0:
-            fit = fit_lomb_scargle(time, signal, dy0, f0, df, numf,
-                    tone_control=tone_control, lambda0_range=lambda0_range,
-                    nharm=nharm, detrend_order=1)
-            model_dict['trend'] = fit['trend_coef'][1]
-        else:
-            fit = fit_lomb_scargle(time, signal, dy0, f0, df, numf,
-                    tone_control=tone_control, lambda0_range=lambda0_range,
-                    nharm=nharm, detrend_order=0)
-        model_dict['freq_fits'].append(fit)
-        signal -= fit['model']
-        model_dict['freq_fits'][-1]['resid'] = signal.copy()
-        if i == 0:
-            model_dict['varrat'] = np.dot(signal**2, wt) / chi0
-
-    model_dict['nfreq'] = nfreq
-    model_dict['nharm'] = nharm
-    model_dict['chi2'] = fit['chi2']
-    model_dict['f0'] = f0
-    model_dict['df'] = df
-    model_dict['numf'] = numf
-
-    return model_dict
-
-
-def lprob2sigma(lprob):
-    """Translate a log_e(probability) to units of Gaussian sigmas."""
-    if lprob > -36.:
-        sigma = stats.norm.ppf(1. - 0.5 * np.exp(lprob))
-    else:
-        sigma = np.sqrt(np.log(2. / np.pi) - 2. * np.log(8.2) - 2. * lprob)
-        f = 0.5 * np.log(2. / np.pi) - 0.5 * sigma**2 - np.log(sigma) - lprob
-        sigma += f / (sigma + 1. / sigma)
-    return sigma
-
-
-def fit_lomb_scargle(time, signal, error, f0, df, numf, nharm=8, psdmin=6., detrend_order=0,
-         freq_zoom=10., tone_control=5., lambda0=1., lambda0_range=[-8,6]):
-    """Calls C implementation of Lomb Scargle sinusoid fitting, which fits a
-    single frequency with nharm harmonics to the data. Called repeatedly by
-    lomb_scargle_model in order to produce a fit with multiple distinct
-    frequencies.
-
-    Inputs:
-    time : array_like
-        Array containing time values.
-
-    signal : array_like
-        Array containing data values.
-
-    error : array_like
-        Array containing measurement error values.
-
-    f0 : float
-        Smallest frequency value to consider.
-
-    df : float
-        Step size for frequency grid search.
-
-    numf : int
-        Number of frequencies for frequency grid search.
-
-    nharm : int
-        Number of harmonics to fit.
-
-    detrend_order : int
-        Order of polynomial detrending.
-
-    psdmin : int
-        Refine periodogram values with larger psd using multi-harmonic fit
-
-    nharm : int
-        Number of harmonics to use in refinement
-
-    lambda0 : float
-        Typical value for regularization parameter
-
-    lambda0_range : [float, float]
-        Allowable range for log10 of regularization parameter
-
-    Returns
-    -------
-    dict
-        Dictionary describing various parameters of the multiharmonic fit at
-        the best-fit frequency
-    """
-    ntime = len(time)
-
-# For some reason we round this to the nearest even integer
-    freq_zoom = round(freq_zoom/2.)*2.
-
-# Polynomial terms
-    coef = np.zeros(detrend_order + 1, dtype='float64')
-    norm = np.zeros(detrend_order + 1, dtype='float64')
-
-    wth0 = 1. / error
-    s0 = np.dot(wth0, wth0)
-    wth0 /= np.sqrt(s0)
-
-    cn = signal * wth0
-    coef[0] = np.dot(cn,wth0)
-    cn0 = coef[0]
-    norm[0] = 1.
-    cn -= coef[0] * wth0
-    vcn = 1.
-
-    # np.sin's and cosin's for later
-    tt = 2. * np.pi * time
-    sinx,cosx = np.sin(tt*f0)*wth0,np.cos(tt*f0)*wth0
-    sinx_step,cosx_step = np.sin(tt*df),np.cos(tt*df)
-    sinx_back,cosx_back = -np.sin(tt*df/2.),np.cos(tt*df/2)
-    sinx_smallstep,cosx_smallstep = np.sin(tt*df/freq_zoom),np.cos(tt*df/freq_zoom)
-
-    npar = 2*nharm
-    hat_matr = np.zeros((npar,ntime),dtype='float64')
-    hat0 = np.zeros((npar,detrend_order+1),dtype='float64')
-    hat_hat = np.zeros((npar,npar),dtype='float64')
-    soln = np.zeros(npar,dtype='float64')
-    psd = np.zeros(numf,dtype='float64')
-
-    # Detrend the data and create the orthogonal detrending basis
-    if detrend_order > 0:
-        wth = np.zeros((detrend_order + 1, ntime),dtype='float64')
-        wth[0,:] = wth0
-    else:
-        wth = wth0
-
-    for i in range(detrend_order):
-        f = wth[i,:] * tt / (2 * np.pi)
-        for j in range(i+1):
-            f -= np.dot(f, wth[j,:]) * wth[j,:]
-        norm[i+1] = np.sqrt(np.dot(f,f))
-        f /= norm[i+1]
-        coef[i+1] = np.dot(cn,f)
-        cn -= coef[i+1]*f
-        wth[i+1,:] = f
-        vcn += (f/wth0)**2
-
-    chi0 = np.dot(cn,cn)
-    varcn = chi0/(ntime-1-detrend_order)
-    psdmin *= 2*varcn
-
-    Tr = np.array(0., dtype='float64')
-    ifreq = np.array(0, dtype='int32')
-    lambda0 = np.array(lambda0 / s0, dtype='float64')
-    lambda0_range = 10**np.array(lambda0_range, dtype='float64') / s0
-
-    lomb_scargle(ntime, numf, nharm, detrend_order, psd, cn, wth, sinx, cosx,
-            sinx_step, cosx_step, sinx_back, cosx_back, sinx_smallstep,
-            cosx_smallstep, hat_matr, hat_hat, hat0, soln, chi0, freq_zoom,
-            psdmin, tone_control, lambda0, lambda0_range, Tr, ifreq)
-
-    hat_hat /= s0
-    ii = np.arange(nharm, dtype='int32')
-    soln[0:nharm] /= (1. + ii)**2
-    soln[nharm:] /= (1. + ii)**2
-    hat_matr0 = np.outer(hat0[:,0], wth0)
-    for i in range(detrend_order):
-        hat_matr0 += np.outer(hat0[:,i+1], wth[i+1,:])
-
-    modl = np.dot(hat_matr.T, soln)
-    coef0 = np.dot(soln, hat0)
-    coef -= coef0
-    hat_matr -= hat_matr0
-
-    out_dict = {}
-    out_dict['psd'] = psd
-    out_dict['chi0'] = chi0 * s0
-    if detrend_order > 0:
-        out_dict['trend'] = np.dot(coef,wth)/wth0
-    else:
-        out_dict['trend'] = coef[0] + 0*wth0
-    out_dict['model'] = modl/wth0 + out_dict['trend']
-
-    j = psd.argmax()
-    freq = f0 + df * j + (ifreq / freq_zoom - 1/2.) * df
-    tt = (time * freq) % 1.
-    out_dict['freq'] = freq
-    out_dict['s0'] = s0
-    out_dict['chi2'] = (chi0 - psd[j]) * s0
-    out_dict['psd'] = psd[j] * 0.5 / varcn
-    out_dict['lambda'] = lambda0 * s0
-#    out_dict['gcv_weight'] = (1 - 3. / ntime) / Tr
-    out_dict['trace'] = Tr
-    out_dict['nu0'] = ntime - npar
-    npars = (1 - Tr) * ntime / 2.
-    out_dict['nu'] = ntime - npars
-    out_dict['npars'] = npars
-
-    A0, B0 = soln[0:nharm], soln[nharm:]
-    hat_hat /= np.outer(np.hstack(((1.+ii)**2, (1.+ii)**2)), np.hstack(((1.+ii)**2, (1.+ii)**2)))
-    err2 = np.diag(hat_hat)
-    vA0, vB0 = err2[0:nharm], err2[nharm:]
-    covA0B0 = hat_hat[(ii,nharm+ii)]
-
-    vmodl = vcn/s0 + np.dot((hat_matr/wth0).T, np.dot(hat_hat, hat_matr/wth0))
-    vmodl0 = vcn/s0 + np.dot((hat_matr0/wth0).T, np.dot(hat_hat, hat_matr0/wth0))
-    out_dict['model_error'] = np.sqrt(np.diag(vmodl))
-    out_dict['trend_error'] = np.sqrt(np.diag(vmodl0))
-
-    amp = np.sqrt(A0**2 + B0**2)
-    damp = np.sqrt(A0**2 * vA0 + B0**2 * vB0 + 2. * A0 * B0 * covA0B0) / amp
-    phase = np.arctan2(B0, A0)
-    rel_phase = phase - phase[0]*(1.+ii)
-    rel_phase = np.arctan2(np.sin(rel_phase), np.cos(rel_phase))
-    dphase = 0.*rel_phase
-    for i in range(nharm - 1):
-        j = i + 1
-        v = np.array([-A0[0] * (1. + j) / amp[0]**2, B0[0] * (1. + j) / amp[0]**2, A0[j] / amp[j]**2, -B0[j] / amp[j]**2])
-        jj = np.array([0, nharm, j, j+nharm])
-        m = hat_hat[np.ix_(jj, jj)]
-        dphase[j] = np.sqrt(np.dot(np.dot(v, m), v))
-
-    out_dict['amplitude'] = amp
-    out_dict['amplitude_error'] = damp
-    out_dict['rel_phase'] = rel_phase
-    out_dict['rel_phase_error'] = dphase
-    out_dict['time0'] = -phase[0] / (2 * np.pi * freq)
-
-    ncp = norm.cumprod()
-    out_dict['trend_coef'] = coef / ncp
-    out_dict['y_offset'] = out_dict['trend_coef'][0] - cn0
-
-    prob = stats.f.sf(0.5 * (ntime - 1. - detrend_order) * (1. -out_dict['chi2'] / out_dict['chi0']), 2, ntime - 1 - detrend_order)
-    out_dict['signif'] = lprob2sigma(np.log(prob))
-
-    return out_dict
-
-
-def get_lomb_frequency(lomb_model, i):
-    """Get the ith frequency from a fitted Lomb-Scargle model."""
-    return lomb_model['freq_fits'][i-1]['freq']
-
-
-def get_lomb_amplitude(lomb_model, i, j):
-    """
-    Get the amplitude of the jth harmonic of the ith frequency from a fitted
-    Lomb-Scargle model.
-    """
-    return lomb_model['freq_fits'][i-1]['amplitude'][j-1]
-
-
-def get_lomb_rel_phase(lomb_model, i, j):
-    """
-    Get the relative phase of the jth harmonic of the ith frequency from a
-    fitted Lomb-Scargle model.
-    """
-    return lomb_model['freq_fits'][i-1]['rel_phase'][j-1]
-
-
-def get_lomb_amplitude_ratio(lomb_model, i):
-    """
-    Get the ratio of the amplitudes of the first harmonic for the ith and first
-    frequencies from a fitted Lomb-Scargle model.
-    """
-    return (lomb_model['freq_fits'][i-1]['amplitude'][0] /
-            lomb_model['freq_fits'][0]['amplitude'][0])
-
-
-def get_lomb_frequency_ratio(lomb_model, i):
-    """
-    Get the ratio of the ith and first frequencies from a fitted Lomb-Scargle
-    model.
-    """
-    return (lomb_model['freq_fits'][i-1]['freq'] /
-            lomb_model['freq_fits'][0]['freq'])
-
-
-def get_lomb_signif_ratio(lomb_model, i):
-    """
-    Get the ratio of the significances (in sigmas) of the ith and first
-    frequencies from a fitted Lomb-Scargle model.
-    """
-    return (lomb_model['freq_fits'][i-1]['signif'] /
-            lomb_model['freq_fits'][0]['signif'])
-
-
-def get_lomb_lambda(lomb_model):
-    """Get the regularization parameter of a fitted Lomb-Scargle model."""
-    return lomb_model['freq_fits'][0]['lambda']
-
-
-def get_lomb_signif(lomb_model):
-    """
-    Get the significance (in sigmas) of the first frequency from a fitted
-    Lomb-Scargle model.
-    """
-    return lomb_model['freq_fits'][0]['signif']
-
-
-def get_lomb_varrat(lomb_model):
-    """
-    Get the fraction of the variance explained by the first frequency of a
-    fitted Lomb-Scargle model.
-    """
-    return lomb_model['varrat']
-
-
-def get_lomb_trend(lomb_model):
-    """Get the linear trend of a fitted Lomb-Scargle model."""
-    return lomb_model['trend']
-
-
-def get_lomb_y_offset(lomb_model):
-    """Get the y-intercept of a fitted Lomb-Scargle model."""
-    return lomb_model['freq_fits'][0]['y_offset']
+import numpy as np
+import scipy.stats as stats
+from ._lomb_scargle import lomb_scargle
+
+
+def lomb_scargle_model(time, signal, error, sys_err=0.05, nharm=8, nfreq=3, tone_control=5.0):
+    """Simultaneous fit of a sum of sinusoids by weighted least squares:
+           y(t) = Sum_k Ck*t^k + Sum_i Sum_j A_ij sin(2*pi*j*fi*(t-t0)+phi_j),
+           i=[1,nfreq], j=[1,nharm]
+
+    Parameters
+    ----------
+    time : array_like
+        Array containing time values.
+
+    signal : array_like
+        Array containing data values.
+
+    error : array_like
+        Array containing measurement error values.
+
+    nharm : int
+        Number of harmonics to fit for each frequency.
+
+    nfreq : int
+        Number of frequencies to fit.
+
+    Returns
+    -------
+    dict
+        Dictionary containing fitted parameter values. Parameters specific to
+        a specific fitted frequency are stored in a list of dicts at
+        model_dict['freq_fits'], each of which contains the output of
+        fit_lomb_scargle(...)
+
+    """
+
+    dy0 = np.sqrt(error**2 + sys_err**2)
+
+    wt = 1. / dy0**2
+    time = time.copy() - min(time) # speeds up lomb_scargle code to have min(time)==0
+    signal = signal.copy()
+
+    chi0 = np.dot(signal**2, wt)
+
+# TODO parametrize?
+    f0 = 1. / max(time)
+    df = 0.8 / max(time) # 20120202 :    0.1/Xmax
+    fmax = 33. #pre 20120126: 10. # 25
+    numf = int((fmax - f0) / df) # TODO !!! this is off by 1 point, fix?
+
+    model_dict = {'freq_fits' : []}
+    lambda0_range = [-np.log10(len(time)), 8] # these numbers "fix" the strange-amplitude effect
+    for i in range(nfreq):
+        if i == 0:
+            fit = fit_lomb_scargle(time, signal, dy0, f0, df, numf,
+                    tone_control=tone_control, lambda0_range=lambda0_range,
+                    nharm=nharm, detrend_order=1)
+            model_dict['trend'] = fit['trend_coef'][1]
+        else:
+            fit = fit_lomb_scargle(time, signal, dy0, f0, df, numf,
+                    tone_control=tone_control, lambda0_range=lambda0_range,
+                    nharm=nharm, detrend_order=0)
+        model_dict['freq_fits'].append(fit)
+        signal -= fit['model']
+        model_dict['freq_fits'][-1]['resid'] = signal.copy()
+        if i == 0:
+            model_dict['varrat'] = np.dot(signal**2, wt) / chi0
+
+    model_dict['nfreq'] = nfreq
+    model_dict['nharm'] = nharm
+    model_dict['chi2'] = fit['chi2']
+    model_dict['f0'] = f0
+    model_dict['df'] = df
+    model_dict['numf'] = numf
+
+    return model_dict
+
+
+def lprob2sigma(lprob):
+    """Translate a log_e(probability) to units of Gaussian sigmas."""
+    if lprob > -36.:
+        sigma = stats.norm.ppf(1. - 0.5 * np.exp(lprob))
+    else:
+        sigma = np.sqrt(np.log(2. / np.pi) - 2. * np.log(8.2) - 2. * lprob)
+        f = 0.5 * np.log(2. / np.pi) - 0.5 * sigma**2 - np.log(sigma) - lprob
+        sigma += f / (sigma + 1. / sigma)
+    return sigma
+
+
+def fit_lomb_scargle(time, signal, error, f0, df, numf, nharm=8, psdmin=6., detrend_order=0,
+         freq_zoom=10., tone_control=5., lambda0=1., lambda0_range=[-8,6]):
+    """Calls C implementation of Lomb Scargle sinusoid fitting, which fits a
+    single frequency with nharm harmonics to the data. Called repeatedly by
+    lomb_scargle_model in order to produce a fit with multiple distinct
+    frequencies.
+
+    Inputs:
+    time : array_like
+        Array containing time values.
+
+    signal : array_like
+        Array containing data values.
+
+    error : array_like
+        Array containing measurement error values.
+
+    f0 : float
+        Smallest frequency value to consider.
+
+    df : float
+        Step size for frequency grid search.
+
+    numf : int
+        Number of frequencies for frequency grid search.
+
+    nharm : int
+        Number of harmonics to fit.
+
+    detrend_order : int
+        Order of polynomial detrending.
+
+    psdmin : int
+        Refine periodogram values with larger psd using multi-harmonic fit
+
+    nharm : int
+        Number of harmonics to use in refinement
+
+    lambda0 : float
+        Typical value for regularization parameter
+
+    lambda0_range : [float, float]
+        Allowable range for log10 of regularization parameter
+
+    Returns
+    -------
+    dict
+        Dictionary describing various parameters of the multiharmonic fit at
+        the best-fit frequency
+    """
+    ntime = len(time)
+
+# For some reason we round this to the nearest even integer
+    freq_zoom = round(freq_zoom/2.)*2.
+
+# Polynomial terms
+    coef = np.zeros(detrend_order + 1, dtype='float64')
+    norm = np.zeros(detrend_order + 1, dtype='float64')
+
+    wth0 = 1. / error
+    s0 = np.dot(wth0, wth0)
+    wth0 /= np.sqrt(s0)
+
+    cn = signal * wth0
+    coef[0] = np.dot(cn,wth0)
+    cn0 = coef[0]
+    norm[0] = 1.
+    cn -= coef[0] * wth0
+    vcn = 1.
+
+    # np.sin's and cosin's for later
+    tt = 2. * np.pi * time
+    sinx,cosx = np.sin(tt*f0)*wth0,np.cos(tt*f0)*wth0
+    sinx_step,cosx_step = np.sin(tt*df),np.cos(tt*df)
+    sinx_back,cosx_back = -np.sin(tt*df/2.),np.cos(tt*df/2)
+    sinx_smallstep,cosx_smallstep = np.sin(tt*df/freq_zoom),np.cos(tt*df/freq_zoom)
+
+    npar = 2*nharm
+    hat_matr = np.zeros((npar,ntime),dtype='float64')
+    hat0 = np.zeros((npar,detrend_order+1),dtype='float64')
+    hat_hat = np.zeros((npar,npar),dtype='float64')
+    soln = np.zeros(npar,dtype='float64')
+    psd = np.zeros(numf,dtype='float64')
+
+    # Detrend the data and create the orthogonal detrending basis
+    if detrend_order > 0:
+        wth = np.zeros((detrend_order + 1, ntime),dtype='float64')
+        wth[0,:] = wth0
+    else:
+        wth = wth0
+
+    for i in range(detrend_order):
+        f = wth[i,:] * tt / (2 * np.pi)
+        for j in range(i+1):
+            f -= np.dot(f, wth[j,:]) * wth[j,:]
+        norm[i+1] = np.sqrt(np.dot(f,f))
+        f /= norm[i+1]
+        coef[i+1] = np.dot(cn,f)
+        cn -= coef[i+1]*f
+        wth[i+1,:] = f
+        vcn += (f/wth0)**2
+
+    chi0 = np.dot(cn,cn)
+    varcn = chi0/(ntime-1-detrend_order)
+    psdmin *= 2*varcn
+
+    Tr = np.array(0., dtype='float64')
+    ifreq = np.array(0, dtype='int32')
+    lambda0 = np.array(lambda0 / s0, dtype='float64')
+    lambda0_range = 10**np.array(lambda0_range, dtype='float64') / s0
+
+    lomb_scargle(ntime, numf, nharm, detrend_order, psd, cn, wth, sinx, cosx,
+            sinx_step, cosx_step, sinx_back, cosx_back, sinx_smallstep,
+            cosx_smallstep, hat_matr, hat_hat, hat0, soln, chi0, freq_zoom,
+            psdmin, tone_control, lambda0, lambda0_range, Tr, ifreq)
+
+    hat_hat /= s0
+    ii = np.arange(nharm, dtype='int32')
+    soln[0:nharm] /= (1. + ii)**2
+    soln[nharm:] /= (1. + ii)**2
+    hat_matr0 = np.outer(hat0[:,0], wth0)
+    for i in range(detrend_order):
+        hat_matr0 += np.outer(hat0[:,i+1], wth[i+1,:])
+
+    modl = np.dot(hat_matr.T, soln)
+    coef0 = np.dot(soln, hat0)
+    coef -= coef0
+    hat_matr -= hat_matr0
+
+    out_dict = {}
+    out_dict['psd'] = psd
+    out_dict['chi0'] = chi0 * s0
+    if detrend_order > 0:
+        out_dict['trend'] = np.dot(coef,wth)/wth0
+    else:
+        out_dict['trend'] = coef[0] + 0*wth0
+    out_dict['model'] = modl/wth0 + out_dict['trend']
+
+    j = psd.argmax()
+    freq = f0 + df * j + (ifreq / freq_zoom - 1/2.) * df
+    tt = (time * freq) % 1.
+    out_dict['freq'] = freq
+    out_dict['s0'] = s0
+    out_dict['chi2'] = (chi0 - psd[j]) * s0
+    out_dict['psd'] = psd[j] * 0.5 / varcn
+    out_dict['lambda'] = lambda0 * s0
+#    out_dict['gcv_weight'] = (1 - 3. / ntime) / Tr
+    out_dict['trace'] = Tr
+    out_dict['nu0'] = ntime - npar
+    npars = (1 - Tr) * ntime / 2.
+    out_dict['nu'] = ntime - npars
+    out_dict['npars'] = npars
+
+    A0, B0 = soln[0:nharm], soln[nharm:]
+    hat_hat /= np.outer(np.hstack(((1.+ii)**2, (1.+ii)**2)), np.hstack(((1.+ii)**2, (1.+ii)**2)))
+    err2 = np.diag(hat_hat)
+    vA0, vB0 = err2[0:nharm], err2[nharm:]
+    covA0B0 = hat_hat[(ii,nharm+ii)]
+
+    vmodl = vcn/s0 + np.dot((hat_matr/wth0).T, np.dot(hat_hat, hat_matr/wth0))
+    vmodl0 = vcn/s0 + np.dot((hat_matr0/wth0).T, np.dot(hat_hat, hat_matr0/wth0))
+    out_dict['model_error'] = np.sqrt(np.diag(vmodl))
+    out_dict['trend_error'] = np.sqrt(np.diag(vmodl0))
+
+    amp = np.sqrt(A0**2 + B0**2)
+    damp = np.sqrt(A0**2 * vA0 + B0**2 * vB0 + 2. * A0 * B0 * covA0B0) / amp
+    phase = np.arctan2(B0, A0)
+    rel_phase = phase - phase[0]*(1.+ii)
+    rel_phase = np.arctan2(np.sin(rel_phase), np.cos(rel_phase))
+    dphase = 0.*rel_phase
+    for i in range(nharm - 1):
+        j = i + 1
+        v = np.array([-A0[0] * (1. + j) / amp[0]**2, B0[0] * (1. + j) / amp[0]**2, A0[j] / amp[j]**2, -B0[j] / amp[j]**2])
+        jj = np.array([0, nharm, j, j+nharm])
+        m = hat_hat[np.ix_(jj, jj)]
+        dphase[j] = np.sqrt(np.dot(np.dot(v, m), v))
+
+    out_dict['amplitude'] = amp
+    out_dict['amplitude_error'] = damp
+    out_dict['rel_phase'] = rel_phase
+    out_dict['rel_phase_error'] = dphase
+    out_dict['time0'] = -phase[0] / (2 * np.pi * freq)
+
+    ncp = norm.cumprod()
+    out_dict['trend_coef'] = coef / ncp
+    out_dict['y_offset'] = out_dict['trend_coef'][0] - cn0
+
+    prob = stats.f.sf(0.5 * (ntime - 1. - detrend_order) * (1. -out_dict['chi2'] / out_dict['chi0']), 2, ntime - 1 - detrend_order)
+    out_dict['signif'] = lprob2sigma(np.log(prob))
+
+    return out_dict
+
+
+def get_lomb_frequency(lomb_model, i):
+    """Get the ith frequency from a fitted Lomb-Scargle model."""
+    return lomb_model['freq_fits'][i-1]['freq']
+
+
+def get_lomb_amplitude(lomb_model, i, j):
+    """
+    Get the amplitude of the jth harmonic of the ith frequency from a fitted
+    Lomb-Scargle model.
+    """
+    return lomb_model['freq_fits'][i-1]['amplitude'][j-1]
+
+
+def get_lomb_rel_phase(lomb_model, i, j):
+    """
+    Get the relative phase of the jth harmonic of the ith frequency from a
+    fitted Lomb-Scargle model.
+    """
+    return lomb_model['freq_fits'][i-1]['rel_phase'][j-1]
+
+
+def get_lomb_amplitude_ratio(lomb_model, i):
+    """
+    Get the ratio of the amplitudes of the first harmonic for the ith and first
+    frequencies from a fitted Lomb-Scargle model.
+    """
+    return (lomb_model['freq_fits'][i-1]['amplitude'][0] /
+            lomb_model['freq_fits'][0]['amplitude'][0])
+
+
+def get_lomb_frequency_ratio(lomb_model, i):
+    """
+    Get the ratio of the ith and first frequencies from a fitted Lomb-Scargle
+    model.
+    """
+    return (lomb_model['freq_fits'][i-1]['freq'] /
+            lomb_model['freq_fits'][0]['freq'])
+
+
+def get_lomb_signif_ratio(lomb_model, i):
+    """
+    Get the ratio of the significances (in sigmas) of the ith and first
+    frequencies from a fitted Lomb-Scargle model.
+    """
+    return (lomb_model['freq_fits'][i-1]['signif'] /
+            lomb_model['freq_fits'][0]['signif'])
+
+
+def get_lomb_lambda(lomb_model):
+    """Get the regularization parameter of a fitted Lomb-Scargle model."""
+    return lomb_model['freq_fits'][0]['lambda']
+
+
+def get_lomb_signif(lomb_model):
+    """
+    Get the significance (in sigmas) of the first frequency from a fitted
+    Lomb-Scargle model.
+    """
+    return lomb_model['freq_fits'][0]['signif']
+
+
+def get_lomb_varrat(lomb_model):
+    """
+    Get the fraction of the variance explained by the first frequency of a
+    fitted Lomb-Scargle model.
+    """
+    return lomb_model['varrat']
+
+
+def get_lomb_trend(lomb_model):
+    """Get the linear trend of a fitted Lomb-Scargle model."""
+    return lomb_model['trend']
+
+
+def get_lomb_y_offset(lomb_model):
+    """Get the y-intercept of a fitted Lomb-Scargle model."""
+    return lomb_model['freq_fits'][0]['y_offset']
```

### Comparing `cesium-0.9.7/cesium/features/lomb_scargle_fast.py` & `cesium-0.9.9/cesium/features/lomb_scargle_fast.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-import numpy as np
-import gatspy
-
-
-def lomb_scargle_fast_period(t, m, e):
-    """Fits a simple sinuosidal model
-
-        y(t) = A sin(2*pi*w*t + phi) + c
-
-    and returns the estimated period 1/w. Much faster than fitting the
-    full multi-frequency model used by `features.lomb_scargle`.
-    """
-    dt = t.max() - t.min()
-    opt_args = {'period_range': (2 * dt / len(t), dt), 'quiet': True}
-    model = gatspy.periodic.LombScargleFast(fit_period=True,
-                                            optimizer_kwds=opt_args,
-                                            silence_warnings=True)
-    model.fit(t, m, e)
-    return model.best_period
+import numpy as np
+import gatspy
+
+
+def lomb_scargle_fast_period(t, m, e):
+    """Fits a simple sinuosidal model
+
+        y(t) = A sin(2*pi*w*t + phi) + c
+
+    and returns the estimated period 1/w. Much faster than fitting the
+    full multi-frequency model used by `features.lomb_scargle`.
+    """
+    dt = t.max() - t.min()
+    opt_args = {'period_range': (2 * dt / len(t), dt), 'quiet': True}
+    model = gatspy.periodic.LombScargleFast(fit_period=True,
+                                            optimizer_kwds=opt_args,
+                                            silence_warnings=True)
+    model.fit(t, m, e)
+    return model.best_period
```

### Comparing `cesium-0.9.7/cesium/datasets/tests/test_datasets.py` & `cesium-0.9.9/cesium/datasets/tests/test_datasets.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,101 +1,101 @@
-import os
-import shutil
-import tarfile
-from zipfile import ZipFile
-
-import numpy as np
-import numpy.testing as npt
-import pandas as pd
-from sklearn.datasets.base import Bunch
-
-from cesium.datasets import andrzejak
-from cesium.datasets import asas_training
-import cesium.datasets.util as dsutil
-
-try:
-    from cStringIO import StringIO
-except:
-    from io import BytesIO as StringIO
-try:
-    import mock
-except:
-    import unittest.mock as mock
-
-
-def urlpatch(*args):
-    try:
-        import urllib.request
-        return mock.patch('urllib.request.urlopen', side_effect=args[0])
-    except:
-        import urllib2
-        return mock.patch('urllib2.urlopen', side_effect=args[0])
-
-
-class MockZipUrl(object):
-    def __init__(self, url, num_columns=1):
-        self.url = url
-        self.num_columns = num_columns
-
-    def read(self):
-        out_buffer = StringIO()
-        fname = os.path.basename(self.url)
-        prefix = fname[0]
-        if fname.endswith('.dat'):
-            header = 'filename,class,meta1\n{}001,{},1.0\n'.format(prefix, prefix)
-            out_buffer.write(header.encode('utf-8'))
-        else:
-            X = np.random.random((10, self.num_columns))
-            text = '\n'.join(','.join(row) for row in X.astype('str'))
-            if fname.endswith('.zip'):
-                with ZipFile(out_buffer, 'w') as z:
-                    z.writestr('{}001.txt'.format(prefix), text)
-            elif fname.endswith('.tar.gz'):
-                with tarfile.open(fileobj=out_buffer, mode='w:gz') as t:
-                    tarinfo = tarfile.TarInfo('{}001.txt'.format(prefix))
-                    tarinfo.size = len(text)
-                    t.addfile(tarinfo, StringIO(text.encode('utf-8')))
-        return out_buffer.getvalue()
-
-
-def _mock_andrzejak_url(*args):
-    return MockZipUrl(url=args[0], num_columns=1)
-
-
-@urlpatch(_mock_andrzejak_url)
-def test_fetch_andrzejak(self, tmpdir):
-    """Test EEG data download."""
-    num_files = len(andrzejak.ZIP_FILES)
-    andrzejak.MD5SUMS = None
-    data = andrzejak.fetch_andrzejak(str(tmpdir))
-    assert(data['archive'].endswith('andrzejak.tar.gz')
-           and os.path.exists(data['archive']))
-    header = pd.read_csv(data['header'])
-    npt.assert_array_equal(header['class'], data['classes'])
-    assert(all(len(t) == len(m)
-               for t, m in zip(data['times'], data['measurements'])))
-    assert(len(data['times']) == num_files)
-    assert(len(data['classes']) == num_files)
-    assert(all(c in ['Z', 'N', 'O', 'S', 'F'] for c in data['classes']))
-
-
-def _mock_asas_training_url(*args):
-    return MockZipUrl(url=args[0], num_columns=3)
-
-
-@urlpatch(_mock_asas_training_url)
-def test_fetch_asas_training(self, tmpdir):
-    """Test ASAS training data download."""
-    num_files = 1
-    asas_training.MD5SUMS = None
-    data = asas_training.fetch_asas_training(str(tmpdir))
-    assert(data['archive'].endswith('asas_training_set.tar.gz')
-           and os.path.exists(data['archive']))
-    header = pd.read_csv(data['header'])
-    npt.assert_array_equal(header['class'], data['classes'])
-    assert(all(len(t) == len(m) and len(m) == len(e)
-               for t, m, e in zip(data['times'], data['measurements'],
-                                  data['errors'])))
-    assert(len(data['times']) == num_files)
-    assert(len(data['classes']) == num_files)
-    assert(len(data['metadata']) == num_files)
-    assert(all(c in ['a'] for c in data['classes']))
+import os
+import shutil
+import tarfile
+from zipfile import ZipFile
+
+import numpy as np
+import numpy.testing as npt
+import pandas as pd
+from sklearn.datasets.base import Bunch
+
+from cesium.datasets import andrzejak
+from cesium.datasets import asas_training
+import cesium.datasets.util as dsutil
+
+try:
+    from cStringIO import StringIO
+except:
+    from io import BytesIO as StringIO
+try:
+    import mock
+except:
+    import unittest.mock as mock
+
+
+def urlpatch(*args):
+    try:
+        import urllib.request
+        return mock.patch('urllib.request.urlopen', side_effect=args[0])
+    except:
+        import urllib2
+        return mock.patch('urllib2.urlopen', side_effect=args[0])
+
+
+class MockZipUrl(object):
+    def __init__(self, url, num_columns=1):
+        self.url = url
+        self.num_columns = num_columns
+
+    def read(self):
+        out_buffer = StringIO()
+        fname = os.path.basename(self.url)
+        prefix = fname[0]
+        if fname.endswith('.dat'):
+            header = 'filename,class,meta1\n{}001,{},1.0\n'.format(prefix, prefix)
+            out_buffer.write(header.encode('utf-8'))
+        else:
+            X = np.random.random((10, self.num_columns))
+            text = '\n'.join(','.join(row) for row in X.astype('str'))
+            if fname.endswith('.zip'):
+                with ZipFile(out_buffer, 'w') as z:
+                    z.writestr('{}001.txt'.format(prefix), text)
+            elif fname.endswith('.tar.gz'):
+                with tarfile.open(fileobj=out_buffer, mode='w:gz') as t:
+                    tarinfo = tarfile.TarInfo('{}001.txt'.format(prefix))
+                    tarinfo.size = len(text)
+                    t.addfile(tarinfo, StringIO(text.encode('utf-8')))
+        return out_buffer.getvalue()
+
+
+def _mock_andrzejak_url(*args):
+    return MockZipUrl(url=args[0], num_columns=1)
+
+
+@urlpatch(_mock_andrzejak_url)
+def test_fetch_andrzejak(self, tmpdir):
+    """Test EEG data download."""
+    num_files = len(andrzejak.ZIP_FILES)
+    andrzejak.MD5SUMS = None
+    data = andrzejak.fetch_andrzejak(str(tmpdir))
+    assert(data['archive'].endswith('andrzejak.tar.gz')
+           and os.path.exists(data['archive']))
+    header = pd.read_csv(data['header'])
+    npt.assert_array_equal(header['class'], data['classes'])
+    assert(all(len(t) == len(m)
+               for t, m in zip(data['times'], data['measurements'])))
+    assert(len(data['times']) == num_files)
+    assert(len(data['classes']) == num_files)
+    assert(all(c in ['Z', 'N', 'O', 'S', 'F'] for c in data['classes']))
+
+
+def _mock_asas_training_url(*args):
+    return MockZipUrl(url=args[0], num_columns=3)
+
+
+@urlpatch(_mock_asas_training_url)
+def test_fetch_asas_training(self, tmpdir):
+    """Test ASAS training data download."""
+    num_files = 1
+    asas_training.MD5SUMS = None
+    data = asas_training.fetch_asas_training(str(tmpdir))
+    assert(data['archive'].endswith('asas_training_set.tar.gz')
+           and os.path.exists(data['archive']))
+    header = pd.read_csv(data['header'])
+    npt.assert_array_equal(header['class'], data['classes'])
+    assert(all(len(t) == len(m) and len(m) == len(e)
+               for t, m, e in zip(data['times'], data['measurements'],
+                                  data['errors'])))
+    assert(len(data['times']) == num_files)
+    assert(len(data['classes']) == num_files)
+    assert(len(data['metadata']) == num_files)
+    assert(all(c in ['a'] for c in data['classes']))
```

### Comparing `cesium-0.9.7/cesium/datasets/util.py` & `cesium-0.9.9/cesium/datasets/andrzejak.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,138 +1,122 @@
-import hashlib
-import os
-import tarfile
-
-import pandas as pd
-
-from .. import util
-
-try:
-    import urllib.request as request
-except:
-    import urllib2 as request
-
-
-DATA_PATH = os.path.expanduser('~/.local/')
-
-
-def _md5sum_file(path):
-    """Calculate the MD5 sum of a file."""
-    with open(path, 'rb') as f:
-        m = hashlib.md5()
-        while True:
-            data = f.read(8192)
-            if not data:
-                break
-            m.update(data)
-    return m.hexdigest()
-
-
-def download_file(data_dir, base_url, filename):
-    """Download a single file into the given directory.
-
-    Parameters
-    ----------
-    data_dir : str
-        Path to directory in which to save file.
-    base_url : str
-        URL of file to download, minus the file name.
-    filename : str
-        Name of file to be downloaded.
-
-    Returns
-    -------
-    str
-        The path to the newly downloaded file.
-    """
-    if not os.path.exists(data_dir):
-        os.makedirs(data_dir)
-
-    file_path = os.path.join(data_dir, filename)
-    opener = request.urlopen(base_url + filename)
-    with open(file_path, 'wb') as f:
-        f.write(opener.read())
-    return file_path
-
-
-def download_and_extract_archives(data_dir, base_url, filenames, md5sums=None,
-                                 remove_archive=True):
-    """Download list of data archives, verify md5 checksums (if applicable),
-    and extract into the given directory.
-
-    Parameters
-    ----------
-    data_dir : str
-        Path to directory in which to download and extract archives.
-    base_url : str
-        URL of files to download, minus the file names.
-    filenames : list or tuple of str
-        Name of file to be downloaded.
-    md5sums : dict, optional
-        Dictionary whose keys are file names and values are
-        corresponding hexadecimal md5 checksums to be checked against.
-    remove_archive : bool, optional
-        Boolean indicating whether to delete the archive(s) from disk
-        after the contents have been extracted. Defaults to True.
-
-    Returns
-    -------
-    list of str
-        The paths to the newly downloaded and unzipped files.
-    """
-    if not os.path.exists(data_dir):
-        os.makedirs(data_dir)
-
-    all_file_paths = []
-    for fname in filenames:
-        archive_path = os.path.join(data_dir, fname)
-        opener = request.urlopen(base_url + fname)
-        with open(archive_path, 'wb') as f:
-            f.write(opener.read())
-        if md5sums:
-            if _md5sum_file(archive_path) != md5sums[fname]:
-                raise ValueError("File {} checksum verification has failed."
-                                 " Dataset fetching aborted.".format(fname))
-        with util.extract_time_series(archive_path,
-                                      cleanup_archive=remove_archive,
-                                      extract_dir=data_dir) as file_paths:
-            all_file_paths.extend(file_paths)
-    return all_file_paths
-
-
-def build_time_series_archive(archive_path, ts_paths):
-    """Write a .tar.gz archive containing the given time series files, as
-    required for data uploaded via the front end.
-
-    Parameters
-    ----------
-    archive_path : str
-        Path at which to create the tarfile.
-    ts_paths : list of str
-        Paths to time-series file to be included in tarfile.
-    """
-    with tarfile.TarFile(archive_path, 'w') as t:
-        for fname in ts_paths:
-            t.add(fname, arcname=os.path.basename(fname))
-
-
-def write_header(header_path, filenames, classes, metadata={}):
-    """Write a header file for the given time series files, as required for
-    data uploaded via the front end.
-
-    Parameters
-    ----------
-    header_path : str
-        Path at which header file will be created.
-    filenames : list of str
-        List of time-series file names associated with header file.
-    classes : list of str
-        List of class names associated with each time-series file.
-    metadata : dict, optional
-        Dictionary describing meta features associated with each time-series.
-        Keys are time-series file names.
-    """
-    data_dict = {'filename': [util.shorten_fname(f) for f in filenames],
-                 'class': classes}
-    data_dict.update(metadata)
-    df = pd.DataFrame(data_dict)
-    df.to_csv(header_path, index=False)
+import logging
+import os
+
+import numpy as np
+from sklearn.externals import joblib
+
+from .. import util
+from . import util as dsutil
+
+
+BASE_URL = "https://github.com/cesium-ml/cesium-data/raw/master/andrzejak/"
+ZIP_FILES = ["Z.zip", "O.zip", "N.zip", "F.zip", "S.zip"]
+MD5SUMS = {
+    "Z.zip": "ca5c761d62704c4d2465822e2131f868",
+    "O.zip": "666ade7e9d519935103404d4a8d81d7d",
+    "N.zip": "0bb8e39ae7530ba17f55b5b4f14e6a02",
+    "F.zip": "10f78c004122c609e8eef74de8790af3",
+    "S.zip": "1d560ac1e03a5c19bb7f336e270ff286"
+}
+CACHE_NAME = "andrzejak.pkl"
+ARCHIVE_NAME = "andrzejak.tar.gz"
+T_MAX = 23.6
+
+logger = logging.getLogger(__name__)
+
+
+def download_andrzejak(data_dir):
+    """Download sample EEG data.
+
+    Three files are created within `data_dir`:
+        - andrzejak.tar.gz (containing .dat files for each time series)
+        - andrzejak.csv (header file containing class labels)
+        - andrzejak.pkl (cached data for faster loading from disk)
+
+    Parameters
+    ----------
+    data_dir : str
+        Path where downloaded data should be stored.
+
+    Returns
+    -------
+    dict
+        Dictionary with attributes:
+            - times: list of (4096,) arrays of time values
+            - measurements: list of (4096,) arrays of measurement values
+            - classes: array of class labels for each time series
+            - archive: path to data archive
+            - header: path to header file
+    """
+    logger.warning("Downloading data from {}".format(BASE_URL))
+
+    ts_paths = dsutil.download_and_extract_archives(data_dir, BASE_URL,
+                                                    ZIP_FILES, MD5SUMS)
+
+    # Reformat time series files and add to `andrzejak.tar.gz` archive
+    times = []
+    measurements = []
+    new_ts_paths = []
+    classes = []
+    for fname in ts_paths:
+        m = np.loadtxt(fname)
+        t = np.linspace(start=0, stop=T_MAX, num=len(m))
+        new_fname = fname[:-4] + '.dat'
+        np.savetxt(new_fname, np.vstack((t, m)).T, delimiter=',')
+        measurements.append(m)
+        times.append(t)
+        new_ts_paths.append(new_fname)
+        classes.append(os.path.basename(new_fname)[0])  # 'Z001.txt' -> 'Z'
+    archive_path = os.path.join(data_dir, ARCHIVE_NAME)
+    dsutil.build_time_series_archive(archive_path, new_ts_paths)
+
+    header_path = os.path.join(data_dir, "andrzejak.csv")
+    dsutil.write_header(header_path, new_ts_paths, classes)
+
+    extract_dir = os.path.join(data_dir, os.path.basename(ARCHIVE_NAME))
+    util.remove_files(ts_paths + new_ts_paths)
+
+    cache_path = os.path.join(data_dir, CACHE_NAME)
+    data = dict(times=times, measurements=measurements,
+                classes=np.array(classes), archive=archive_path,
+                header=header_path)
+    joblib.dump(data, cache_path, compress=3)
+    return data
+
+
+def fetch_andrzejak(data_dir=None):
+    """Download (if not already downloaded) and load an example EEG dataset.
+
+    Parameters
+    ----------
+    data_dir : str, optional
+        Path where downloaded data should be stored. Defaults to a subdirectory
+        `datasets/andrzejak` within `dsutil.DATA_PATH`.
+
+    Returns
+    -------
+    dict
+        Dictionary with attributes:
+            - times: list of (4096,) arrays of time values
+            - measurements: list of (4096,) arrays of measurement values
+            - classes: array of class labels for each time series
+            - archive: path to data archive
+            - header: path to header file
+
+    References
+    ----------
+    Andrzejak, Ralph G., et al. "Indications of nonlinear deterministic and
+    finite-dimensional structures in time series of brain electrical activity:
+    Dependence on recording region and brain state." *Phys. Rev. E* 64.6
+    (2001): 061907.
+    """
+
+    if data_dir is None:
+        data_dir = os.path.join(dsutil.DATA_PATH, "datasets/andrzejak")
+    cache_path = os.path.join(data_dir, CACHE_NAME)
+
+    try:
+        data = joblib.load(cache_path)
+        logger.warning("Loaded data from cached archive.")
+    except (ValueError, IOError): #  missing or incompatible cache
+        data = download_andrzejak(data_dir)
+    return data
```

### Comparing `cesium-0.9.7/cesium/tests/test_util.py` & `cesium-0.9.9/cesium/tests/test_util.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-import os
-from cesium import util
-import numpy.testing as npt
-
-
-def test_shorten_fname():
-    """Test util.shorten_fname"""
-    npt.assert_equal(util.shorten_fname("/a/b/c/name.ext"), "name")
-    npt.assert_equal(util.shorten_fname("path/to/fname.name2.ext2"),
-                     "fname.name2")
-    npt.assert_equal(util.shorten_fname("fname.ext"), "fname")
-    npt.assert_equal(util.shorten_fname("fname"), "fname")
-
-
-def test_remove_files(tmpdir):
-    """Test util.remove_files"""
-    # Pass in single path (non-list)
-    fpath = os.path.join(str(tmpdir), "cesium.test")
-    f = open(fpath, "w").close()
-    assert os.path.exists(fpath)
-    util.remove_files(fpath)
-    assert not os.path.exists(fpath)
-
-    # Pass in list of paths
-    f = open(fpath, "w").close()
-    assert os.path.exists(fpath)
-    util.remove_files([fpath])
-    assert not os.path.exists(fpath)
-
-    # File does not exist, should not raise exception
-    util.remove_files(fpath)
+import os
+from cesium import util
+import numpy.testing as npt
+
+
+def test_shorten_fname():
+    """Test util.shorten_fname"""
+    npt.assert_equal(util.shorten_fname("/a/b/c/name.ext"), "name")
+    npt.assert_equal(util.shorten_fname("path/to/fname.name2.ext2"),
+                     "fname.name2")
+    npt.assert_equal(util.shorten_fname("fname.ext"), "fname")
+    npt.assert_equal(util.shorten_fname("fname"), "fname")
+
+
+def test_remove_files(tmpdir):
+    """Test util.remove_files"""
+    # Pass in single path (non-list)
+    fpath = os.path.join(str(tmpdir), "cesium.test")
+    f = open(fpath, "w").close()
+    assert os.path.exists(fpath)
+    util.remove_files(fpath)
+    assert not os.path.exists(fpath)
+
+    # Pass in list of paths
+    f = open(fpath, "w").close()
+    assert os.path.exists(fpath)
+    util.remove_files([fpath])
+    assert not os.path.exists(fpath)
+
+    # File does not exist, should not raise exception
+    util.remove_files(fpath)
```

### Comparing `cesium-0.9.7/cesium/tests/fixtures.py` & `cesium-0.9.9/cesium/tests/fixtures.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-import shutil
-import tempfile
-import uuid
-from contextlib import contextmanager
-from itertools import cycle, islice
-from os.path import join as pjoin
-import numpy as np
-import pandas as pd
-
-from cesium.time_series import TimeSeries
-
-
-def sample_values(size=51, channels=1):
-    times = np.sort(np.random.random(size))
-    values = np.array([np.random.normal(size=size) for i in range(channels)])
-    errors = np.array([np.random.exponential(size=size)
-                       for i in range(channels)])
-    if channels == 1:
-        values = values[0]
-        errors = errors[0]
-    return times, values, errors
-
-
-@contextmanager
-def sample_ts_files(size, labels=[None]):
-    temp_dir = tempfile.mkdtemp()
-    paths = []
-    for label in islice(cycle(labels), size):
-        t, m, e = sample_values()
-        name = str(uuid.uuid4())
-        path = pjoin(temp_dir, '{}.npz'.format(name))
-        ts = TimeSeries(t, m, e, label=label, path=path, name=name)
-        ts.save(path)
-        paths.append(path)
-
-    yield paths
-
-    shutil.rmtree(temp_dir)
-
-
-def sample_featureset(size, n_channels=1, features=['mean'], labels=None,
-                      names=None, meta_features=[]):
-    ts_names = np.arange(size).astype('str')
-    columns = pd.MultiIndex.from_tuples([(f, i) for f in features
-                                         for i in range(n_channels)],
-                                        names=['feature', 'channel'])
-    fset = pd.DataFrame(np.random.random((size, len(features) * n_channels)),
-                        columns=columns)
-    if labels:
-        labels = np.array(list(islice(cycle(labels), size)))
-    if names:
-        fset.index = names
-    for feat in meta_features:
-        fset[feat] = np.random.random(size)
-
-    return fset, labels
+import shutil
+import tempfile
+import uuid
+from contextlib import contextmanager
+from itertools import cycle, islice
+from os.path import join as pjoin
+import numpy as np
+import pandas as pd
+
+from cesium.time_series import TimeSeries
+
+
+def sample_values(size=51, channels=1):
+    times = np.sort(np.random.random(size))
+    values = np.array([np.random.normal(size=size) for i in range(channels)])
+    errors = np.array([np.random.exponential(size=size)
+                       for i in range(channels)])
+    if channels == 1:
+        values = values[0]
+        errors = errors[0]
+    return times, values, errors
+
+
+@contextmanager
+def sample_ts_files(size, labels=[None]):
+    temp_dir = tempfile.mkdtemp()
+    paths = []
+    for label in islice(cycle(labels), size):
+        t, m, e = sample_values()
+        name = str(uuid.uuid4())
+        path = pjoin(temp_dir, '{}.npz'.format(name))
+        ts = TimeSeries(t, m, e, label=label, path=path, name=name)
+        ts.save(path)
+        paths.append(path)
+
+    yield paths
+
+    shutil.rmtree(temp_dir)
+
+
+def sample_featureset(size, n_channels=1, features=['mean'], labels=None,
+                      names=None, meta_features=[]):
+    ts_names = np.arange(size).astype('str')
+    columns = pd.MultiIndex.from_tuples([(f, i) for f in features
+                                         for i in range(n_channels)],
+                                        names=['feature', 'channel'])
+    fset = pd.DataFrame(np.random.random((size, len(features) * n_channels)),
+                        columns=columns)
+    if labels:
+        labels = np.array(list(islice(cycle(labels), size)))
+    if names:
+        fset.index = names
+    for feat in meta_features:
+        fset[feat] = np.random.random(size)
+
+    return fset, labels
```

### Comparing `cesium-0.9.7/cesium/tests/data/asas_training_subset.tar.gz` & `cesium-0.9.9/cesium/tests/data/asas_training_subset.tar.gz`

 * *Files identical despite different names*

### Comparing `cesium-0.9.7/cesium/tests/data/dotastro_215153.dat` & `cesium-0.9.9/cesium/tests/data/dotastro_215153.dat`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,170 +1,170 @@
-2629.52836,9.511,0.042
-2805.93132,12.719,0.038
-2814.9028,12.695,0.038
-2840.87507,12.483,0.036
-2843.85544,12.797,0.039
-2851.9036,12.26,0.037
-2858.7859,12.017,0.032
-2875.80358,11.28,0.034
-2877.76851,11.134,0.034
-2880.74438,11.012,0.047
-2883.76435,10.81,0.033
-2885.72244,10.737,0.038
-2895.73375,10.314,0.04
-2897.73746,9.968,0.038
-2902.69841,10.118,0.038
-2905.67732,10.045,0.033
-2908.68856,10.008,0.035
-2910.72017,9.952,0.033
-2912.67879,9.948,0.035
-2915.66041,9.908,0.034
-2917.63089,9.909,0.037
-2923.65656,9.831,0.041
-2926.65262,9.782,0.035
-2928.65138,9.79,0.037
-2930.64852,9.779,0.035
-2934.63533,9.718,0.035
-2936.63595,9.656,0.056
-2939.64986,9.627,0.036
-2943.58775,9.567,0.038
-2945.58683,9.493,0.039
-2950.58475,9.286,0.04
-2952.59876,9.233,0.038
-2954.60462,9.126,0.038
-2956.60356,9.046,0.038
-2958.60234,8.947,0.051
-2965.53482,8.724,0.037
-2969.55975,8.538,0.034
-3179.93673,12.049,0.039
-3186.92905,11.927,0.043
-3190.89194,11.802,0.043
-3279.60736,8.653,0.043
-3299.56018,8.093,0.042
-3348.61344,9.583,0.054
-3348.61897,9.609,0.047
-3543.88159,9.678,0.044
-3547.87057,9.578,0.051
-3552.85137,9.412,0.044
-3562.83404,9.192,0.037
-3569.81581,9.087,0.038
-3571.81193,9.057,0.041
-3583.77362,8.814,0.043
-3592.74773,8.551,0.042
-3596.73552,8.42,0.037
-3602.69825,8.202,0.053
-3602.72875,8.213,0.047
-3602.73115,8.215,0.047
-3602.76166,8.199,0.048
-3617.68923,7.822,0.045
-3620.67678,7.821,0.05
-3624.66643,7.916,0.037
-3628.65738,7.984,0.04
-3634.63799,8.096,0.049
-3639.62616,8.219,0.039
-3642.61849,8.277,0.041
-3646.6086,8.376,0.041
-3652.58716,8.553,0.046
-3654.58752,8.608,0.046
-3657.57887,8.743,0.046
-3662.55624,8.929,0.056
-3665.55676,9.035,0.05
-3670.53595,9.235,0.037
-3674.52903,9.414,0.04
-3677.5157,9.531,0.04
-3892.92012,9.735,0.037
-3897.90905,9.683,0.054
-3900.90089,9.605,0.047
-3903.89143,9.538,0.039
-3907.88202,9.422,0.04
-3912.87059,9.294,0.039
-3981.68065,9.008,0.046
-4253.93171,8.521,0.044
-4258.92019,8.487,0.037
-4273.88102,8.329,0.045
-4283.85713,8.407,0.042
-4285.85247,8.427,0.042
-4290.83492,8.504,0.049
-4293.83233,8.523,0.042
-4296.8227,8.624,0.042
-4301.80401,8.873,0.054
-4303.80372,8.87,0.045
-4305.79442,8.893,0.038
-4307.7936,9.025,0.054
-4309.78321,9.112,0.059
-4311.7869,9.174,0.04
-4319.75605,9.462,0.035
-4330.71942,9.866,0.038
-4332.72594,9.975,0.037
-4334.71692,10.04,0.035
-4347.68766,10.476,0.045
-4350.67822,10.58,0.038
-4353.66616,10.656,0.037
-4356.65611,10.8,0.038
-4359.64771,10.846,0.037
-4362.64625,10.982,0.034
-4364.64093,11.062,0.035
-4372.61611,11.282,0.045
-4376.60823,11.471,0.037
-4379.59932,11.663,0.057
-4382.58816,11.654,0.051
-4385.57692,11.857,0.035
-4387.58184,11.925,0.035
-4389.56873,11.939,0.044
-4403.52749,12.251,0.037
-4409.5191,12.54,0.04
-4631.92369,9.777,0.039
-4640.92177,9.968,0.05
-4645.93574,10.081,0.041
-4648.91382,10.103,0.037
-4661.87572,10.458,0.04
-4664.84448,10.548,0.039
-4666.8496,10.65,0.038
-4672.86644,10.806,0.036
-4675.85983,10.929,0.036
-4679.80544,11.05,0.036
-4682.80765,11.171,0.037
-4684.80805,11.246,0.04
-4686.80145,11.298,0.039
-4690.78818,11.378,0.035
-4693.78595,11.499,0.051
-4701.79238,11.658,0.035
-4704.74575,11.771,0.039
-4707.73783,11.755,0.046
-4716.72629,11.993,0.04
-4720.71771,12.003,0.042
-4722.72674,12.426,0.044
-4728.6768,12.239,0.043
-4730.72439,12.216,0.039
-4733.76544,12.307,0.056
-4739.64942,12.358,0.036
-4744.70318,12.325,0.037
-4746.70666,12.512,0.04
-4748.7177,12.513,0.038
-4754.64412,12.263,0.056
-4756.66845,12.592,0.048
-4759.62208,12.451,0.04
-4762.60727,12.448,0.041
-4767.59675,12.177,0.041
-4774.6189,12.352,0.043
-4776.62458,12.294,0.046
-4782.57845,12.417,0.047
-4784.62777,12.208,0.049
-4797.54233,11.796,0.051
-4803.54779,11.568,0.042
-4816.54062,10.933,0.052
-4992.93716,10.443,0.056
-5014.86617,11.245,0.056
-5017.90202,11.332,0.061
-5023.87545,11.402,0.055
-5048.77738,11.992,0.054
-5063.77957,12.087,0.057
-5072.76379,11.968,0.056
-5075.73142,11.994,0.059
-5082.76421,12.056,0.057
-5084.75892,11.978,0.049
-5089.74278,11.847,0.051
-5092.68685,11.946,0.047
-5105.65881,11.414,0.06
-5122.66529,10.679,0.062
-5131.57904,10.344,0.058
-5145.57672,9.755,0.06
+2629.52836,9.511,0.042
+2805.93132,12.719,0.038
+2814.9028,12.695,0.038
+2840.87507,12.483,0.036
+2843.85544,12.797,0.039
+2851.9036,12.26,0.037
+2858.7859,12.017,0.032
+2875.80358,11.28,0.034
+2877.76851,11.134,0.034
+2880.74438,11.012,0.047
+2883.76435,10.81,0.033
+2885.72244,10.737,0.038
+2895.73375,10.314,0.04
+2897.73746,9.968,0.038
+2902.69841,10.118,0.038
+2905.67732,10.045,0.033
+2908.68856,10.008,0.035
+2910.72017,9.952,0.033
+2912.67879,9.948,0.035
+2915.66041,9.908,0.034
+2917.63089,9.909,0.037
+2923.65656,9.831,0.041
+2926.65262,9.782,0.035
+2928.65138,9.79,0.037
+2930.64852,9.779,0.035
+2934.63533,9.718,0.035
+2936.63595,9.656,0.056
+2939.64986,9.627,0.036
+2943.58775,9.567,0.038
+2945.58683,9.493,0.039
+2950.58475,9.286,0.04
+2952.59876,9.233,0.038
+2954.60462,9.126,0.038
+2956.60356,9.046,0.038
+2958.60234,8.947,0.051
+2965.53482,8.724,0.037
+2969.55975,8.538,0.034
+3179.93673,12.049,0.039
+3186.92905,11.927,0.043
+3190.89194,11.802,0.043
+3279.60736,8.653,0.043
+3299.56018,8.093,0.042
+3348.61344,9.583,0.054
+3348.61897,9.609,0.047
+3543.88159,9.678,0.044
+3547.87057,9.578,0.051
+3552.85137,9.412,0.044
+3562.83404,9.192,0.037
+3569.81581,9.087,0.038
+3571.81193,9.057,0.041
+3583.77362,8.814,0.043
+3592.74773,8.551,0.042
+3596.73552,8.42,0.037
+3602.69825,8.202,0.053
+3602.72875,8.213,0.047
+3602.73115,8.215,0.047
+3602.76166,8.199,0.048
+3617.68923,7.822,0.045
+3620.67678,7.821,0.05
+3624.66643,7.916,0.037
+3628.65738,7.984,0.04
+3634.63799,8.096,0.049
+3639.62616,8.219,0.039
+3642.61849,8.277,0.041
+3646.6086,8.376,0.041
+3652.58716,8.553,0.046
+3654.58752,8.608,0.046
+3657.57887,8.743,0.046
+3662.55624,8.929,0.056
+3665.55676,9.035,0.05
+3670.53595,9.235,0.037
+3674.52903,9.414,0.04
+3677.5157,9.531,0.04
+3892.92012,9.735,0.037
+3897.90905,9.683,0.054
+3900.90089,9.605,0.047
+3903.89143,9.538,0.039
+3907.88202,9.422,0.04
+3912.87059,9.294,0.039
+3981.68065,9.008,0.046
+4253.93171,8.521,0.044
+4258.92019,8.487,0.037
+4273.88102,8.329,0.045
+4283.85713,8.407,0.042
+4285.85247,8.427,0.042
+4290.83492,8.504,0.049
+4293.83233,8.523,0.042
+4296.8227,8.624,0.042
+4301.80401,8.873,0.054
+4303.80372,8.87,0.045
+4305.79442,8.893,0.038
+4307.7936,9.025,0.054
+4309.78321,9.112,0.059
+4311.7869,9.174,0.04
+4319.75605,9.462,0.035
+4330.71942,9.866,0.038
+4332.72594,9.975,0.037
+4334.71692,10.04,0.035
+4347.68766,10.476,0.045
+4350.67822,10.58,0.038
+4353.66616,10.656,0.037
+4356.65611,10.8,0.038
+4359.64771,10.846,0.037
+4362.64625,10.982,0.034
+4364.64093,11.062,0.035
+4372.61611,11.282,0.045
+4376.60823,11.471,0.037
+4379.59932,11.663,0.057
+4382.58816,11.654,0.051
+4385.57692,11.857,0.035
+4387.58184,11.925,0.035
+4389.56873,11.939,0.044
+4403.52749,12.251,0.037
+4409.5191,12.54,0.04
+4631.92369,9.777,0.039
+4640.92177,9.968,0.05
+4645.93574,10.081,0.041
+4648.91382,10.103,0.037
+4661.87572,10.458,0.04
+4664.84448,10.548,0.039
+4666.8496,10.65,0.038
+4672.86644,10.806,0.036
+4675.85983,10.929,0.036
+4679.80544,11.05,0.036
+4682.80765,11.171,0.037
+4684.80805,11.246,0.04
+4686.80145,11.298,0.039
+4690.78818,11.378,0.035
+4693.78595,11.499,0.051
+4701.79238,11.658,0.035
+4704.74575,11.771,0.039
+4707.73783,11.755,0.046
+4716.72629,11.993,0.04
+4720.71771,12.003,0.042
+4722.72674,12.426,0.044
+4728.6768,12.239,0.043
+4730.72439,12.216,0.039
+4733.76544,12.307,0.056
+4739.64942,12.358,0.036
+4744.70318,12.325,0.037
+4746.70666,12.512,0.04
+4748.7177,12.513,0.038
+4754.64412,12.263,0.056
+4756.66845,12.592,0.048
+4759.62208,12.451,0.04
+4762.60727,12.448,0.041
+4767.59675,12.177,0.041
+4774.6189,12.352,0.043
+4776.62458,12.294,0.046
+4782.57845,12.417,0.047
+4784.62777,12.208,0.049
+4797.54233,11.796,0.051
+4803.54779,11.568,0.042
+4816.54062,10.933,0.052
+4992.93716,10.443,0.056
+5014.86617,11.245,0.056
+5017.90202,11.332,0.061
+5023.87545,11.402,0.055
+5048.77738,11.992,0.054
+5063.77957,12.087,0.057
+5072.76379,11.968,0.056
+5075.73142,11.994,0.059
+5082.76421,12.056,0.057
+5084.75892,11.978,0.049
+5089.74278,11.847,0.051
+5092.68685,11.946,0.047
+5105.65881,11.414,0.06
+5122.66529,10.679,0.062
+5131.57904,10.344,0.058
+5145.57672,9.755,0.06
```

### Comparing `cesium-0.9.7/cesium/tests/data/215153_215176_218272_218934.tar.gz` & `cesium-0.9.9/cesium/tests/data/215153_215176_218272_218934.tar.gz`

 * *Files identical despite different names*

### Comparing `cesium-0.9.7/cesium/tests/test_data_management.py` & `cesium-0.9.9/cesium/tests/test_data_management.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,88 +1,88 @@
-try:
-    from StringIO import StringIO
-except:
-    from io import StringIO
-import os
-from os.path import join as pjoin
-import shutil
-import numpy as np
-from cesium import data_management
-from cesium import util
-
-import numpy.testing as npt
-import pytest
-
-
-DATA_PATH = pjoin(os.path.dirname(__file__), "data")
-
-
-def test_parse_ts_data(tmpdir):
-    """Test time series data file parsing."""
-    to_str = lambda X: StringIO('\n'.join([','.join(row)
-                                           for row in X.astype(str).tolist()]))
-    values = np.random.random((10, 3))
-
-    t, m, e = data_management.parse_ts_data(to_str(values))
-    npt.assert_allclose(t, values[:, 0])
-    npt.assert_allclose(m, values[:, 1])
-    npt.assert_allclose(e, values[:, 2])
-
-    t, m, e = data_management.parse_ts_data(to_str(values[:, :2]))
-    npt.assert_allclose(t, values[:, 0])
-    npt.assert_allclose(m, values[:, 1])
-    npt.assert_allclose(e[1:], e[:-1])  # constant
-
-    t, m, e = data_management.parse_ts_data(to_str(values[:, :1]))
-    npt.assert_allclose(np.diff(t), 1. / (len(values) - 1))
-    npt.assert_allclose(m, values[:, 0])
-    npt.assert_allclose(e[1:], e[:-1])  # constant
-
-    with pytest.raises(ValueError):
-        data_management.parse_ts_data(to_str(values[:, []]))
-
-
-def test_parse_headerfile():
-    """Test header file parsing."""
-    headerfile_path = pjoin(DATA_PATH,
-                            "asas_training_subset_classes_with_metadata.dat")
-
-    labels, metadata = data_management.parse_headerfile(headerfile_path)
-    npt.assert_array_equal(metadata.keys(), ["meta1", "meta2", "meta3"])
-    npt.assert_equal(labels.loc["217801"], "Mira")
-    npt.assert_almost_equal(metadata.loc["224635"].meta1, 0.330610932539)
-
-    with pytest.raises(ValueError):
-        labels, metadata = data_management.parse_headerfile(
-            StringIO('test\n1,2\n3,4,5'))
-
-    labels, metadata = data_management.parse_headerfile(headerfile_path,
-        files_to_include=["217801"])
-    npt.assert_array_equal(metadata.keys(), ["meta1", "meta2", "meta3"])
-    npt.assert_equal(labels.loc["217801"], "Mira")
-
-    with pytest.raises(ValueError):
-        labels, metadata = data_management.parse_headerfile(headerfile_path,
-            files_to_include=["111111111"])
-
-    labels, metadata = data_management.parse_headerfile(headerfile_path,
-        files_to_include=["217801"])
-    npt.assert_array_equal(metadata.keys(), ["meta1", "meta2", "meta3"])
-    npt.assert_equal(labels.loc["217801"], "Mira")
-
-
-def test_parsing_and_saving(tmpdir):
-    data_file_path = pjoin(DATA_PATH, "215153_215176_218272_218934.tar.gz")
-    header_path = pjoin(DATA_PATH, "215153_215176_218272_218934_metadata.dat")
-    time_series = data_management.parse_and_store_ts_data(
-        data_file_path, str(tmpdir), header_path, cleanup_archive=False,
-        cleanup_header=False)
-    for ts in time_series:
-        assert isinstance(ts, str)
-        assert os.path.exists(ts)
-
-    time_series = data_management.parse_and_store_ts_data(
-        data_file_path, str(tmpdir), None, cleanup_archive=False,
-        cleanup_header=False)
-    for ts in time_series:
-        assert isinstance(ts, str)
-        assert os.path.exists(ts)
+try:
+    from StringIO import StringIO
+except:
+    from io import StringIO
+import os
+from os.path import join as pjoin
+import shutil
+import numpy as np
+from cesium import data_management
+from cesium import util
+
+import numpy.testing as npt
+import pytest
+
+
+DATA_PATH = pjoin(os.path.dirname(__file__), "data")
+
+
+def test_parse_ts_data(tmpdir):
+    """Test time series data file parsing."""
+    to_str = lambda X: StringIO('\n'.join([','.join(row)
+                                           for row in X.astype(str).tolist()]))
+    values = np.random.random((10, 3))
+
+    t, m, e = data_management.parse_ts_data(to_str(values))
+    npt.assert_allclose(t, values[:, 0])
+    npt.assert_allclose(m, values[:, 1])
+    npt.assert_allclose(e, values[:, 2])
+
+    t, m, e = data_management.parse_ts_data(to_str(values[:, :2]))
+    npt.assert_allclose(t, values[:, 0])
+    npt.assert_allclose(m, values[:, 1])
+    npt.assert_allclose(e[1:], e[:-1])  # constant
+
+    t, m, e = data_management.parse_ts_data(to_str(values[:, :1]))
+    npt.assert_allclose(np.diff(t), 1. / (len(values) - 1))
+    npt.assert_allclose(m, values[:, 0])
+    npt.assert_allclose(e[1:], e[:-1])  # constant
+
+    with pytest.raises(ValueError):
+        data_management.parse_ts_data(to_str(values[:, []]))
+
+
+def test_parse_headerfile():
+    """Test header file parsing."""
+    headerfile_path = pjoin(DATA_PATH,
+                            "asas_training_subset_classes_with_metadata.dat")
+
+    labels, metadata = data_management.parse_headerfile(headerfile_path)
+    npt.assert_array_equal(metadata.keys(), ["meta1", "meta2", "meta3"])
+    npt.assert_equal(labels.loc["217801"], "Mira")
+    npt.assert_almost_equal(metadata.loc["224635"].meta1, 0.330610932539)
+
+    with pytest.raises(ValueError):
+        labels, metadata = data_management.parse_headerfile(
+            StringIO('test\n1,2\n3,4,5'))
+
+    labels, metadata = data_management.parse_headerfile(headerfile_path,
+        files_to_include=["217801"])
+    npt.assert_array_equal(metadata.keys(), ["meta1", "meta2", "meta3"])
+    npt.assert_equal(labels.loc["217801"], "Mira")
+
+    with pytest.raises(ValueError):
+        labels, metadata = data_management.parse_headerfile(headerfile_path,
+            files_to_include=["111111111"])
+
+    labels, metadata = data_management.parse_headerfile(headerfile_path,
+        files_to_include=["217801"])
+    npt.assert_array_equal(metadata.keys(), ["meta1", "meta2", "meta3"])
+    npt.assert_equal(labels.loc["217801"], "Mira")
+
+
+def test_parsing_and_saving(tmpdir):
+    data_file_path = pjoin(DATA_PATH, "215153_215176_218272_218934.tar.gz")
+    header_path = pjoin(DATA_PATH, "215153_215176_218272_218934_metadata.dat")
+    time_series = data_management.parse_and_store_ts_data(
+        data_file_path, str(tmpdir), header_path, cleanup_archive=False,
+        cleanup_header=False)
+    for ts in time_series:
+        assert isinstance(ts, str)
+        assert os.path.exists(ts)
+
+    time_series = data_management.parse_and_store_ts_data(
+        data_file_path, str(tmpdir), None, cleanup_archive=False,
+        cleanup_header=False)
+    for ts in time_series:
+        assert isinstance(ts, str)
+        assert os.path.exists(ts)
```

### Comparing `cesium-0.9.7/cesium/tests/test_featurize.py` & `cesium-0.9.9/cesium/tests/test_featurize.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,283 +1,283 @@
-import os
-from os.path import join as pjoin
-import numpy as np
-import pandas as pd
-import scipy.stats
-import dask
-
-from cesium import featurize
-from cesium.tests.fixtures import (sample_values, sample_ts_files,
-                                   sample_featureset)
-
-import numpy.testing as npt
-import pytest
-
-
-DATA_PATH = pjoin(os.path.dirname(__file__), "data")
-FEATURES_CSV_PATH = pjoin(DATA_PATH, "test_features_with_targets.csv")
-
-
-def test_featurize_files_function(tmpdir):
-    """Test featurize function for on-disk time series"""
-    with sample_ts_files(size=4, labels=['A', 'B']) as ts_paths:
-        fset, labels = featurize.featurize_ts_files(ts_paths,
-                                                    features_to_use=["std_err"],
-                                                    scheduler=dask.get)
-    assert "std_err" in fset
-    assert fset.shape == (4, 1)
-    npt.assert_array_equal(labels, ['A', 'B', 'A', 'B'])
-
-
-def test_featurize_time_series_single():
-    """Test featurize wrapper function for single time series"""
-    t, m, e = sample_values()
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = {'meta1': 0.5}
-    fset = featurize.featurize_time_series(t, m, e, features_to_use,
-                                           meta_features, scheduler=dask.get)
-    assert fset['amplitude'].values.dtype == np.float64
-
-
-def test_featurize_time_series_single_multichannel():
-    """Test featurize wrapper function for single multichannel time series"""
-    n_channels = 3
-    t, m, e = sample_values(channels=n_channels)
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = {'meta1': 0.5}
-    fset = featurize.featurize_time_series(t, m, e, features_to_use,
-                                           meta_features, scheduler=dask.get)
-    assert ('amplitude', 0) in fset.columns
-    assert 'meta1' in fset.columns
-
-
-def test_featurize_time_series_multiple():
-    """Test featurize wrapper function for multiple time series"""
-    n_series = 5
-    list_of_series = [sample_values() for i in range(n_series)]
-    times, values, errors = [list(x) for x in zip(*list_of_series)]
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = [{'meta1': 0.5}] * n_series
-    fset = featurize.featurize_time_series(times, values, errors,
-                                           features_to_use,
-                                           meta_features, scheduler=dask.get)
-    npt.assert_array_equal(sorted(fset.columns.get_level_values('feature')),
-                           ['amplitude', 'meta1', 'std_err'])
-
-
-def test_featurize_time_series_multiple_multichannel():
-    """Test featurize wrapper function for multiple multichannel time series"""
-    n_series = 5
-    n_channels = 3
-    list_of_series = [sample_values(channels=n_channels)
-                      for i in range(n_series)]
-    times, values, errors = [list(x) for x in zip(*list_of_series)]
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = {'meta1': 0.5}
-    fset = featurize.featurize_time_series(times, values, errors,
-                                           features_to_use,
-                                           meta_features, scheduler=dask.get)
-    assert ('amplitude', 0) in fset.columns
-    assert 'meta1' in fset.columns
-
-
-def test_featurize_time_series_uneven_multichannel():
-    """Test featurize wrapper function for uneven-length multichannel data"""
-    n_channels = 3
-    t, m, e = sample_values(channels=n_channels)
-    t = [[t, t[0:-5], t[0:-10]]]
-    m = [[m[0], m[1][0:-5], m[2][0:-10]]]
-    e = [[e[0], e[1][0:-5], e[2][0:-10]]]
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = {'meta1': 0.5}
-    fset = featurize.featurize_time_series(t, m, e, features_to_use,
-                                           meta_features, scheduler=dask.get)
-    assert ('amplitude', 0) in fset.columns
-    assert 'meta1' in fset.columns
-
-
-def test_featurize_time_series_custom_functions():
-    """Test featurize wrapper function for time series w/ custom functions"""
-    n_channels = 3
-    t, m, e = sample_values(channels=n_channels)
-    features_to_use = ['amplitude', 'std_err', 'test_f']
-    meta_features = {'meta1': 0.5}
-    custom_functions = {'test_f': lambda t, m, e: np.pi}
-    fset = featurize.featurize_time_series(t, m, e, features_to_use,
-                                           meta_features,
-                                           custom_functions=custom_functions,
-                                           scheduler=dask.get)
-    npt.assert_array_equal(fset['test_f', 0], np.pi)
-    assert ('amplitude', 0) in fset.columns
-    assert 'meta1' in fset.columns
-
-
-def test_featurize_time_series_custom_dask_graph():
-    """Test featurize wrapper function for time series w/ custom dask graph"""
-    n_channels = 3
-    t, m, e = sample_values(channels=n_channels)
-    features_to_use = ['amplitude', 'std_err', 'test_f', 'test_meta']
-    meta_features = {'meta1': 0.5}
-    custom_functions = {'test_f': (lambda x: x.min() - x.max(), 'amplitude'),
-                        'test_meta': (lambda x: 2. * x, 'meta1')}
-    fset = featurize.featurize_time_series(t, m, e, features_to_use,
-                                           meta_features,
-                                           custom_functions=custom_functions,
-                                           scheduler=dask.get)
-    assert ('amplitude', 0) in fset.columns
-    assert ('test_f', 0) in fset.columns
-    assert ('test_meta', 0) in fset.columns
-
-
-def test_featurize_time_series_default_times():
-    """Test featurize wrapper function for time series w/ missing times"""
-    n_channels = 3
-    _, m, e = sample_values(channels=n_channels)
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = {}
-    fset = featurize.featurize_time_series(None, m, e, features_to_use,
-                                           meta_features, scheduler=dask.get)
-
-    m = [[m[0], m[1][0:-5], m[2][0:-10]]]
-    e = [[e[0], e[1][0:-5], e[2][0:-10]]]
-    fset = featurize.featurize_time_series(None, m, e, features_to_use,
-                                           meta_features, scheduler=dask.get)
-
-    m = m[0][0]
-    e = e[0][0]
-    fset = featurize.featurize_time_series(None, m, e, features_to_use,
-                                           meta_features, scheduler=dask.get)
-    assert ('amplitude', 0) in fset.columns
-
-
-def test_featurize_time_series_default_errors():
-    """Test featurize wrapper function for time series w/ missing errors"""
-    n_channels = 3
-    t, m, _ = sample_values(channels=n_channels)
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = {}
-    fset = featurize.featurize_time_series(t, m, None, features_to_use,
-                                           meta_features, scheduler=dask.get)
-
-    t = [[t, t[0:-5], t[0:-10]]]
-    m = [[m[0], m[1][0:-5], m[2][0:-10]]]
-    fset = featurize.featurize_time_series(t, m, None, features_to_use,
-                                           meta_features, scheduler=dask.get)
-
-    t = t[0][0]
-    m = m[0][0]
-    fset = featurize.featurize_time_series(t, m, None, features_to_use,
-                                           meta_features, scheduler=dask.get)
-    assert ('amplitude', 0) in fset.columns
-
-
-def test_featurize_time_series_pandas_metafeatures():
-    """Test featurize function for metafeatures passed as Series/DataFrames."""
-    t, m, e = sample_values()
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = pd.Series({'meta1': 0.5})
-    fset = featurize.featurize_time_series(t, m, e, features_to_use,
-                                           meta_features, scheduler=dask.get)
-    npt.assert_allclose(fset['meta1'], 0.5)
-
-    n_series = 5
-    list_of_series = [sample_values() for i in range(n_series)]
-    times, values, errors = [list(x) for x in zip(*list_of_series)]
-    features_to_use = ['amplitude', 'std_err']
-    meta_features = pd.DataFrame({'meta1': [0.5] * n_series,
-                                  'meta2': [0.8] * n_series})
-    fset = featurize.featurize_time_series(times, values, errors,
-                                           features_to_use,
-                                           meta_features, scheduler=dask.get)
-    npt.assert_allclose(fset['meta1'], 0.5)
-    npt.assert_allclose(fset['meta2'], 0.8)
-
-
-def test_impute():
-    """Test imputation of missing Featureset values."""
-    fset, labels = sample_featureset(5, 1, ['amplitude'], ['class1', 'class2'],
-                                     names=['a', 'b', 'c', 'd', 'e'],
-                                     meta_features=['meta1'])
-
-    imputed = featurize.impute_featureset(fset)
-    npt.assert_allclose(fset.amplitude.values, imputed.amplitude.values)
-    assert isinstance(imputed, pd.DataFrame)
-
-    fset.amplitude.values[0] = np.inf
-    fset.amplitude.values[1] = np.nan
-    amp_values = fset.amplitude.values[2:]
-    other_values = fset.values.T.ravel()[2:]
-
-    imputed = featurize.impute_featureset(fset, strategy='constant',
-                                          value=None)
-    npt.assert_allclose(-2 * np.nanmax(np.abs(other_values)),
-                        imputed.amplitude.values[0:2])
-
-    imputed = featurize.impute_featureset(fset, strategy='constant',
-                                          value=-1e4)
-    npt.assert_allclose(-1e4, imputed.amplitude.values[0:2])
-
-    imputed = featurize.impute_featureset(fset, strategy='mean')
-    npt.assert_allclose(np.mean(amp_values), imputed.amplitude.values[0:2])
-    npt.assert_allclose(amp_values, imputed.amplitude.values[2:])
-
-    imputed = featurize.impute_featureset(fset, strategy='median')
-    npt.assert_allclose(np.median(amp_values), imputed.amplitude.values[0:2])
-    npt.assert_allclose(amp_values, imputed.amplitude.values[2:])
-
-    imputed = featurize.impute_featureset(fset, strategy='most_frequent')
-    npt.assert_allclose(scipy.stats.mode(amp_values).mode.item(),
-                        imputed.amplitude.values[0:2])
-    npt.assert_allclose(amp_values, imputed.amplitude.values[2:])
-
-    featurize.impute_featureset(fset, strategy='constant', value=-1e4,
-                                inplace=True)
-    npt.assert_allclose(-1e4, fset.amplitude.values[0:2])
-
-    with pytest.raises(NotImplementedError):
-        featurize.impute_featureset(fset, strategy='blah')
-
-
-def test_roundtrip_featureset(tmpdir):
-    fset_path = os.path.join(str(tmpdir), 'test.npz')
-    for n_channels in [1, 3]:
-        for labels in [['class1', 'class2'], []]:
-            fset, labels = sample_featureset(3, n_channels, ['amplitude'],
-                                             labels, names=['a', 'b', 'c'],
-                                             meta_features=['meta1'])
-
-            pred_probs = pd.DataFrame(np.random.random((len(fset), 2)),
-                                      index=fset.index.values,
-                                      columns=['class1', 'class2'])
-
-            featurize.save_featureset(fset, fset_path, labels=labels,
-                                      pred_probs=pred_probs)
-            fset_loaded, data_loaded = featurize.load_featureset(fset_path)
-            npt.assert_allclose(fset.values, fset_loaded.values)
-            npt.assert_array_equal(fset.index, fset_loaded.index)
-            npt.assert_array_equal(fset.columns, fset_loaded.columns)
-            assert isinstance(fset_loaded, pd.DataFrame)
-            npt.assert_array_equal(labels, data_loaded['labels'])
-            npt.assert_allclose(pred_probs, data_loaded['pred_probs'])
-            npt.assert_array_equal(pred_probs.columns,
-                                   data_loaded['pred_probs'].columns)
-
-
-def test_ignore_exceptions():
-    import cesium.features.graphs
-    def raise_exc(x):
-        raise ValueError()
-    old_value = cesium.features.graphs.dask_feature_graph['mean']
-    try:
-        cesium.features.graphs.dask_feature_graph['mean'] = (raise_exc, 't')
-        t, m, e = sample_values()
-        features_to_use = ['mean']
-        with pytest.raises(ValueError):
-            fset = featurize.featurize_time_series(t, m, e, features_to_use,
-                                                   scheduler=dask.get,
-                                                   raise_exceptions=True)
-        fset = featurize.featurize_time_series(t, m, e, features_to_use,
-                                               scheduler=dask.get,
-                                               raise_exceptions=False)
-        assert np.isnan(fset.values).all()
-    finally:
-        cesium.features.graphs.dask_feature_graph['mean'] = old_value
+import os
+from os.path import join as pjoin
+import numpy as np
+import pandas as pd
+import scipy.stats
+import dask
+
+from cesium import featurize
+from cesium.tests.fixtures import (sample_values, sample_ts_files,
+                                   sample_featureset)
+
+import numpy.testing as npt
+import pytest
+
+
+DATA_PATH = pjoin(os.path.dirname(__file__), "data")
+FEATURES_CSV_PATH = pjoin(DATA_PATH, "test_features_with_targets.csv")
+
+
+def test_featurize_files_function(tmpdir):
+    """Test featurize function for on-disk time series"""
+    with sample_ts_files(size=4, labels=['A', 'B']) as ts_paths:
+        fset, labels = featurize.featurize_ts_files(ts_paths,
+                                                    features_to_use=["std_err"],
+                                                    scheduler=dask.get)
+    assert "std_err" in fset
+    assert fset.shape == (4, 1)
+    npt.assert_array_equal(labels, ['A', 'B', 'A', 'B'])
+
+
+def test_featurize_time_series_single():
+    """Test featurize wrapper function for single time series"""
+    t, m, e = sample_values()
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = {'meta1': 0.5}
+    fset = featurize.featurize_time_series(t, m, e, features_to_use,
+                                           meta_features, scheduler=dask.get)
+    assert fset['amplitude'].values.dtype == np.float64
+
+
+def test_featurize_time_series_single_multichannel():
+    """Test featurize wrapper function for single multichannel time series"""
+    n_channels = 3
+    t, m, e = sample_values(channels=n_channels)
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = {'meta1': 0.5}
+    fset = featurize.featurize_time_series(t, m, e, features_to_use,
+                                           meta_features, scheduler=dask.get)
+    assert ('amplitude', 0) in fset.columns
+    assert 'meta1' in fset.columns
+
+
+def test_featurize_time_series_multiple():
+    """Test featurize wrapper function for multiple time series"""
+    n_series = 5
+    list_of_series = [sample_values() for i in range(n_series)]
+    times, values, errors = [list(x) for x in zip(*list_of_series)]
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = [{'meta1': 0.5}] * n_series
+    fset = featurize.featurize_time_series(times, values, errors,
+                                           features_to_use,
+                                           meta_features, scheduler=dask.get)
+    npt.assert_array_equal(sorted(fset.columns.get_level_values('feature')),
+                           ['amplitude', 'meta1', 'std_err'])
+
+
+def test_featurize_time_series_multiple_multichannel():
+    """Test featurize wrapper function for multiple multichannel time series"""
+    n_series = 5
+    n_channels = 3
+    list_of_series = [sample_values(channels=n_channels)
+                      for i in range(n_series)]
+    times, values, errors = [list(x) for x in zip(*list_of_series)]
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = {'meta1': 0.5}
+    fset = featurize.featurize_time_series(times, values, errors,
+                                           features_to_use,
+                                           meta_features, scheduler=dask.get)
+    assert ('amplitude', 0) in fset.columns
+    assert 'meta1' in fset.columns
+
+
+def test_featurize_time_series_uneven_multichannel():
+    """Test featurize wrapper function for uneven-length multichannel data"""
+    n_channels = 3
+    t, m, e = sample_values(channels=n_channels)
+    t = [[t, t[0:-5], t[0:-10]]]
+    m = [[m[0], m[1][0:-5], m[2][0:-10]]]
+    e = [[e[0], e[1][0:-5], e[2][0:-10]]]
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = {'meta1': 0.5}
+    fset = featurize.featurize_time_series(t, m, e, features_to_use,
+                                           meta_features, scheduler=dask.get)
+    assert ('amplitude', 0) in fset.columns
+    assert 'meta1' in fset.columns
+
+
+def test_featurize_time_series_custom_functions():
+    """Test featurize wrapper function for time series w/ custom functions"""
+    n_channels = 3
+    t, m, e = sample_values(channels=n_channels)
+    features_to_use = ['amplitude', 'std_err', 'test_f']
+    meta_features = {'meta1': 0.5}
+    custom_functions = {'test_f': lambda t, m, e: np.pi}
+    fset = featurize.featurize_time_series(t, m, e, features_to_use,
+                                           meta_features,
+                                           custom_functions=custom_functions,
+                                           scheduler=dask.get)
+    npt.assert_array_equal(fset['test_f', 0], np.pi)
+    assert ('amplitude', 0) in fset.columns
+    assert 'meta1' in fset.columns
+
+
+def test_featurize_time_series_custom_dask_graph():
+    """Test featurize wrapper function for time series w/ custom dask graph"""
+    n_channels = 3
+    t, m, e = sample_values(channels=n_channels)
+    features_to_use = ['amplitude', 'std_err', 'test_f', 'test_meta']
+    meta_features = {'meta1': 0.5}
+    custom_functions = {'test_f': (lambda x: x.min() - x.max(), 'amplitude'),
+                        'test_meta': (lambda x: 2. * x, 'meta1')}
+    fset = featurize.featurize_time_series(t, m, e, features_to_use,
+                                           meta_features,
+                                           custom_functions=custom_functions,
+                                           scheduler=dask.get)
+    assert ('amplitude', 0) in fset.columns
+    assert ('test_f', 0) in fset.columns
+    assert ('test_meta', 0) in fset.columns
+
+
+def test_featurize_time_series_default_times():
+    """Test featurize wrapper function for time series w/ missing times"""
+    n_channels = 3
+    _, m, e = sample_values(channels=n_channels)
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = {}
+    fset = featurize.featurize_time_series(None, m, e, features_to_use,
+                                           meta_features, scheduler=dask.get)
+
+    m = [[m[0], m[1][0:-5], m[2][0:-10]]]
+    e = [[e[0], e[1][0:-5], e[2][0:-10]]]
+    fset = featurize.featurize_time_series(None, m, e, features_to_use,
+                                           meta_features, scheduler=dask.get)
+
+    m = m[0][0]
+    e = e[0][0]
+    fset = featurize.featurize_time_series(None, m, e, features_to_use,
+                                           meta_features, scheduler=dask.get)
+    assert ('amplitude', 0) in fset.columns
+
+
+def test_featurize_time_series_default_errors():
+    """Test featurize wrapper function for time series w/ missing errors"""
+    n_channels = 3
+    t, m, _ = sample_values(channels=n_channels)
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = {}
+    fset = featurize.featurize_time_series(t, m, None, features_to_use,
+                                           meta_features, scheduler=dask.get)
+
+    t = [[t, t[0:-5], t[0:-10]]]
+    m = [[m[0], m[1][0:-5], m[2][0:-10]]]
+    fset = featurize.featurize_time_series(t, m, None, features_to_use,
+                                           meta_features, scheduler=dask.get)
+
+    t = t[0][0]
+    m = m[0][0]
+    fset = featurize.featurize_time_series(t, m, None, features_to_use,
+                                           meta_features, scheduler=dask.get)
+    assert ('amplitude', 0) in fset.columns
+
+
+def test_featurize_time_series_pandas_metafeatures():
+    """Test featurize function for metafeatures passed as Series/DataFrames."""
+    t, m, e = sample_values()
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = pd.Series({'meta1': 0.5})
+    fset = featurize.featurize_time_series(t, m, e, features_to_use,
+                                           meta_features, scheduler=dask.get)
+    npt.assert_allclose(fset['meta1'], 0.5)
+
+    n_series = 5
+    list_of_series = [sample_values() for i in range(n_series)]
+    times, values, errors = [list(x) for x in zip(*list_of_series)]
+    features_to_use = ['amplitude', 'std_err']
+    meta_features = pd.DataFrame({'meta1': [0.5] * n_series,
+                                  'meta2': [0.8] * n_series})
+    fset = featurize.featurize_time_series(times, values, errors,
+                                           features_to_use,
+                                           meta_features, scheduler=dask.get)
+    npt.assert_allclose(fset['meta1'], 0.5)
+    npt.assert_allclose(fset['meta2'], 0.8)
+
+
+def test_impute():
+    """Test imputation of missing Featureset values."""
+    fset, labels = sample_featureset(5, 1, ['amplitude'], ['class1', 'class2'],
+                                     names=['a', 'b', 'c', 'd', 'e'],
+                                     meta_features=['meta1'])
+
+    imputed = featurize.impute_featureset(fset)
+    npt.assert_allclose(fset.amplitude.values, imputed.amplitude.values)
+    assert isinstance(imputed, pd.DataFrame)
+
+    fset.amplitude.values[0] = np.inf
+    fset.amplitude.values[1] = np.nan
+    amp_values = fset.amplitude.values[2:]
+    other_values = fset.values.T.ravel()[2:]
+
+    imputed = featurize.impute_featureset(fset, strategy='constant',
+                                          value=None)
+    npt.assert_allclose(-2 * np.nanmax(np.abs(other_values)),
+                        imputed.amplitude.values[0:2])
+
+    imputed = featurize.impute_featureset(fset, strategy='constant',
+                                          value=-1e4)
+    npt.assert_allclose(-1e4, imputed.amplitude.values[0:2])
+
+    imputed = featurize.impute_featureset(fset, strategy='mean')
+    npt.assert_allclose(np.mean(amp_values), imputed.amplitude.values[0:2])
+    npt.assert_allclose(amp_values, imputed.amplitude.values[2:])
+
+    imputed = featurize.impute_featureset(fset, strategy='median')
+    npt.assert_allclose(np.median(amp_values), imputed.amplitude.values[0:2])
+    npt.assert_allclose(amp_values, imputed.amplitude.values[2:])
+
+    imputed = featurize.impute_featureset(fset, strategy='most_frequent')
+    npt.assert_allclose(scipy.stats.mode(amp_values).mode.item(),
+                        imputed.amplitude.values[0:2])
+    npt.assert_allclose(amp_values, imputed.amplitude.values[2:])
+
+    featurize.impute_featureset(fset, strategy='constant', value=-1e4,
+                                inplace=True)
+    npt.assert_allclose(-1e4, fset.amplitude.values[0:2])
+
+    with pytest.raises(NotImplementedError):
+        featurize.impute_featureset(fset, strategy='blah')
+
+
+def test_roundtrip_featureset(tmpdir):
+    fset_path = os.path.join(str(tmpdir), 'test.npz')
+    for n_channels in [1, 3]:
+        for labels in [['class1', 'class2'], []]:
+            fset, labels = sample_featureset(3, n_channels, ['amplitude'],
+                                             labels, names=['a', 'b', 'c'],
+                                             meta_features=['meta1'])
+
+            pred_probs = pd.DataFrame(np.random.random((len(fset), 2)),
+                                      index=fset.index.values,
+                                      columns=['class1', 'class2'])
+
+            featurize.save_featureset(fset, fset_path, labels=labels,
+                                      pred_probs=pred_probs)
+            fset_loaded, data_loaded = featurize.load_featureset(fset_path)
+            npt.assert_allclose(fset.values, fset_loaded.values)
+            npt.assert_array_equal(fset.index, fset_loaded.index)
+            npt.assert_array_equal(fset.columns, fset_loaded.columns)
+            assert isinstance(fset_loaded, pd.DataFrame)
+            npt.assert_array_equal(labels, data_loaded['labels'])
+            npt.assert_allclose(pred_probs, data_loaded['pred_probs'])
+            npt.assert_array_equal(pred_probs.columns,
+                                   data_loaded['pred_probs'].columns)
+
+
+def test_ignore_exceptions():
+    import cesium.features.graphs
+    def raise_exc(x):
+        raise ValueError()
+    old_value = cesium.features.graphs.dask_feature_graph['mean']
+    try:
+        cesium.features.graphs.dask_feature_graph['mean'] = (raise_exc, 't')
+        t, m, e = sample_values()
+        features_to_use = ['mean']
+        with pytest.raises(ValueError):
+            fset = featurize.featurize_time_series(t, m, e, features_to_use,
+                                                   scheduler=dask.get,
+                                                   raise_exceptions=True)
+        fset = featurize.featurize_time_series(t, m, e, features_to_use,
+                                               scheduler=dask.get,
+                                               raise_exceptions=False)
+        assert np.isnan(fset.values).all()
+    finally:
+        cesium.features.graphs.dask_feature_graph['mean'] = old_value
```

### Comparing `cesium-0.9.7/cesium/util.py` & `cesium-0.9.9/cesium/util.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,111 +1,111 @@
-import contextlib
-import errno
-import os
-import tarfile
-import tempfile
-import zipfile
-
-
-__all__ = ['shorten_fname', 'remove_files', 'extract_time_series']
-
-
-def shorten_fname(file_path):
-    """Extract the name of a file (omitting directory names and extensions).
-
-    Parameters
-    ----------
-    file_path : str
-        Absolute or relative path to a file.
-
-    Returns
-    -------
-    str
-       The name of the file with directory names and extensions removed.
-
-    """
-    return os.path.splitext(os.path.basename(file_path))[0]
-
-
-def remove_files(paths):
-    """Remove specified file(s) from disk.
-
-    Parameters
-    ----------
-    paths : str or list of str
-        Path(s) to file(s) to be removed from disk.
-
-    """
-    if isinstance(paths, str):
-        paths = [paths]
-
-    for path in paths:
-        try:
-            os.remove(path)
-        except OSError as e:
-            if e.errno != errno.ENOENT:
-                raise
-            else:
-                pass
-
-
-@contextlib.contextmanager
-def extract_time_series(data_path, cleanup_archive=True, cleanup_files=False,
-                        extract_dir=None):
-    """Extract zip- or tarfile of time series file and return file paths.
-
-    If the given file is not a tar- or zipfile then it is treated as a single
-    time series filepath.
-
-    Parameters
-    ----------
-    data_path : str
-        Path to data archive or single data file.
-
-    cleanup_archive : bool, optional
-        Boolean specifying whether to delete the original archive (if
-        applicable). Defaults to True.
-
-    cleanup_files : bool, optional
-        Boolean specifying whether to delete the extracted files when exiting
-        the given context. Defaults to False.
-
-    extract_dir : str, optional
-        Directory into which files are to be extracted (if applicable). If
-        None, a temporary directory is created.
-
-    Yields
-    ------
-    list of str
-        List of full paths to time series files.
-    """
-    if extract_dir is None:
-        extract_dir = tempfile.mkdtemp()
-
-    if tarfile.is_tarfile(data_path):
-        archive = tarfile.open(data_path)
-        members_to_extract = [x for x in archive.getmembers() if not
-                              x.name.startswith(('.', '/'))]
-        extracted_names = [x.name for x in members_to_extract]
-        archive.extractall(path=extract_dir, members=members_to_extract)
-        all_paths = [os.path.join(extract_dir, f) for f in extracted_names]
-    elif zipfile.is_zipfile(data_path):
-        archive = zipfile.ZipFile(data_path)
-        members_to_extract = [x for x in archive.namelist() if not
-                              x.startswith(('.', '/'))]
-        archive.extractall(path=extract_dir, members=members_to_extract)
-        all_paths = [os.path.join(extract_dir, f) for f in members_to_extract]
-    else:
-        archive = None
-        all_paths = [data_path]
-
-    if archive:
-        archive.close()
-        if cleanup_archive:
-            remove_files(data_path)
-
-    file_paths = [f for f in all_paths if not os.path.isdir(f)]
-    try:
-        yield file_paths
-    finally:
-        if cleanup_files:
-            remove_files(file_paths)
+import contextlib
+import errno
+import os
+import tarfile
+import tempfile
+import zipfile
+
+
+__all__ = ['shorten_fname', 'remove_files', 'extract_time_series']
+
+
+def shorten_fname(file_path):
+    """Extract the name of a file (omitting directory names and extensions).
+
+    Parameters
+    ----------
+    file_path : str
+        Absolute or relative path to a file.
+
+    Returns
+    -------
+    str
+       The name of the file with directory names and extensions removed.
+
+    """
+    return os.path.splitext(os.path.basename(file_path))[0]
+
+
+def remove_files(paths):
+    """Remove specified file(s) from disk.
+
+    Parameters
+    ----------
+    paths : str or list of str
+        Path(s) to file(s) to be removed from disk.
+
+    """
+    if isinstance(paths, str):
+        paths = [paths]
+
+    for path in paths:
+        try:
+            os.remove(path)
+        except OSError as e:
+            if e.errno != errno.ENOENT:
+                raise
+            else:
+                pass
+
+
+@contextlib.contextmanager
+def extract_time_series(data_path, cleanup_archive=True, cleanup_files=False,
+                        extract_dir=None):
+    """Extract zip- or tarfile of time series file and return file paths.
+
+    If the given file is not a tar- or zipfile then it is treated as a single
+    time series filepath.
+
+    Parameters
+    ----------
+    data_path : str
+        Path to data archive or single data file.
+
+    cleanup_archive : bool, optional
+        Boolean specifying whether to delete the original archive (if
+        applicable). Defaults to True.
+
+    cleanup_files : bool, optional
+        Boolean specifying whether to delete the extracted files when exiting
+        the given context. Defaults to False.
+
+    extract_dir : str, optional
+        Directory into which files are to be extracted (if applicable). If
+        None, a temporary directory is created.
+
+    Yields
+    ------
+    list of str
+        List of full paths to time series files.
+    """
+    if extract_dir is None:
+        extract_dir = tempfile.mkdtemp()
+
+    if tarfile.is_tarfile(data_path):
+        archive = tarfile.open(data_path)
+        members_to_extract = [x for x in archive.getmembers() if not
+                              x.name.startswith(('.', '/'))]
+        extracted_names = [x.name for x in members_to_extract]
+        archive.extractall(path=extract_dir, members=members_to_extract)
+        all_paths = [os.path.join(extract_dir, f) for f in extracted_names]
+    elif zipfile.is_zipfile(data_path):
+        archive = zipfile.ZipFile(data_path)
+        members_to_extract = [x for x in archive.namelist() if not
+                              x.startswith(('.', '/'))]
+        archive.extractall(path=extract_dir, members=members_to_extract)
+        all_paths = [os.path.join(extract_dir, f) for f in members_to_extract]
+    else:
+        archive = None
+        all_paths = [data_path]
+
+    if archive:
+        archive.close()
+        if cleanup_archive:
+            remove_files(data_path)
+
+    file_paths = [f for f in all_paths if not os.path.isdir(f)]
+    try:
+        yield file_paths
+    finally:
+        if cleanup_files:
+            remove_files(file_paths)
```

### Comparing `cesium-0.9.7/cesium/data_management.py` & `cesium-0.9.9/cesium/data_management.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,158 +1,158 @@
-import os
-import numpy as np
-import pandas as pd
-from . import util
-from . import time_series
-from .time_series import TimeSeries
-
-
-__all__ = ['parse_ts_data', 'parse_headerfile', 'parse_and_store_ts_data']
-
-
-# TODO more robust error handling
-def parse_ts_data(filepath, sep=","):
-    """Parses raw time series data file and returns an (n, 3) array of values.
-
-    Data is expected as text in tabular format with separator `sep`. The output
-    will always have three columns (time, measurement, error), even if the data
-    file contains two or fewer:
-
-    - For data containing three columns (time, measurement, error), all
-      three are returned.
-    - For data containing two columns, a dummy error column is added with
-      value `time_series.DEFAULT_ERROR_VALUE`.
-    - For data containing one column, a time column is also added with
-      values evenly spaced from 0 to `time_series.DEFAULT_MAX_TIME`.
-
-    Parameters
-    ----------
-    filename : str
-        Path to raw time series data to be parsed.
-    sep : str, optional
-        Separator of columns in data file; defaults to ','.
-
-    Returns
-    -------
-    np.ndarray
-        3-column array of (time, measurement, error) values.
-    """
-    ts_data = np.loadtxt(filepath, delimiter=sep, ndmin=2)
-    ts_data = ts_data[:, :3]  # Only using T, M, E
-    if ts_data.shape[0] == 0 or ts_data.shape[1] == 0:
-        raise ValueError("Incomplete or improperly formatted time series data"
-                         " file provided.")
-    elif ts_data.shape[1] == 1:
-        ts_data = np.c_[np.linspace(0, time_series.DEFAULT_MAX_TIME,
-                                    len(ts_data)),
-                        ts_data,
-                        np.repeat(time_series.DEFAULT_ERROR_VALUE,
-                                  len(ts_data))]
-    elif ts_data.shape[1] == 2:
-        ts_data = np.c_[ts_data,
-                        np.repeat(time_series.DEFAULT_ERROR_VALUE,
-                                  len(ts_data))]
-    return ts_data.T
-
-
-def parse_headerfile(headerfile_path, files_to_include=None):
-    """Parse header file containing classes/targets and meta-feature
-    information.
-
-    Parameters
-    ----------
-    headerfile_path : str
-        Path to header file.
-
-    files_to_include : list, optional
-        If provided, only return the subset of rows from the header
-        corresponding to the given filenames.
-
-    Returns
-    -------
-    pandas.Series
-        Class labels/targets from header file (if missing, all values are None)
-
-    pandas.DataFrame
-        Feature data from other columns besides filename, label (can be empty)
-    """
-    try:
-        header = pd.read_csv(headerfile_path, comment='#')
-    except:
-        raise ValueError("Improperly formatted header file.")
-    if 'filename' in header:
-        header.index = [util.shorten_fname(str(f)) for f in header['filename']]
-        header.drop('filename', axis=1, inplace=True)
-    if files_to_include:
-        short_fnames_to_include = [util.shorten_fname(str(f))
-                                   for f in files_to_include]
-        try:
-            header = header.loc[short_fnames_to_include]
-        except:
-            raise ValueError("Incomplete header file: make sure your "
-                              "header contains an entry for each time "
-                              "series file in the uploaded archive, and "
-                              "that the file names match the first column "
-                              "of the header.")
-    header.rename(columns={c: 'label' for c in ['label', 'target', 'class',
-                                                'class_label']}, inplace=True)
-    labels = (header.label if 'label' in header
-              else pd.Series([None]*len(header.index), index=header.index))
-    feature_data = header.drop(['label', 'class'], axis=1, errors='ignore')
-    return labels, feature_data
-
-
-def parse_and_store_ts_data(data_path, output_dir, header_path=None,
-                            cleanup_archive=True, cleanup_header=True, sep=','):
-    """Parses raw time series data from a single file or archive and loads
-    metadata from header file (if applicable). Data is stored as files within
-    `output_dir`, and the list of these paths is returned.
-
-    Parameters
-    ----------
-    data_path : str
-        Path to an individual time series file or tarball of multiple time
-        series files to be used for feature generation.
-    output_dir : str
-        Directory in which time series files will be saved.
-    header_path : str, optional
-        Path to header file containing file names, labels/targets, and
-        meta_features.
-    cleanup_archive : bool, optional
-        Boolean specifying whether to delete the uploaded data file/archive
-        (defaults to True).
-    cleanup_header : bool, optional
-        Boolean specifying whether to delete the uploaded header file (defaults
-        to True).
-    sep : str, optional
-        Separator of columns in data file; defaults to ','.
-
-    Returns
-    -------
-    List of paths to time series files
-    """
-    with util.extract_time_series(data_path, cleanup_archive=cleanup_archive,
-                                  cleanup_files=True) as ts_paths:
-        short_fnames = [util.shorten_fname(f) for f in ts_paths]
-        if header_path:
-            labels, meta_features = parse_headerfile(header_path, ts_paths)
-        else:
-            labels = pd.Series([None]*len(short_fnames), index=short_fnames)
-            meta_features = pd.DataFrame(index=short_fnames)
-
-        all_time_series = []
-        for ts_path in ts_paths:
-            fname = util.shorten_fname(ts_path)
-            t, m, e = parse_ts_data(ts_path, sep)
-            ts_label = labels.loc[fname]
-            ts_meta_features = meta_features.loc[fname]
-            ts_path = '{}.npz'.format(fname)
-            ts_path = os.path.join(output_dir, ts_path)
-            ts = TimeSeries(t, m, e, ts_label, ts_meta_features, fname,
-                            ts_path)
-            ts.save(ts_path)
-            all_time_series.append(ts_path)
-
-    if header_path and cleanup_header:
-        util.remove_files([header_path])
-
-    return all_time_series
+import os
+import numpy as np
+import pandas as pd
+from . import util
+from . import time_series
+from .time_series import TimeSeries
+
+
+__all__ = ['parse_ts_data', 'parse_headerfile', 'parse_and_store_ts_data']
+
+
+# TODO more robust error handling
+def parse_ts_data(filepath, sep=","):
+    """Parses raw time series data file and returns an (n, 3) array of values.
+
+    Data is expected as text in tabular format with separator `sep`. The output
+    will always have three columns (time, measurement, error), even if the data
+    file contains two or fewer:
+
+    - For data containing three columns (time, measurement, error), all
+      three are returned.
+    - For data containing two columns, a dummy error column is added with
+      value `time_series.DEFAULT_ERROR_VALUE`.
+    - For data containing one column, a time column is also added with
+      values evenly spaced from 0 to `time_series.DEFAULT_MAX_TIME`.
+
+    Parameters
+    ----------
+    filename : str
+        Path to raw time series data to be parsed.
+    sep : str, optional
+        Separator of columns in data file; defaults to ','.
+
+    Returns
+    -------
+    np.ndarray
+        3-column array of (time, measurement, error) values.
+    """
+    ts_data = np.loadtxt(filepath, delimiter=sep, ndmin=2)
+    ts_data = ts_data[:, :3]  # Only using T, M, E
+    if ts_data.shape[0] == 0 or ts_data.shape[1] == 0:
+        raise ValueError("Incomplete or improperly formatted time series data"
+                         " file provided.")
+    elif ts_data.shape[1] == 1:
+        ts_data = np.c_[np.linspace(0, time_series.DEFAULT_MAX_TIME,
+                                    len(ts_data)),
+                        ts_data,
+                        np.repeat(time_series.DEFAULT_ERROR_VALUE,
+                                  len(ts_data))]
+    elif ts_data.shape[1] == 2:
+        ts_data = np.c_[ts_data,
+                        np.repeat(time_series.DEFAULT_ERROR_VALUE,
+                                  len(ts_data))]
+    return ts_data.T
+
+
+def parse_headerfile(headerfile_path, files_to_include=None):
+    """Parse header file containing classes/targets and meta-feature
+    information.
+
+    Parameters
+    ----------
+    headerfile_path : str
+        Path to header file.
+
+    files_to_include : list, optional
+        If provided, only return the subset of rows from the header
+        corresponding to the given filenames.
+
+    Returns
+    -------
+    pandas.Series
+        Class labels/targets from header file (if missing, all values are None)
+
+    pandas.DataFrame
+        Feature data from other columns besides filename, label (can be empty)
+    """
+    try:
+        header = pd.read_csv(headerfile_path, comment='#')
+    except:
+        raise ValueError("Improperly formatted header file.")
+    if 'filename' in header:
+        header.index = [util.shorten_fname(str(f)) for f in header['filename']]
+        header.drop('filename', axis=1, inplace=True)
+    if files_to_include:
+        short_fnames_to_include = [util.shorten_fname(str(f))
+                                   for f in files_to_include]
+        try:
+            header = header.loc[short_fnames_to_include]
+        except:
+            raise ValueError("Incomplete header file: make sure your "
+                              "header contains an entry for each time "
+                              "series file in the uploaded archive, and "
+                              "that the file names match the first column "
+                              "of the header.")
+    header.rename(columns={c: 'label' for c in ['label', 'target', 'class',
+                                                'class_label']}, inplace=True)
+    labels = (header.label if 'label' in header
+              else pd.Series([None] * len(header.index), index=header.index))
+    feature_data = header.drop(['label', 'class'], axis=1, errors='ignore')
+    return labels, feature_data
+
+
+def parse_and_store_ts_data(data_path, output_dir, header_path=None,
+                            cleanup_archive=True, cleanup_header=True, sep=','):
+    """Parses raw time series data from a single file or archive and loads
+    metadata from header file (if applicable). Data is stored as files within
+    `output_dir`, and the list of these paths is returned.
+
+    Parameters
+    ----------
+    data_path : str
+        Path to an individual time series file or tarball of multiple time
+        series files to be used for feature generation.
+    output_dir : str
+        Directory in which time series files will be saved.
+    header_path : str, optional
+        Path to header file containing file names, labels/targets, and
+        meta_features.
+    cleanup_archive : bool, optional
+        Boolean specifying whether to delete the uploaded data file/archive
+        (defaults to True).
+    cleanup_header : bool, optional
+        Boolean specifying whether to delete the uploaded header file (defaults
+        to True).
+    sep : str, optional
+        Separator of columns in data file; defaults to ','.
+
+    Returns
+    -------
+    List of paths to time series files
+    """
+    with util.extract_time_series(data_path, cleanup_archive=cleanup_archive,
+                                  cleanup_files=True) as ts_paths:
+        short_fnames = [util.shorten_fname(f) for f in ts_paths]
+        if header_path:
+            labels, meta_features = parse_headerfile(header_path, ts_paths)
+        else:
+            labels = pd.Series([None] * len(short_fnames), index=short_fnames)
+            meta_features = pd.DataFrame(index=short_fnames)
+
+        all_time_series = []
+        for ts_path in ts_paths:
+            fname = util.shorten_fname(ts_path)
+            t, m, e = parse_ts_data(ts_path, sep)
+            ts_label = labels.loc[fname]
+            ts_meta_features = meta_features.loc[fname]
+            ts_path = '{}.npz'.format(fname)
+            ts_path = os.path.join(output_dir, ts_path)
+            ts = TimeSeries(t, m, e, ts_label, ts_meta_features, fname,
+                            ts_path)
+            ts.save(ts_path)
+            all_time_series.append(ts_path)
+
+    if header_path and cleanup_header:
+        util.remove_files([header_path])
+
+    return all_time_series
```

### Comparing `cesium-0.9.7/cesium/time_series.py` & `cesium-0.9.9/cesium/time_series.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,299 +1,299 @@
-import copy
-from collections import Iterable
-import numpy as np
-
-
-__all__ = ['load', 'TimeSeries', 'DEFAULT_MAX_TIME',
-           'DEFAULT_ERROR_VALUE']
-
-
-DEFAULT_MAX_TIME = 1.0
-DEFAULT_ERROR_VALUE = 1e-4
-
-
-def _ndim(x):
-    """Return number of dimensions for a (possibly ragged) array."""
-    n = 0
-    while isinstance(x, Iterable):
-        x = x[0]
-        n += 1
-    return n
-
-
-def _compatible_shapes(x, y):
-    """Check recursively that iterables x and y (and each iterable contained
-    within, if applicable), have compatible sizes.
-    """
-    if hasattr(x, 'shape') and hasattr(y, 'shape'):
-        return x.shape == y.shape
-    else:
-        return (len(x) == len(y) and all(np.shape(x_i) == np.shape(y_i)
-                                         for x_i, y_i in zip(x, y)))
-
-
-def _default_values_like(old_values, value=None, upper=None):
-    """Creates a range of default values with the same shape as the input
-    `old_values`. If `value` is provided then each entry will equal `value`;
-    if `upper` is provided then the values will be linearly-spaced from 0 to
-    `upper`.
-
-    Parameters
-    ----------
-    old_values : (n,) or (p,n) array or list of (n,) arrays
-        Input array(s), typically time series measurements for which default
-        time or error values need to be inferred.
-    value : float, optional
-        Value that each output entry will be set to (omitted if `upper` is
-        provided).
-    upper : float, optional
-        Upper bound of range of linearly-spaced output entries (omitted if
-        `value` is provided).
-    """
-    if value and upper:
-        raise ValueError("Only one of `value` or `upper` may be proivded.")
-    elif value is not None:
-        lower = value
-        upper = value
-    elif upper is not None:
-        lower = 0.
-    else:
-        raise ValueError("Either `value` or `upper` must be provided.")
-
-    new_values = copy.deepcopy(old_values)
-    if _ndim(old_values) == 1 or (isinstance(old_values, np.ndarray) and 1 in
-                                  old_values.shape):
-        new_values[:] = np.linspace(lower, upper, len(new_values))
-    else:
-        for new_array in new_values:
-            new_array[:] = np.linspace(lower, upper, len(new_array))
-
-    return new_values
-
-
-def _make_array_if_possible(x):
-    """Helper function to cast (1, n) arrays to (n,) arrrays, or uniform lists
-    of arrays to (p, n) arrays.
-    """
-    try:
-        x = np.asfarray(x).squeeze()
-    except ValueError:
-        pass
-    return x
-
-
-def load(ts_path):
-    """Load serialized TimeSeries from .npz file."""
-    with np.load(ts_path) as npz_file:
-        data = dict(npz_file)
-
-    for key in ['time', 'measurement', 'error']:
-        if key not in data:  # combine channel arrays into list
-            n_channels = sum(1 for c in data.keys() if key in c)  # time0, ...
-            data[key] = [data[key + str(i)] for i in range(n_channels)]
-
-    # Convert 0d arrays to single values
-    if 'name' in data:
-        data['name'] = data['name'].item()
-    if 'label' in data:
-        data['label'] = data['label'].item()
-
-    return TimeSeries(t=data.get('time'), m=data.get('measurement'),
-                      e=data.get('error'),
-                      meta_features=dict(zip(data['meta_feat_names'],
-                                             data['meta_feat_values'])),
-                      name=data.get('name'), label=data.get('label'))
-
-
-class TimeSeries(object):
-    """Class representing a single time series of measurements and metadata.
-
-    A `TimeSeries` object encapsulates a single set of time-domain
-    measurements, along with any metadata describing the observation.
-    Typically the observations will consist of times, measurements, and
-    (optionally) measurement errors. The measurements can be scalar- or
-    vector-valued (i.e., "multichannel"); for multichannel measurements, the
-    times and errors can also be vector-valued, or they can be shared across
-    all channels of measurement.
-
-    Attributes
-    ----------
-    time : (n,) or (p, n) array or list of (n,) arrays
-        Array(s) of times corresponding to measurement values. If `measurement`
-        is two-dimensional, this can be one-dimensional (same times for each
-        channel) or two-dimensional (different times for each channel). If
-        `time` is one-dimensional then it will be broadcast to match
-        `measurement.shape`.
-    measurement : (n,) or (p, n) array or list of (n,) arrays
-        Array(s) of measurement values; can be two-dimensional for
-        multichannel data. In the case of multichannel data with different
-        numbers of measurements for each channel, `measurement` will be a list
-        of arrays instead of a single two-dimensional array.
-    error : (n,) or (p, n) array or list of (n,) arrays
-        Array(s) of measurement errors for each value. If `measurement` is
-        two-dimensional, this can be one-dimensional (same times for each
-        channel) or two-dimensional (different times for each channel).
-        If `error` is one-dimensional then it will be broadcast match
-        `measurement.shape`.
-    label : str, float, or None
-        Class label or regression target for the given time series (if
-        applicable).
-    meta_features : dict
-        Dictionary of feature names/values specified independently of the
-        featurization process in `featurize`.
-    name : str or None
-        Identifying name for the given time series (if applicable).
-        Typically the name of the raw data file from which the time series was
-        created.
-    path : str or None
-        Path to the file where the time series is stored on disk (if
-        applicable).
-    channel_names : list of str
-        List of names of channels of measurement; by default these are simply
-        `channel_{i}`, but can be arbitrary depending on the nature of the
-        different measurement channels.
-    """
-    def __init__(self, t=None, m=None, e=None, label=None, meta_features={},
-                 name=None, path=None, channel_names=None):
-        """Create a `TimeSeries` object from measurement values/metadata.
-
-        See `TimeSeries` documentation for parameter values.
-        """
-        if t is None and m is None:
-            raise ValueError("Either times or measurements must be provided.")
-        elif m is None:
-            m = _default_values_like(t, value=np.nan)
-
-        # If m is 1-dimensional, so are t and e
-        if _ndim(m) == 1:
-            self.n_channels = 1
-            if t is None:
-                t = _default_values_like(m, upper=DEFAULT_MAX_TIME)
-            if e is None:
-                e = _default_values_like(m, value=DEFAULT_ERROR_VALUE)
-        # If m is 2-dimensional, t and e could be 1d or 2d; default is 1d
-        elif isinstance(m, np.ndarray) and m.ndim == 2:
-            self.n_channels = len(m)
-            if t is None:
-                t = _default_values_like(m[0], upper=DEFAULT_MAX_TIME)
-            if e is None:
-                e = _default_values_like(m[0], value=DEFAULT_ERROR_VALUE)
-        # If m is ragged (list of 1d arrays), t and e should also be ragged
-        elif _ndim(m) == 2:
-            self.n_channels = len(m)
-            if t is None:
-                t = _default_values_like(m, upper=DEFAULT_MAX_TIME)
-            if e is None:
-                e = _default_values_like(m, value=DEFAULT_ERROR_VALUE)
-        else:
-            raise ValueError("m must be a 1D or 2D array, or a 2D list of"
-                             " arrays.")
-
-        self.time = _make_array_if_possible(t)
-        self.measurement = _make_array_if_possible(m)
-        self.error = _make_array_if_possible(e)
-        self.sort()  # re-order by time before broadcasting
-
-        if _ndim(self.time) == 1 and _ndim(self.measurement) == 2:
-            if isinstance(self.measurement, np.ndarray):
-                self.time = np.broadcast_to(self.time, self.measurement.shape)
-            else:
-                raise ValueError("Times for each channel must be provided if m"
-                                 " is a ragged array.")
-
-        if _ndim(self.error) == 1 and _ndim(self.measurement) == 2:
-            if isinstance(self.measurement, np.ndarray):
-                self.error = np.broadcast_to(self.error, self.measurement.shape)
-            else:
-                raise ValueError("Errors for each channel must be provided if"
-                                 " m is a ragged array.")
-
-        if not (_compatible_shapes(self.measurement, self.time) and
-                _compatible_shapes(self.measurement, self.error)):
-            raise ValueError("times, values, errors are not of compatible"
-                             " types/sizes. Please refer to the docstring"
-                             " for list of allowed input types.")
-
-        self.label = label
-        self.meta_features = dict(meta_features)
-        self.name = name
-        self.path = path
-        if channel_names is None:
-            self.channel_names = ["channel_{}".format(i)
-                                  for i in range(self.n_channels)]
-        else:
-            self.channel_names = channel_names
-
-    def channels(self):
-        """Iterates over measurement channels (whether one or multiple)."""
-        t_channels = self.time
-        m_channels = self.measurement
-        e_channels = self.error
-        if isinstance(self.time, np.ndarray) and self.time.ndim == 1:
-            t_channels = np.broadcast_to(self.time,
-                                         (self.n_channels, len(self.time)))
-        if (isinstance(self.measurement, np.ndarray) and
-                self.measurement.ndim == 1):
-            m_channels = np.broadcast_to(self.measurement,
-                                         (self.n_channels, len(self.measurement)))
-        if isinstance(self.error, np.ndarray) and self.error.ndim == 1:
-            e_channels = np.broadcast_to(self.error,
-                                         (self.n_channels, len(self.error)))
-        return zip(t_channels, m_channels, e_channels)
-
-    def sort(self):
-        """Sort times, measurements, and errors by time."""
-        if _ndim(self.time) == 1:
-            inds = np.argsort(self.time)
-            self.time = self.time[inds]
-            if _ndim(self.measurement) == 1:
-                self.measurement = self.measurement[inds]
-            else:
-                for i in range(len(self.measurement)):
-                   self.measurement[i] = self.measurement[i][inds]
-            if _ndim(self.error) == 1:
-                self.error = self.error[inds]
-            else:
-                for i in range(len(self.error)):
-                   self.error[i] = self.error[i][inds]
-        else:  # if time is 2d, so are measurement and error
-            for i in range(len(self.time)):
-                inds = np.argsort(self.time[i])
-                self.time[i] = self.time[i][inds]
-                self.measurement[i] = self.measurement[i][inds]
-                self.error[i] = self.error[i][inds]
-
-
-    def save(self, path=None):
-        """Store TimeSeries object as a single .npz file.
-
-        Attributes are stored in the following arrays:
-            - time
-            - measurement
-            - error
-            - meta_feat_names
-            - meta_feat_values
-            - name
-            - label
-
-        If `path` is omitted then the `path` attribute from the TimeSeries
-        object is used.
-        """
-        if path is None:
-            path = self.path
-
-        data = {'meta_feat_names': list(self.meta_features.keys()),
-                'meta_feat_values': list(self.meta_features.values())}
-
-        for key in ['time', 'measurement', 'error']:
-            value = getattr(self, key)
-            if isinstance(value, np.ndarray):
-                data[key] = value
-            else:  # list of arrays -> save each channel separately
-                for i, value_i in enumerate(value):
-                    data[key + str(i)] = value_i
-
-        if self.name:
-            data['name'] = self.name
-        if self.label:
-            data['label'] = self.label
-        np.savez(path, **data)
+import copy
+from collections import Iterable
+import numpy as np
+
+
+__all__ = ['load', 'TimeSeries', 'DEFAULT_MAX_TIME',
+           'DEFAULT_ERROR_VALUE']
+
+
+DEFAULT_MAX_TIME = 1.0
+DEFAULT_ERROR_VALUE = 1e-4
+
+
+def _ndim(x):
+    """Return number of dimensions for a (possibly ragged) array."""
+    n = 0
+    while isinstance(x, Iterable):
+        x = x[0]
+        n += 1
+    return n
+
+
+def _compatible_shapes(x, y):
+    """Check recursively that iterables x and y (and each iterable contained
+    within, if applicable), have compatible sizes.
+    """
+    if hasattr(x, 'shape') and hasattr(y, 'shape'):
+        return x.shape == y.shape
+    else:
+        return (len(x) == len(y) and all(np.shape(x_i) == np.shape(y_i)
+                                         for x_i, y_i in zip(x, y)))
+
+
+def _default_values_like(old_values, value=None, upper=None):
+    """Creates a range of default values with the same shape as the input
+    `old_values`. If `value` is provided then each entry will equal `value`;
+    if `upper` is provided then the values will be linearly-spaced from 0 to
+    `upper`.
+
+    Parameters
+    ----------
+    old_values : (n,) or (p,n) array or list of (n,) arrays
+        Input array(s), typically time series measurements for which default
+        time or error values need to be inferred.
+    value : float, optional
+        Value that each output entry will be set to (omitted if `upper` is
+        provided).
+    upper : float, optional
+        Upper bound of range of linearly-spaced output entries (omitted if
+        `value` is provided).
+    """
+    if value and upper:
+        raise ValueError("Only one of `value` or `upper` may be proivded.")
+    elif value is not None:
+        lower = value
+        upper = value
+    elif upper is not None:
+        lower = 0.
+    else:
+        raise ValueError("Either `value` or `upper` must be provided.")
+
+    new_values = copy.deepcopy(old_values)
+    if _ndim(old_values) == 1 or (isinstance(old_values, np.ndarray) and 1 in
+                                  old_values.shape):
+        new_values[:] = np.linspace(lower, upper, len(new_values))
+    else:
+        for new_array in new_values:
+            new_array[:] = np.linspace(lower, upper, len(new_array))
+
+    return new_values
+
+
+def _make_array_if_possible(x):
+    """Helper function to cast (1, n) arrays to (n,) arrrays, or uniform lists
+    of arrays to (p, n) arrays.
+    """
+    try:
+        x = np.asfarray(x).squeeze()
+    except ValueError:
+        pass
+    return x
+
+
+def load(ts_path):
+    """Load serialized TimeSeries from .npz file."""
+    with np.load(ts_path) as npz_file:
+        data = dict(npz_file)
+
+    for key in ['time', 'measurement', 'error']:
+        if key not in data:  # combine channel arrays into list
+            n_channels = sum(1 for c in data.keys() if key in c)  # time0, ...
+            data[key] = [data[key + str(i)] for i in range(n_channels)]
+
+    # Convert 0d arrays to single values
+    if 'name' in data:
+        data['name'] = data['name'].item()
+    if 'label' in data:
+        data['label'] = data['label'].item()
+
+    return TimeSeries(t=data.get('time'), m=data.get('measurement'),
+                      e=data.get('error'),
+                      meta_features=dict(zip(data['meta_feat_names'],
+                                             data['meta_feat_values'])),
+                      name=data.get('name'), label=data.get('label'))
+
+
+class TimeSeries(object):
+    """Class representing a single time series of measurements and metadata.
+
+    A `TimeSeries` object encapsulates a single set of time-domain
+    measurements, along with any metadata describing the observation.
+    Typically the observations will consist of times, measurements, and
+    (optionally) measurement errors. The measurements can be scalar- or
+    vector-valued (i.e., "multichannel"); for multichannel measurements, the
+    times and errors can also be vector-valued, or they can be shared across
+    all channels of measurement.
+
+    Attributes
+    ----------
+    time : (n,) or (p, n) array or list of (n,) arrays
+        Array(s) of times corresponding to measurement values. If `measurement`
+        is two-dimensional, this can be one-dimensional (same times for each
+        channel) or two-dimensional (different times for each channel). If
+        `time` is one-dimensional then it will be broadcast to match
+        `measurement.shape`.
+    measurement : (n,) or (p, n) array or list of (n,) arrays
+        Array(s) of measurement values; can be two-dimensional for
+        multichannel data. In the case of multichannel data with different
+        numbers of measurements for each channel, `measurement` will be a list
+        of arrays instead of a single two-dimensional array.
+    error : (n,) or (p, n) array or list of (n,) arrays
+        Array(s) of measurement errors for each value. If `measurement` is
+        two-dimensional, this can be one-dimensional (same times for each
+        channel) or two-dimensional (different times for each channel).
+        If `error` is one-dimensional then it will be broadcast match
+        `measurement.shape`.
+    label : str, float, or None
+        Class label or regression target for the given time series (if
+        applicable).
+    meta_features : dict
+        Dictionary of feature names/values specified independently of the
+        featurization process in `featurize`.
+    name : str or None
+        Identifying name for the given time series (if applicable).
+        Typically the name of the raw data file from which the time series was
+        created.
+    path : str or None
+        Path to the file where the time series is stored on disk (if
+        applicable).
+    channel_names : list of str
+        List of names of channels of measurement; by default these are simply
+        `channel_{i}`, but can be arbitrary depending on the nature of the
+        different measurement channels.
+    """
+    def __init__(self, t=None, m=None, e=None, label=None, meta_features={},
+                 name=None, path=None, channel_names=None):
+        """Create a `TimeSeries` object from measurement values/metadata.
+
+        See `TimeSeries` documentation for parameter values.
+        """
+        if t is None and m is None:
+            raise ValueError("Either times or measurements must be provided.")
+        elif m is None:
+            m = _default_values_like(t, value=np.nan)
+
+        # If m is 1-dimensional, so are t and e
+        if _ndim(m) == 1:
+            self.n_channels = 1
+            if t is None:
+                t = _default_values_like(m, upper=DEFAULT_MAX_TIME)
+            if e is None:
+                e = _default_values_like(m, value=DEFAULT_ERROR_VALUE)
+        # If m is 2-dimensional, t and e could be 1d or 2d; default is 1d
+        elif isinstance(m, np.ndarray) and m.ndim == 2:
+            self.n_channels = len(m)
+            if t is None:
+                t = _default_values_like(m[0], upper=DEFAULT_MAX_TIME)
+            if e is None:
+                e = _default_values_like(m[0], value=DEFAULT_ERROR_VALUE)
+        # If m is ragged (list of 1d arrays), t and e should also be ragged
+        elif _ndim(m) == 2:
+            self.n_channels = len(m)
+            if t is None:
+                t = _default_values_like(m, upper=DEFAULT_MAX_TIME)
+            if e is None:
+                e = _default_values_like(m, value=DEFAULT_ERROR_VALUE)
+        else:
+            raise ValueError("m must be a 1D or 2D array, or a 2D list of"
+                             " arrays.")
+
+        self.time = _make_array_if_possible(t)
+        self.measurement = _make_array_if_possible(m)
+        self.error = _make_array_if_possible(e)
+        self.sort()  # re-order by time before broadcasting
+
+        if _ndim(self.time) == 1 and _ndim(self.measurement) == 2:
+            if isinstance(self.measurement, np.ndarray):
+                self.time = np.broadcast_to(self.time, self.measurement.shape)
+            else:
+                raise ValueError("Times for each channel must be provided if m"
+                                 " is a ragged array.")
+
+        if _ndim(self.error) == 1 and _ndim(self.measurement) == 2:
+            if isinstance(self.measurement, np.ndarray):
+                self.error = np.broadcast_to(self.error, self.measurement.shape)
+            else:
+                raise ValueError("Errors for each channel must be provided if"
+                                 " m is a ragged array.")
+
+        if not (_compatible_shapes(self.measurement, self.time) and
+                _compatible_shapes(self.measurement, self.error)):
+            raise ValueError("times, values, errors are not of compatible"
+                             " types/sizes. Please refer to the docstring"
+                             " for list of allowed input types.")
+
+        self.label = label
+        self.meta_features = dict(meta_features)
+        self.name = name
+        self.path = path
+        if channel_names is None:
+            self.channel_names = ["channel_{}".format(i)
+                                  for i in range(self.n_channels)]
+        else:
+            self.channel_names = channel_names
+
+    def channels(self):
+        """Iterates over measurement channels (whether one or multiple)."""
+        t_channels = self.time
+        m_channels = self.measurement
+        e_channels = self.error
+        if isinstance(self.time, np.ndarray) and self.time.ndim == 1:
+            t_channels = np.broadcast_to(self.time,
+                                         (self.n_channels, len(self.time)))
+        if (isinstance(self.measurement, np.ndarray) and
+                self.measurement.ndim == 1):
+            m_channels = np.broadcast_to(self.measurement,
+                                         (self.n_channels, len(self.measurement)))
+        if isinstance(self.error, np.ndarray) and self.error.ndim == 1:
+            e_channels = np.broadcast_to(self.error,
+                                         (self.n_channels, len(self.error)))
+        return zip(t_channels, m_channels, e_channels)
+
+    def sort(self):
+        """Sort times, measurements, and errors by time."""
+        if _ndim(self.time) == 1:
+            inds = np.argsort(self.time)
+            self.time = self.time[inds]
+            if _ndim(self.measurement) == 1:
+                self.measurement = self.measurement[inds]
+            else:
+                for i in range(len(self.measurement)):
+                   self.measurement[i] = self.measurement[i][inds]
+            if _ndim(self.error) == 1:
+                self.error = self.error[inds]
+            else:
+                for i in range(len(self.error)):
+                   self.error[i] = self.error[i][inds]
+        else:  # if time is 2d, so are measurement and error
+            for i in range(len(self.time)):
+                inds = np.argsort(self.time[i])
+                self.time[i] = self.time[i][inds]
+                self.measurement[i] = self.measurement[i][inds]
+                self.error[i] = self.error[i][inds]
+
+
+    def save(self, path=None):
+        """Store TimeSeries object as a single .npz file.
+
+        Attributes are stored in the following arrays:
+            - time
+            - measurement
+            - error
+            - meta_feat_names
+            - meta_feat_values
+            - name
+            - label
+
+        If `path` is omitted then the `path` attribute from the TimeSeries
+        object is used.
+        """
+        if path is None:
+            path = self.path
+
+        data = {'meta_feat_names': list(self.meta_features.keys()),
+                'meta_feat_values': list(self.meta_features.values())}
+
+        for key in ['time', 'measurement', 'error']:
+            value = getattr(self, key)
+            if isinstance(value, np.ndarray):
+                data[key] = value
+            else:  # list of arrays -> save each channel separately
+                for i, value_i in enumerate(value):
+                    data[key + str(i)] = value_i
+
+        if self.name:
+            data['name'] = self.name
+        if self.label:
+            data['label'] = self.label
+        np.savez(path, **data)
```

### Comparing `cesium-0.9.7/cesium/featurize.py` & `cesium-0.9.9/cesium/featurize.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,452 +1,452 @@
-import copy
-from collections import Iterable
-import numpy as np
-import pandas as pd
-import dask
-import dask.threaded
-from dask import delayed
-from dask.compatibility import reraise
-from dask.threaded import pack_exception
-from sklearn.preprocessing import Imputer
-
-from . import time_series
-from .time_series import TimeSeries
-from .features import generate_dask_graph
-
-__all__ = ['featurize_time_series', 'featurize_single_ts',
-           'featurize_ts_files', 'assemble_featureset']
-
-
-def featurize_single_ts(ts, features_to_use, custom_script_path=None,
-                        custom_functions=None, raise_exceptions=True):
-    """Compute feature values for a given single time-series. Data is
-    returned as dictionaries/lists of lists.
-
-    Parameters
-    ----------
-    ts : TimeSeries object
-        Single time series to be featurized.
-    features_to_use : list of str
-        List of feature names to be generated.
-    custom_functions : dict, optional
-        Dictionary of custom feature functions to be evaluated for the given
-        time series, or a dictionary representing a dask graph of function
-        evaluations. Dictionaries of functions should have keys `feature_name`
-        and values functions that take arguments (t, m, e); in the case of a
-        dask graph, these arrays should be referenced as 't', 'm', 'e',
-        respectively, and any values with keys present in `features_to_use`
-        will be computed.
-    raise_exceptions : bool, optional
-        If True, exceptions during feature computation are raised immediately;
-        if False, exceptions are supressed and `np.nan` is returned for the
-        given feature and any dependent features. Defaults to True.
-
-    Returns
-    -------
-    dict
-        Dictionary with feature names as keys, lists of feature values (one per
-        channel) as values.
-    """
-    # Initialize empty feature array for all channels
-    feature_values = np.empty((len(features_to_use), ts.n_channels))
-    for (t_i, m_i, e_i), i in zip(ts.channels(), range(ts.n_channels)):
-        feature_graph = generate_dask_graph(t_i, m_i, e_i)
-        feature_graph.update(ts.meta_features)
-
-        if custom_functions:
-            # If values in custom_functions are functions, add calls to graph
-            if all(hasattr(v, '__call__') for v in custom_functions.values()):
-                feature_graph.update({feat: f(t_i, m_i, e_i)
-                                      for feat, f in custom_functions.items()})
-            # Otherwise, custom_functions is another dask graph
-            else:
-                feature_graph.update(custom_functions)
-
-        # Do not execute in parallel; parallelization has already taken place
-        # at the level of time series, so we compute features for a single time
-        # series in serial.
-        if raise_exceptions:
-            raise_callback = reraise
-        else:
-            raise_callback = lambda e, tb: None
-        dask_values = dask.get(feature_graph, features_to_use,
-                               raise_exception=raise_callback,
-                               pack_exception=pack_exception)
-        feature_values[:, i] = [x if not isinstance(x, Exception) else np.nan
-                                for x in dask_values]
-    index = pd.MultiIndex.from_product((features_to_use, range(ts.n_channels)),
-                                       names=('feature', 'channel'))
-    return pd.Series(feature_values.ravel(), index=index)
-
-
-def assemble_featureset(features_list, time_series=None,
-                        meta_features_list=None, names=None):
-    """Transforms raw feature data (as returned by `featurize_single_ts`) into
-    a pd.DataFrame.
-
-    Parameters
-    ----------
-    features_list : list of pd.Series
-        List of series (one per time series file) with (feature name, channel)
-        multiindex.
-    time_series : list of TimeSeries
-        If provided, the name and metafeatures from the time series objects
-        will be used, overriding the `meta_features_list` and `names` values.
-    meta_features_list : list of dict
-        If provided, the columns of `metadata` will be added to the featureset.
-    names : list of str
-        If provided, the (row) index of the featureset will be set accordingly.
-
-    Returns
-    -------
-    pd.DataFrame
-        DataFrame with columns containing feature values, indexed by name.
-    """
-    if time_series is not None:
-        meta_features_list, names = zip(*[(ts.meta_features, ts.name)
-                                          for ts in time_series])
-    if len(features_list) > 0:
-        feat_df = pd.concat(features_list, axis=1, ignore_index=True).T
-        feat_df.index = names
-    else:
-        feat_df = pd.DataFrame(index=names)
-
-    if meta_features_list and any(meta_features_list):  # not all empty dicts
-        meta_df = pd.DataFrame(list(meta_features_list), index=names)
-        meta_df.columns = pd.MultiIndex.from_tuples([(c, '') for c in meta_df],
-                                                    names=['feature', 'channel'])
-        feat_df = pd.concat((feat_df, meta_df), axis=1)
-
-    return feat_df
-
-
-# TODO should this be changed to use TimeSeries objects? or maybe an optional
-# argument for TimeSeries? some redundancy here...
-def featurize_time_series(times, values, errors=None, features_to_use=[],
-                          meta_features={}, names=None,
-                          custom_script_path=None, custom_functions=None,
-                          scheduler=dask.threaded.get, raise_exceptions=True):
-    """Versatile feature generation function for one or more time series.
-
-    For a single time series, inputs may have the form:
-
-    - `times`:  (n,) array or (p, n) array (for p channels of measurement)
-    - `values`: (n,) array or (p, n) array (for p channels of measurement)
-    - `errors`: (n,) array or (p, n) array (for p channels of measurement)
-
-    For multiple time series, inputs may have the form:
-
-    - `times`: list of (n,) arrays, list of (p, n) arrays (for p channels of
-      measurement), or list of lists of (n,) arrays (for
-      multichannel data with different time values per channel)
-    - `values`: list of (n,) arrays, list of (p, n) arrays (for p channels of
-      measurement), or list of lists of (n,) arrays (for
-      multichannel data with different time values per channel)
-    - `errors`: list of (n,) arrays, list of (p, n) arrays (for p channels of
-      measurement), or list of lists of (n,) arrays (for
-      multichannel data with different time values per channel)
-
-    In the case of multichannel measurements, each channel will be
-    featurized separately, and the index of the output featureset will contain
-    a `channel` coordinate.
-
-    Parameters
-    ----------
-    times : array, list of array, or list of lists of array
-        Array containing time values for a single time series, or a list of
-        arrays each containing time values for a single time series, or a list
-        of lists of arrays for multichannel data with different time values per
-        channel
-    values : array or list of array
-        Array containing measurement values for a single time series, or a list
-        of arrays each containing (possibly multivariate) measurement values
-        for a single time series, or a list of lists of arrays for multichannel
-        data with different time values per channel
-    errors : array or list/tuple of array, optional
-        Array containing measurement error values for a single time series, or
-        a list of arrays each containing (possibly multivariate) measurement
-        values for a single time series, or a list of lists of arrays for
-        multichannel data with different time values per channel
-    features_to_use : list of str, optional
-        List of feature names to be generated. Defaults to an empty list, which
-        will result in only meta_features features being stored.
-    meta_features : dict/Pandas.Series or list of dicts/Pandas.DataFrame
-        dict/Series (for a single time series) or DataFrame (for multiple time
-        series) of metafeature information; features are added to the output
-        featureset, and their values are consumable by custom feature scripts.
-    names : str or list of str, optional
-        Name or list of names for each time series, if applicable; will be
-        stored in the (row) index of the featureset.
-    custom_script_path : str, optional
-        Path to Python script containing function definitions for the
-        generation of any custom features. Defaults to None.
-    custom_functions : dict, optional
-        Dictionary of custom feature functions to be evaluated for the given
-        time series, or a dictionary representing a dask graph of function
-        evaluations.  Dictionaries of functions should have keys `feature_name`
-        and values functions that take arguments (t, m, e); in the case of a
-        dask graph, these arrays should be referenced as 't', 'm', 'e',
-        respectively, and any values with keys present in `features_to_use`
-        will be computed.
-    scheduler : function, optional
-        `dask` scheduler function used to perform feature extraction
-        computation. Defaults to `dask.threaded.get`.
-    raise_exceptions : bool, optional
-        If True, exceptions during feature computation are raised immediately;
-        if False, exceptions are supressed and `np.nan` is returned for the
-        given feature and any dependent features. Defaults to True.
-
-    Returns
-    -------
-    pd.DataFrame
-        DataFrame with columns containing feature values, indexed by name.
-    """
-    if times is None:
-        times = copy.deepcopy(values)
-        if isinstance(times, np.ndarray) and (times.ndim == 1
-                                              or 1 in times.shape):
-            times[:] = np.linspace(0., time_series.DEFAULT_MAX_TIME,
-                                   times.size)
-        else:
-            for t in times:
-                if isinstance(t, np.ndarray) and (t.ndim == 1 or 1 in t.shape):
-                    t[:] = np.linspace(0., time_series.DEFAULT_MAX_TIME,
-                                       t.size)
-                else:
-                    for t_i in t:
-                        t_i[:] = np.linspace(0., time_series.DEFAULT_MAX_TIME,
-                                             t_i.size)
-
-    if errors is None:
-        errors = copy.deepcopy(values)
-        if isinstance(errors, np.ndarray) and (errors.ndim == 1
-                                               or 1 in errors.shape):
-            errors[:] = time_series.DEFAULT_ERROR_VALUE
-        else:
-            for e in errors:
-                if isinstance(e, np.ndarray) and (e.ndim == 1 or 1 in e.shape):
-                    e[:] = time_series.DEFAULT_ERROR_VALUE
-                else:
-                    for e_i in e:
-                        e_i[:] = time_series.DEFAULT_ERROR_VALUE
-
-    # One single-channel time series:
-    if not isinstance(values[0], Iterable):
-        times, values, errors = [times], [values], [errors]
-    # One multi-channel time series:
-    elif isinstance(values, np.ndarray) and values.ndim == 2:
-        times, values, errors = [times], [values], [errors]
-
-    if names is None:
-        names = np.arange(len(times))
-
-    if isinstance(meta_features, pd.Series):
-        meta_features = meta_features.to_dict()
-    meta_features = pd.DataFrame(meta_features, index=names)
-
-    all_time_series = [delayed(TimeSeries(t, m, e,
-                                          meta_features=meta_features.loc[name],
-                                          name=name), pure=True)
-                       for t, m, e, name in zip(times, values, errors, names)]
-
-    all_features = [delayed(featurize_single_ts, pure=True)(ts, features_to_use,
-                                                            custom_script_path,
-                                                            custom_functions,
-                                                            raise_exceptions)
-                    for ts in all_time_series]
-    result = delayed(assemble_featureset, pure=True)(all_features, all_time_series)
-    return result.compute(get=scheduler)
-
-
-def featurize_ts_files(ts_paths, features_to_use, custom_script_path=None,
-                       custom_functions=None, scheduler=dask.threaded.get,
-                       raise_exceptions=True):
-    """Feature generation function for on-disk time series (.npz) files.
-
-    By default, computes features concurrently using the
-    `dask.threaded.get` scheduler. Other possible options include
-    `dask.local.get` for synchronous computation (e.g., when debugging),
-    or `dask.distributed.Executor.get` for distributed computation.
-
-    In the case of multichannel measurements, each channel will be
-    featurized separately, and the index of the output featureset will contain
-    a `channel` coordinate.
-
-    Parameters
-    ----------
-    ts_paths : list of str
-        List of paths to time series data, stored in `numpy` .npz format.
-        See `time_series.load` for details.
-    features_to_use : list of str, optional
-        List of feature names to be generated. Defaults to an empty list, which
-        will result in only meta_features features being stored.
-    custom_script_path : str, optional
-        Path to Python script containing function definitions for the
-        generation of any custom features. Defaults to None.
-    custom_functions : dict, optional
-        Dictionary of custom feature functions to be evaluated for the given
-        time series, or a dictionary representing a dask graph of function
-        evaluations.  Dictionaries of functions should have keys `feature_name`
-        and values functions that take arguments (t, m, e); in the case of a
-        dask graph, these arrays should be referenced as 't', 'm', 'e',
-        respectively, and any values with keys present in `features_to_use`
-        will be computed.
-    scheduler : function, optional
-        `dask` scheduler function used to perform feature extraction
-        computation. Defaults to `dask.threaded.get`.
-    raise_exceptions : bool, optional
-        If True, exceptions during feature computation are raised immediately;
-        if False, exceptions are supressed and `np.nan` is returned for the
-        given feature and any dependent features. Defaults to True.
-
-    Returns
-    -------
-    pd.DataFrame
-        DataFrame with columns containing feature values, indexed by name.
-    """
-    all_time_series = [delayed(time_series.load, pure=True)(ts_path)
-                       for ts_path in ts_paths]
-    all_features = [delayed(featurize_single_ts, pure=True)(ts, features_to_use,
-                                                            custom_script_path,
-                                                            custom_functions,
-                                                            raise_exceptions)
-                    for ts in all_time_series]
-    names, meta_feats, all_labels = zip(*[(ts.name, ts.meta_features, ts.label)
-                                          for ts in all_time_series])
-    result = delayed(assemble_featureset, pure=True)(all_features,
-                                                     meta_features_list=meta_feats,
-                                                     names=names)
-    fset, labels = dask.compute(result, all_labels, get=scheduler)
-
-    return fset, labels
-
-
-def impute_featureset(fset, strategy='constant', value=None, max_value=1e20,
-                      inplace=False):
-    """Replace NaN/Inf values with imputed values as defined by `strategy`.
-    Output should satisfy `sklearn.validation.assert_all_finite` so that
-    training a model will not produce an error.
-
-    Parameters
-    ----------
-    strategy : str, optional
-    The imputation strategy. Defaults to 'constant'.
-
-        - 'constant': replace all missing with `value`
-        - 'mean': replace all missing with mean along `axis`
-        - 'median': replace all missing with median along `axis`
-        - 'most_frequent': replace all missing with mode along `axis`
-
-    value : float or None, optional
-        Replacement value to use for `strategy='constant'`. Defaults to
-        `None`, in which case a very large negative value is used (a
-        good choice for e.g. random forests).
-
-    max_value : float, optional
-        Maximum (absolute) value above which values are treated as infinite.
-        Used to prevent overflow when fitting `sklearn` models.
-
-    inplace : bool, optional
-        If True, fill in place. If False, return a copy.
-
-    Returns
-    -------
-    pd.DataFrame
-        Feature data frame wth no missing/infinite values.
-    """
-    if not inplace:
-        fset = fset.copy()
-    fset.values[np.isnan(fset.values)] = np.inf  # avoid NaN comparison warnings
-    fset.values[np.abs(fset.values) > max_value] = np.nan
-    if strategy == 'constant':
-        if value is None:
-            # If no fill-in value is provided, use a large negative value
-            value = -2. * np.nanmax(np.abs(fset.values))
-        fset.fillna(value, inplace=True)
-    elif strategy in ('mean', 'median', 'most_frequent'):
-        imputer = Imputer(strategy=strategy, axis=0)
-        fset.values[:] = imputer.fit_transform(fset.values)
-    else:
-        raise NotImplementedError("Imputation strategy '{}' not"
-                                  "recognized.".format(strategy))
-    return fset
-
-
-def save_featureset(fset, path, **kwargs):
-    """Save feature DataFrame in .npz format.
-
-    Can optionally store class labels/targets and other metadata. All other
-    keyword arguments will be passed on to `np.savez`; data frames are saved as
-    record arrays and converted back into data frames by `load_featureset`.
-
-    Parameters
-    ----------
-    fset : pd.DataFrame
-        Feature data frame to be saved.
-    path : str
-        Path to store feature data.
-    kwargs : dict of array or data frame
-        Additional keyword arguments, e.g.:
-        labels -> class labels
-        preds -> predicted class labels
-        pred_probs -> (n_sample, n_class) data frame of class probabilities
-    """
-    # Transpose to properly handle MultiIndex columns
-    kwargs['features'] = fset.T
-
-    for k, v in kwargs.items():
-        if isinstance(v, pd.DataFrame):
-            arr = v.to_records()
-            dt_list = arr.dtype.descr
-            # Change type of indices from object to str
-            for i, (name, dt) in enumerate(dt_list):
-                if dt.endswith('O'):
-                    size = max(len(x) for x in arr['index'])
-                    dt_list[i] = (name, 'U' + str(size))
-                dt_list[i] = (str(name),) + dt_list[i][1:]  # avoid Py2 unicode
-            kwargs[k] = arr.astype(dt_list)
-
-        # Ignore null values, e.g. for unlabeled data
-        if all(el is None for el in v):
-            kwargs[k] = []
-
-    # Bypass savez to allow for `allow_pickle` keyword
-    # See https://github.com/numpy/numpy/pull/5770
-    np.lib.npyio._savez(path, [], kwargs, compress=True, allow_pickle=False)
-
-
-def load_featureset(path):
-    """Load feature DataFrame from .npz file.
-
-    Feature information is returned as a single DataFrame, while any other
-    arrays that were saved (class labels/predictions, etc.) are returned in a
-    single dictionary.
-
-    Parameters
-    ----------
-    path : str
-        Path where feature data is stored.
-
-    Returns
-    -------
-    pd.DataFrame
-        Feature data frame to be saved.
-    dict
-        Additional variables passed to `save_featureset`, including labels, etc.
-    """
-    with np.load(path, allow_pickle=False) as npz_file:
-        data = dict(npz_file)
-
-    # Transpose to properly handle MultiIndex columns
-    fset = pd.DataFrame.from_records(data.pop('features'),
-                                     index=['feature', 'channel']).T
-    features, channels = zip(*fset.columns)
-    channels = [int(c) if str(c).isdigit() else '' for c in channels]
-    fset.columns = pd.MultiIndex.from_tuples(list(zip(features, channels)),
-                                             names=['feature', 'channel'])
-
-    for k, v in data.items():
-        if len(v.dtype) > 0:
-            data[k] = pd.DataFrame.from_records(v, index='index')
-
-    return fset, data
+import copy
+from collections import Iterable
+import numpy as np
+import pandas as pd
+import dask
+import dask.threaded
+from dask import delayed
+from dask.compatibility import reraise
+from dask.threaded import pack_exception
+from sklearn.preprocessing import Imputer
+
+from . import time_series
+from .time_series import TimeSeries
+from .features import generate_dask_graph
+
+__all__ = ['featurize_time_series', 'featurize_single_ts',
+           'featurize_ts_files', 'assemble_featureset']
+
+
+def featurize_single_ts(ts, features_to_use, custom_script_path=None,
+                        custom_functions=None, raise_exceptions=True):
+    """Compute feature values for a given single time-series. Data is
+    returned as dictionaries/lists of lists.
+
+    Parameters
+    ----------
+    ts : TimeSeries object
+        Single time series to be featurized.
+    features_to_use : list of str
+        List of feature names to be generated.
+    custom_functions : dict, optional
+        Dictionary of custom feature functions to be evaluated for the given
+        time series, or a dictionary representing a dask graph of function
+        evaluations. Dictionaries of functions should have keys `feature_name`
+        and values functions that take arguments (t, m, e); in the case of a
+        dask graph, these arrays should be referenced as 't', 'm', 'e',
+        respectively, and any values with keys present in `features_to_use`
+        will be computed.
+    raise_exceptions : bool, optional
+        If True, exceptions during feature computation are raised immediately;
+        if False, exceptions are supressed and `np.nan` is returned for the
+        given feature and any dependent features. Defaults to True.
+
+    Returns
+    -------
+    dict
+        Dictionary with feature names as keys, lists of feature values (one per
+        channel) as values.
+    """
+    # Initialize empty feature array for all channels
+    feature_values = np.empty((len(features_to_use), ts.n_channels))
+    for (t_i, m_i, e_i), i in zip(ts.channels(), range(ts.n_channels)):
+        feature_graph = generate_dask_graph(t_i, m_i, e_i)
+        feature_graph.update(ts.meta_features)
+
+        if custom_functions:
+            # If values in custom_functions are functions, add calls to graph
+            if all(hasattr(v, '__call__') for v in custom_functions.values()):
+                feature_graph.update({feat: f(t_i, m_i, e_i)
+                                      for feat, f in custom_functions.items()})
+            # Otherwise, custom_functions is another dask graph
+            else:
+                feature_graph.update(custom_functions)
+
+        # Do not execute in parallel; parallelization has already taken place
+        # at the level of time series, so we compute features for a single time
+        # series in serial.
+        if raise_exceptions:
+            raise_callback = reraise
+        else:
+            raise_callback = lambda e, tb: None
+        dask_values = dask.get(feature_graph, features_to_use,
+                               raise_exception=raise_callback,
+                               pack_exception=pack_exception)
+        feature_values[:, i] = [x if not isinstance(x, Exception) else np.nan
+                                for x in dask_values]
+    index = pd.MultiIndex.from_product((features_to_use, range(ts.n_channels)),
+                                       names=('feature', 'channel'))
+    return pd.Series(feature_values.ravel(), index=index)
+
+
+def assemble_featureset(features_list, time_series=None,
+                        meta_features_list=None, names=None):
+    """Transforms raw feature data (as returned by `featurize_single_ts`) into
+    a pd.DataFrame.
+
+    Parameters
+    ----------
+    features_list : list of pd.Series
+        List of series (one per time series file) with (feature name, channel)
+        multiindex.
+    time_series : list of TimeSeries
+        If provided, the name and metafeatures from the time series objects
+        will be used, overriding the `meta_features_list` and `names` values.
+    meta_features_list : list of dict
+        If provided, the columns of `metadata` will be added to the featureset.
+    names : list of str
+        If provided, the (row) index of the featureset will be set accordingly.
+
+    Returns
+    -------
+    pd.DataFrame
+        DataFrame with columns containing feature values, indexed by name.
+    """
+    if time_series is not None:
+        meta_features_list, names = zip(*[(ts.meta_features, ts.name)
+                                          for ts in time_series])
+    if len(features_list) > 0:
+        feat_df = pd.concat(features_list, axis=1, ignore_index=True).T
+        feat_df.index = names
+    else:
+        feat_df = pd.DataFrame(index=names)
+
+    if meta_features_list and any(meta_features_list):  # not all empty dicts
+        meta_df = pd.DataFrame(list(meta_features_list), index=names)
+        meta_df.columns = pd.MultiIndex.from_tuples([(c, '') for c in meta_df],
+                                                    names=['feature', 'channel'])
+        feat_df = pd.concat((feat_df, meta_df), axis=1)
+
+    return feat_df
+
+
+# TODO should this be changed to use TimeSeries objects? or maybe an optional
+# argument for TimeSeries? some redundancy here...
+def featurize_time_series(times, values, errors=None, features_to_use=[],
+                          meta_features={}, names=None,
+                          custom_script_path=None, custom_functions=None,
+                          scheduler=dask.threaded.get, raise_exceptions=True):
+    """Versatile feature generation function for one or more time series.
+
+    For a single time series, inputs may have the form:
+
+    - `times`:  (n,) array or (p, n) array (for p channels of measurement)
+    - `values`: (n,) array or (p, n) array (for p channels of measurement)
+    - `errors`: (n,) array or (p, n) array (for p channels of measurement)
+
+    For multiple time series, inputs may have the form:
+
+    - `times`: list of (n,) arrays, list of (p, n) arrays (for p channels of
+      measurement), or list of lists of (n,) arrays (for
+      multichannel data with different time values per channel)
+    - `values`: list of (n,) arrays, list of (p, n) arrays (for p channels of
+      measurement), or list of lists of (n,) arrays (for
+      multichannel data with different time values per channel)
+    - `errors`: list of (n,) arrays, list of (p, n) arrays (for p channels of
+      measurement), or list of lists of (n,) arrays (for
+      multichannel data with different time values per channel)
+
+    In the case of multichannel measurements, each channel will be
+    featurized separately, and the index of the output featureset will contain
+    a `channel` coordinate.
+
+    Parameters
+    ----------
+    times : array, list of array, or list of lists of array
+        Array containing time values for a single time series, or a list of
+        arrays each containing time values for a single time series, or a list
+        of lists of arrays for multichannel data with different time values per
+        channel
+    values : array or list of array
+        Array containing measurement values for a single time series, or a list
+        of arrays each containing (possibly multivariate) measurement values
+        for a single time series, or a list of lists of arrays for multichannel
+        data with different time values per channel
+    errors : array or list/tuple of array, optional
+        Array containing measurement error values for a single time series, or
+        a list of arrays each containing (possibly multivariate) measurement
+        values for a single time series, or a list of lists of arrays for
+        multichannel data with different time values per channel
+    features_to_use : list of str, optional
+        List of feature names to be generated. Defaults to an empty list, which
+        will result in only meta_features features being stored.
+    meta_features : dict/Pandas.Series or list of dicts/Pandas.DataFrame
+        dict/Series (for a single time series) or DataFrame (for multiple time
+        series) of metafeature information; features are added to the output
+        featureset, and their values are consumable by custom feature scripts.
+    names : str or list of str, optional
+        Name or list of names for each time series, if applicable; will be
+        stored in the (row) index of the featureset.
+    custom_script_path : str, optional
+        Path to Python script containing function definitions for the
+        generation of any custom features. Defaults to None.
+    custom_functions : dict, optional
+        Dictionary of custom feature functions to be evaluated for the given
+        time series, or a dictionary representing a dask graph of function
+        evaluations.  Dictionaries of functions should have keys `feature_name`
+        and values functions that take arguments (t, m, e); in the case of a
+        dask graph, these arrays should be referenced as 't', 'm', 'e',
+        respectively, and any values with keys present in `features_to_use`
+        will be computed.
+    scheduler : function, optional
+        `dask` scheduler function used to perform feature extraction
+        computation. Defaults to `dask.threaded.get`.
+    raise_exceptions : bool, optional
+        If True, exceptions during feature computation are raised immediately;
+        if False, exceptions are supressed and `np.nan` is returned for the
+        given feature and any dependent features. Defaults to True.
+
+    Returns
+    -------
+    pd.DataFrame
+        DataFrame with columns containing feature values, indexed by name.
+    """
+    if times is None:
+        times = copy.deepcopy(values)
+        if isinstance(times, np.ndarray) and (times.ndim == 1
+                                              or 1 in times.shape):
+            times[:] = np.linspace(0., time_series.DEFAULT_MAX_TIME,
+                                   times.size)
+        else:
+            for t in times:
+                if isinstance(t, np.ndarray) and (t.ndim == 1 or 1 in t.shape):
+                    t[:] = np.linspace(0., time_series.DEFAULT_MAX_TIME,
+                                       t.size)
+                else:
+                    for t_i in t:
+                        t_i[:] = np.linspace(0., time_series.DEFAULT_MAX_TIME,
+                                             t_i.size)
+
+    if errors is None:
+        errors = copy.deepcopy(values)
+        if isinstance(errors, np.ndarray) and (errors.ndim == 1
+                                               or 1 in errors.shape):
+            errors[:] = time_series.DEFAULT_ERROR_VALUE
+        else:
+            for e in errors:
+                if isinstance(e, np.ndarray) and (e.ndim == 1 or 1 in e.shape):
+                    e[:] = time_series.DEFAULT_ERROR_VALUE
+                else:
+                    for e_i in e:
+                        e_i[:] = time_series.DEFAULT_ERROR_VALUE
+
+    # One single-channel time series:
+    if not isinstance(values[0], Iterable):
+        times, values, errors = [times], [values], [errors]
+    # One multi-channel time series:
+    elif isinstance(values, np.ndarray) and values.ndim == 2:
+        times, values, errors = [times], [values], [errors]
+
+    if names is None:
+        names = np.arange(len(times))
+
+    if isinstance(meta_features, pd.Series):
+        meta_features = meta_features.to_dict()
+    meta_features = pd.DataFrame(meta_features, index=names)
+
+    all_time_series = [delayed(TimeSeries(t, m, e,
+                                          meta_features=meta_features.loc[name],
+                                          name=name), pure=True)
+                       for t, m, e, name in zip(times, values, errors, names)]
+
+    all_features = [delayed(featurize_single_ts, pure=True)(ts, features_to_use,
+                                                            custom_script_path,
+                                                            custom_functions,
+                                                            raise_exceptions)
+                    for ts in all_time_series]
+    result = delayed(assemble_featureset, pure=True)(all_features, all_time_series)
+    return result.compute(scheduler=scheduler)
+
+
+def featurize_ts_files(ts_paths, features_to_use, custom_script_path=None,
+                       custom_functions=None, scheduler=dask.threaded.get,
+                       raise_exceptions=True):
+    """Feature generation function for on-disk time series (.npz) files.
+
+    By default, computes features concurrently using the
+    `dask.threaded.get` scheduler. Other possible options include
+    `dask.local.get` for synchronous computation (e.g., when debugging),
+    or `dask.distributed.Executor.get` for distributed computation.
+
+    In the case of multichannel measurements, each channel will be
+    featurized separately, and the index of the output featureset will contain
+    a `channel` coordinate.
+
+    Parameters
+    ----------
+    ts_paths : list of str
+        List of paths to time series data, stored in `numpy` .npz format.
+        See `time_series.load` for details.
+    features_to_use : list of str, optional
+        List of feature names to be generated. Defaults to an empty list, which
+        will result in only meta_features features being stored.
+    custom_script_path : str, optional
+        Path to Python script containing function definitions for the
+        generation of any custom features. Defaults to None.
+    custom_functions : dict, optional
+        Dictionary of custom feature functions to be evaluated for the given
+        time series, or a dictionary representing a dask graph of function
+        evaluations.  Dictionaries of functions should have keys `feature_name`
+        and values functions that take arguments (t, m, e); in the case of a
+        dask graph, these arrays should be referenced as 't', 'm', 'e',
+        respectively, and any values with keys present in `features_to_use`
+        will be computed.
+    scheduler : function, optional
+        `dask` scheduler function used to perform feature extraction
+        computation. Defaults to `dask.threaded.get`.
+    raise_exceptions : bool, optional
+        If True, exceptions during feature computation are raised immediately;
+        if False, exceptions are supressed and `np.nan` is returned for the
+        given feature and any dependent features. Defaults to True.
+
+    Returns
+    -------
+    pd.DataFrame
+        DataFrame with columns containing feature values, indexed by name.
+    """
+    all_time_series = [delayed(time_series.load, pure=True)(ts_path)
+                       for ts_path in ts_paths]
+    all_features = [delayed(featurize_single_ts, pure=True)(ts, features_to_use,
+                                                            custom_script_path,
+                                                            custom_functions,
+                                                            raise_exceptions)
+                    for ts in all_time_series]
+    names, meta_feats, all_labels = zip(*[(ts.name, ts.meta_features, ts.label)
+                                          for ts in all_time_series])
+    result = delayed(assemble_featureset, pure=True)(all_features,
+                                                     meta_features_list=meta_feats,
+                                                     names=names)
+    fset, labels = dask.compute(result, all_labels, scheduler=scheduler)
+
+    return fset, labels
+
+
+def impute_featureset(fset, strategy='constant', value=None, max_value=1e20,
+                      inplace=False):
+    """Replace NaN/Inf values with imputed values as defined by `strategy`.
+    Output should satisfy `sklearn.validation.assert_all_finite` so that
+    training a model will not produce an error.
+
+    Parameters
+    ----------
+    strategy : str, optional
+    The imputation strategy. Defaults to 'constant'.
+
+        - 'constant': replace all missing with `value`
+        - 'mean': replace all missing with mean along `axis`
+        - 'median': replace all missing with median along `axis`
+        - 'most_frequent': replace all missing with mode along `axis`
+
+    value : float or None, optional
+        Replacement value to use for `strategy='constant'`. Defaults to
+        `None`, in which case a very large negative value is used (a
+        good choice for e.g. random forests).
+
+    max_value : float, optional
+        Maximum (absolute) value above which values are treated as infinite.
+        Used to prevent overflow when fitting `sklearn` models.
+
+    inplace : bool, optional
+        If True, fill in place. If False, return a copy.
+
+    Returns
+    -------
+    pd.DataFrame
+        Feature data frame wth no missing/infinite values.
+    """
+    if not inplace:
+        fset = fset.copy()
+    fset.values[np.isnan(fset.values)] = np.inf  # avoid NaN comparison warnings
+    fset.values[np.abs(fset.values) > max_value] = np.nan
+    if strategy == 'constant':
+        if value is None:
+            # If no fill-in value is provided, use a large negative value
+            value = -2. * np.nanmax(np.abs(fset.values))
+        fset.fillna(value, inplace=True)
+    elif strategy in ('mean', 'median', 'most_frequent'):
+        imputer = Imputer(strategy=strategy, axis=0)
+        fset.values[:] = imputer.fit_transform(fset.values)
+    else:
+        raise NotImplementedError("Imputation strategy '{}' not"
+                                  "recognized.".format(strategy))
+    return fset
+
+
+def save_featureset(fset, path, **kwargs):
+    """Save feature DataFrame in .npz format.
+
+    Can optionally store class labels/targets and other metadata. All other
+    keyword arguments will be passed on to `np.savez`; data frames are saved as
+    record arrays and converted back into data frames by `load_featureset`.
+
+    Parameters
+    ----------
+    fset : pd.DataFrame
+        Feature data frame to be saved.
+    path : str
+        Path to store feature data.
+    kwargs : dict of array or data frame
+        Additional keyword arguments, e.g.:
+        labels -> class labels
+        preds -> predicted class labels
+        pred_probs -> (n_sample, n_class) data frame of class probabilities
+    """
+    # Transpose to properly handle MultiIndex columns
+    kwargs['features'] = fset.T
+
+    for k, v in kwargs.items():
+        if isinstance(v, pd.DataFrame):
+            arr = v.to_records()
+            dt_list = arr.dtype.descr
+            # Change type of indices from object to str
+            for i, (name, dt) in enumerate(dt_list):
+                if dt.endswith('O'):
+                    size = max(len(x) for x in arr['index'])
+                    dt_list[i] = (name, 'U' + str(size))
+                dt_list[i] = (str(name),) + dt_list[i][1:]  # avoid Py2 unicode
+            kwargs[k] = arr.astype(dt_list)
+
+        # Ignore null values, e.g. for unlabeled data
+        if all(el is None for el in v):
+            kwargs[k] = []
+
+    # Bypass savez to allow for `allow_pickle` keyword
+    # See https://github.com/numpy/numpy/pull/5770
+    np.lib.npyio._savez(path, [], kwargs, compress=True, allow_pickle=False)
+
+
+def load_featureset(path):
+    """Load feature DataFrame from .npz file.
+
+    Feature information is returned as a single DataFrame, while any other
+    arrays that were saved (class labels/predictions, etc.) are returned in a
+    single dictionary.
+
+    Parameters
+    ----------
+    path : str
+        Path where feature data is stored.
+
+    Returns
+    -------
+    pd.DataFrame
+        Feature data frame to be saved.
+    dict
+        Additional variables passed to `save_featureset`, including labels, etc.
+    """
+    with np.load(path, allow_pickle=False) as npz_file:
+        data = dict(npz_file)
+
+    # Transpose to properly handle MultiIndex columns
+    fset = pd.DataFrame.from_records(data.pop('features'),
+                                     index=['feature', 'channel']).T
+    features, channels = zip(*fset.columns)
+    channels = [int(c) if str(c).isdigit() else '' for c in channels]
+    fset.columns = pd.MultiIndex.from_tuples(list(zip(features, channels)),
+                                             names=['feature', 'channel'])
+
+    for k, v in data.items():
+        if len(v.dtype) > 0:
+            data[k] = pd.DataFrame.from_records(v, index='index')
+
+    return fset, data
```

### Comparing `cesium-0.9.7/PKG-INFO` & `cesium-0.9.9/PKG-INFO`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,36 @@
-Metadata-Version: 1.1
-Name: cesium
-Version: 0.9.7
-Summary: Machine Learning Time-Series Platform
-Home-page: http://cesium-ml.org
-Author: cesium Team
-Author-email: stefanv@berkeley.edu
-License: Modified BSD
-Download-URL: https://github.com/cesium-ml/cesium
-Description-Content-Type: UNKNOWN
-Description: Machine Learning Time Series Platform
-        
-        https://github.com/cesium-ml/cesium
-        
-        
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: Environment :: Console
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: BSD License
-Classifier: Programming Language :: C
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 3
-Classifier: Topic :: Scientific/Engineering
-Classifier: Operating System :: Microsoft :: Windows
-Classifier: Operating System :: POSIX
-Classifier: Operating System :: Unix
-Classifier: Operating System :: MacOS
-Requires: numpy (>= 1.12.1)
-Requires: scipy (>= 0.16.0)
-Requires: scikit_learn (>= 0.18.1)
-Requires: pandas (>= 0.17.0)
-Requires: dask (>= 0.15.0)
-Requires: toolz
-Requires: gatspy (>= 0.3.0)
-Requires: cloudpickle
+Metadata-Version: 1.2
+Name: cesium
+Version: 0.9.9
+Summary: Machine Learning Time-Series Platform
+Home-page: http://cesium-ml.org
+Maintainer: cesium Team
+Maintainer-email: stefanv@berkeley.edu
+License: Modified BSD
+Download-URL: https://github.com/cesium-ml/cesium
+Description: Machine Learning Time Series Platform
+        
+        https://github.com/cesium-ml/cesium
+        
+        
+Platform: UNKNOWN
+Classifier: Development Status :: 4 - Beta
+Classifier: Environment :: Console
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: BSD License
+Classifier: Programming Language :: C
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 3
+Classifier: Topic :: Scientific/Engineering
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: POSIX
+Classifier: Operating System :: Unix
+Classifier: Operating System :: MacOS
+Requires: numpy (>= 1.14.3)
+Requires: scipy (>= 0.16.0)
+Requires: scikit_learn (>= 0.18.1)
+Requires: pandas (>= 0.17.0)
+Requires: dask (>= 1.0.0)
+Requires: toolz
+Requires: gatspy (>= 0.3.0)
+Requires: cloudpickle
```

### Comparing `cesium-0.9.7/README.md` & `cesium-0.9.9/README.md`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-# `cesium`: Open-Source Platform for Time Series Inference
-[![Join the chat at https://gitter.im/cesium-ml/cesium](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/cesium-ml/cesium?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
-[![Build Status](https://travis-ci.org/cesium-ml/cesium.svg?branch=master)](https://travis-ci.org/cesium-ml/cesium)
-[![codecov.io](http://codecov.io/github/cesium-ml/cesium/coverage.svg?branch=master)](http://codecov.io/github/cesium-ml/cesium?branch=master)
-
-## Summary
-`cesium` is an open source library that allows users to:
-- extract features from raw time series data ([see list](http://cesium-ml.org/docs/feature_table.html)),
-- build machine learning models from these features, and
-- generate predictions for new data.
-
-The `cesium` library also powers computations within the [`cesium` web interface](https://github.com/cesium-ml/cesium_web), 
-which allows similar time series analyses to be performed entirely within the browser.
-
-More information and [examples](http://cesium-ml.org/docs/auto_examples/index.html) can be found on our [home page](http://cesium-ml.org).
-
-## Installation from binaries:
-- Wheels for Mac and Linux can be installed via `pip install cesium`.
-
-## Installation from source:
-1. Install [Cython](http://cython.readthedocs.io/en/latest/src/quickstart/install.html)
-2. Clone the repository: `git clone https://github.com/cesium-ml/cesium.git`
-3. `cd cesium && pip install -e .`
-
-Note that cesium requires a C99 compiler, which in particular excludes MSVC. On Windows, a different compiler like MinGW has to be used.
-
-## License:
-`cesium` uses the 3-clause BSD licence. The full license may be found in LICENSE.txt.
+# `cesium`: Open-Source Platform for Time Series Inference
+[![Join the chat at https://gitter.im/cesium-ml/cesium](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/cesium-ml/cesium?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
+[![Build Status](https://travis-ci.org/cesium-ml/cesium.svg?branch=master)](https://travis-ci.org/cesium-ml/cesium)
+[![codecov.io](http://codecov.io/github/cesium-ml/cesium/coverage.svg?branch=master)](http://codecov.io/github/cesium-ml/cesium?branch=master)
+
+## Summary
+`cesium` is an open source library that allows users to:
+- extract features from raw time series data ([see list](http://cesium-ml.org/docs/feature_table.html)),
+- build machine learning models from these features, and
+- generate predictions for new data.
+
+The `cesium` library also powers computations within the [`cesium` web interface](https://github.com/cesium-ml/cesium_web), 
+which allows similar time series analyses to be performed entirely within the browser.
+
+More information and [examples](http://cesium-ml.org/docs/auto_examples/index.html) can be found on our [home page](http://cesium-ml.org).
+
+## Installation from binaries:
+- Wheels for Mac and Linux can be installed via `pip install cesium`.
+
+## Installation from source:
+1. Install [Cython](http://cython.readthedocs.io/en/latest/src/quickstart/install.html)
+2. Clone the repository: `git clone https://github.com/cesium-ml/cesium.git`
+3. `cd cesium && pip install -e .`
+
+Note that cesium requires a C99 compiler, which in particular excludes MSVC. On Windows, a different compiler like MinGW has to be used.
+
+## License:
+`cesium` uses the 3-clause BSD licence. The full license may be found in LICENSE.txt.
```

### Comparing `cesium-0.9.7/dockerfiles/base/Dockerfile` & `cesium-0.9.9/dockerfiles/base/Dockerfile`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-FROM phusion/baseimage:0.9.15
-
-CMD ["/sbin/my_init"]
-
-RUN /etc/my_init.d/00_regen_ssh_host_keys.sh
-
-RUN apt-get update
-RUN apt-get -y upgrade
-
-
-RUN apt-get install -y python-pip python-numpy python-scipy \
-                       python-matplotlib python-beautifulsoup \
-                       python-parse python-yaml rabbitmq-server
-
-RUN pip install -U future cython
-RUN pip install scikit-learn==0.16.1
-
-# RUN apt-get install -y python3-dev python3-pip python3-numpy \
-#                        python3-scipy python3-matplotlib
-# RUN pip3 install psutil future cython parse scikit-learn beautifulsoup4 \
-#                  flask requests
-
-ENTRYPOINT ["/sbin/my_init", "--"]
+FROM phusion/baseimage:0.9.15
+
+CMD ["/sbin/my_init"]
+
+RUN /etc/my_init.d/00_regen_ssh_host_keys.sh
+
+RUN apt-get update
+RUN apt-get -y upgrade
+
+
+RUN apt-get install -y python-pip python-numpy python-scipy \
+                       python-matplotlib python-beautifulsoup \
+                       python-parse python-yaml rabbitmq-server
+
+RUN pip install -U future cython
+RUN pip install scikit-learn==0.16.1
+
+# RUN apt-get install -y python3-dev python3-pip python3-numpy \
+#                        python3-scipy python3-matplotlib
+# RUN pip3 install psutil future cython parse scikit-learn beautifulsoup4 \
+#                  flask requests
+
+ENTRYPOINT ["/sbin/my_init", "--"]
```

### Comparing `cesium-0.9.7/MANIFEST.in` & `cesium-0.9.9/MANIFEST.in`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,16 @@
-include setup*.py
-include MANIFEST.in
-include *.txt
-include Makefile
-recursive-include cesium *.pyx *.pxd *.pxi *.py *.c *.h *.ini *.md5 *.npy *.txt *.yaml .example
-recursive-include dockerfiles Dockerfile *.config *.conf *.py *.sh *.txt *.patch *.md
-recursive-include tools
-recursive-include cesium *.csv *.dat *.js *.tar.gz *.dat *.html *.nc *.npz
-
-include doc/Makefile
-recursive-include doc/source *.txt
-recursive-include doc/tools *.txt
-recursive-include doc/source/_templates *.html
-recursive-include doc *.py
-prune doc/build
-prune doc/gh-pages
+include setup*.py
+include MANIFEST.in
+include *.txt
+include Makefile
+recursive-include cesium *.pyx *.pxd *.pxi *.py *.c *.h *.ini *.md5 *.npy *.txt *.yaml .example
+recursive-include dockerfiles Dockerfile *.config *.conf *.py *.sh *.txt *.patch *.md
+recursive-include tools
+recursive-include cesium *.csv *.dat *.js *.tar.gz *.dat *.html *.nc *.npz
+
+include doc/Makefile
+recursive-include doc/source *.txt
+recursive-include doc/tools *.txt
+recursive-include doc/source/_templates *.html
+recursive-include doc *.py
+prune doc/build
+prune doc/gh-pages
```

### Comparing `cesium-0.9.7/doc/tools/feature_table.py` & `cesium-0.9.9/doc/tools/feature_table.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-from tabulate import tabulate
-import re
-from cesium.features.graphs import (feature_categories, dask_feature_graph,
-                                    extra_feature_docs)
-
-
-def feature_graph_to_rst_table(graph, category_name):
-    """Convert feature graph to Sphinx-compatible ReST table."""
-    header = [category_name, 'Description']
-    table = []
-    for feature_name in sorted(
-            graph, key=lambda s: [int(t) if t.isdigit() else t
-                                  for t in re.split('(\d+)', s)]):
-        description = (extra_feature_docs[feature_name] if feature_name in
-                       extra_feature_docs else
-                       ' '.join([e.strip() for e in
-                                 graph[feature_name][0].__doc__.split('\n\n')[0]
-                                 .strip().split('\n')]))
-        table.append([feature_name, description])
-
-    return tabulate(table, headers=header, tablefmt='rst')
-
-
-def write_feature_tables(fname):
-    with open(fname, 'w') as f:
-        f.write('==============================\n'
-                'Cesium Features - By Category\n'
-                '==============================\n\n')
-
-        dfg = dask_feature_graph
-
-        for category in feature_categories:
-            graph = {feature: dfg[feature]
-                         for feature in feature_categories[category]}
-
-            f.write(feature_graph_to_rst_table(graph, category) + '\n\n')
+from tabulate import tabulate
+import re
+from cesium.features.graphs import (feature_categories, dask_feature_graph,
+                                    extra_feature_docs)
+
+
+def feature_graph_to_rst_table(graph, category_name):
+    """Convert feature graph to Sphinx-compatible ReST table."""
+    header = [category_name, 'Description']
+    table = []
+    for feature_name in sorted(
+            graph, key=lambda s: [int(t) if t.isdigit() else t
+                                  for t in re.split('(\d+)', s)]):
+        description = (extra_feature_docs[feature_name] if feature_name in
+                       extra_feature_docs else
+                       ' '.join([e.strip() for e in
+                                 graph[feature_name][0].__doc__.split('\n\n')[0]
+                                 .strip().split('\n')]))
+        table.append([feature_name, description])
+
+    return tabulate(table, headers=header, tablefmt='rst')
+
+
+def write_feature_tables(fname):
+    with open(fname, 'w') as f:
+        f.write('==============================\n'
+                'Cesium Features - By Category\n'
+                '==============================\n\n')
+
+        dfg = dask_feature_graph
+
+        for category in feature_categories:
+            graph = {feature: dfg[feature]
+                         for feature in feature_categories[category]}
+
+            f.write(feature_graph_to_rst_table(graph, category) + '\n\n')
```

### Comparing `cesium-0.9.7/doc/tools/apigen.py` & `cesium-0.9.9/doc/tools/apigen.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,367 +1,367 @@
-"""
-Attempt to generate templates for module reference with Sphinx
-
-Notes
------
-This parsing is based on import and introspection of modules.
-
-This is a modified version of a script shipped with scikit-image, which was
-itself based on similar scripts from PyMVPA and NiPy.
-"""
-
-# Stdlib imports
-import os
-import re
-
-from types import BuiltinFunctionType, FunctionType
-
-# suppress print statements (warnings for empty files)
-DEBUG = True
-
-
-class ApiDocWriter(object):
-    ''' Class for automatic detection and parsing of API docs
-    to Sphinx-parsable reST format'''
-
-    # only separating first two levels
-    rst_section_levels = ['*', '=', '-', '~', '^']
-
-    def __init__(self,
-                 package_name,
-                 rst_extension='.txt',
-                 skip_patterns=['.*__', '.*tests$'],
-                 ):
-        ''' Initialize package for parsing
-
-        Parameters
-        ----------
-        package_name : string
-            Name of the top-level package.  *package_name* must be the
-            name of an importable package
-        rst_extension : string, optional
-            Extension for reST files, default '.rst'
-        skip_patterns : None or sequence
-            Sequence of strings giving URIs of modules to be excluded
-            Operates on the module name including preceding URI path,
-            back to the first dot after *package_name*.  For example
-            ``sphinx.util.console`` results in the string to search of
-            ``.util.console``
-            If is None, gives default. Default is:
-            ['\.setup$', '\._']
-        '''
-        self.package_name = package_name
-        self.skip_patterns = skip_patterns
-        self.rst_extension = rst_extension
-        root_module = self._import(package_name)
-        self.root_path = root_module.__path__[-1]
-
-    def _import(self, name):
-        ''' Import namespace package '''
-        mod = __import__(name)
-        components = name.split('.')
-        for comp in components[1:]:
-            mod = getattr(mod, comp)
-        return mod
-
-    def _get_object_name(self, line):
-        ''' Get second token in line
-        >>> docwriter = ApiDocWriter('sphinx')
-        >>> docwriter._get_object_name("  def func():  ")
-        'func'
-        >>> docwriter._get_object_name("  class Klass(object):  ")
-        'Klass'
-        >>> docwriter._get_object_name("  class Klass:  ")
-        'Klass'
-        '''
-        name = line.split()[1].split('(')[0].strip()
-        # in case we have classes which are not derived from object
-        # ie. old style classes
-        return name.rstrip(':')
-
-    def _parse_module_with_import(self, uri):
-        """Look for functions and classes in an importable module.
-
-        Parameters
-        ----------
-        uri : str
-            The name of the module to be parsed. This module needs to be
-            importable.
-
-        Returns
-        -------
-        functions : list of str
-            A list of (public) function names in the module.
-        classes : list of str
-            A list of (public) class names in the module.
-        """
-        mod = __import__(uri, fromlist=[uri.split('.')[-1]])
-        # find all public objects in the module.
-        obj_strs = [obj for obj in dir(mod) if not obj.startswith('_')]
-        functions = []
-        classes = []
-        for obj_str in obj_strs:
-            # find the actual object from its string representation
-            if obj_str not in mod.__dict__:
-                continue
-            obj = mod.__dict__[obj_str]
-            if (hasattr(obj, '__module__')
-                and self.package_name not in obj.__module__):
-                continue
-
-            # figure out if obj is a function or class
-            if isinstance(obj, (FunctionType, BuiltinFunctionType)):
-                functions.append(obj_str)
-            else:
-                try:
-                    issubclass(obj, object)
-                    classes.append(obj_str)
-                except TypeError:
-                    # not a function or class
-                    pass
-        return functions, classes
-
-    def generate_api_doc(self, uri):
-        '''Make autodoc documentation template string for a module
-
-        Parameters
-        ----------
-        uri : string
-            python location of module - e.g 'sphinx.builder'
-
-        Returns
-        -------
-        S : string
-            Contents of API doc
-        '''
-        # get the names of all classes and functions
-        functions, classes = self._parse_module_with_import(uri)
-        if not len(functions) and not len(classes) and DEBUG:
-            print('WARNING: Empty -', uri)  # dbg
-            return ''
-
-        # Make a shorter version of the uri that omits the package name for
-        # titles
-        uri_short = re.sub(r'^%s\.' % self.package_name,'',uri)
-
-        ad = '.. AUTO-GENERATED FILE -- DO NOT EDIT!\n\n'
-
-        # Set the chapter title to read 'module' for all modules except for the
-        # main packages
-        if '.' in uri:
-            title = 'Module: :mod:`' + uri_short + '`'
-        else:
-            title = ':mod:`' + uri_short + '`'
-        ad += title + '\n' + self.rst_section_levels[1] * len(title)
-
-        ad += '\n.. automodule:: ' + uri + '\n'
-        ad += '\n.. currentmodule:: ' + uri + '\n'
-        ad += '.. autosummary::\n\n'
-        for f in functions:
-            ad += '   ' + uri + '.' + f + '\n'
-        ad += '\n'
-        for c in classes:
-            ad += '   ' + uri + '.' + c + '\n'
-        ad += '\n'
-
-        for f in functions:
-            # must NOT exclude from index to keep cross-refs working
-            full_f = uri + '.' + f
-            ad += f + '\n'
-            ad += self.rst_section_levels[2] * len(f) + '\n'
-            ad += '\n.. autofunction:: ' + full_f + '\n\n'
-        for c in classes:
-            ad += '\n:class:`' + c + '`\n' \
-                  + self.rst_section_levels[2] * \
-                  (len(c)+9) + '\n\n'
-            ad += '\n.. autoclass:: ' + c + '\n'
-            # must NOT exclude from index to keep cross-refs working
-            ad += '  :members:\n' \
-                  '  :undoc-members:\n' \
-                  '  :show-inheritance:\n' \
-                  '\n' \
-                  '  .. automethod:: __init__\n'
-        return ad
-
-    def _survives_exclude(self, matchstr):
-        ''' Returns True if *matchstr* does not match patterns
-
-        ``self.package_name`` removed from front of string if present
-        '''
-        for pat in self.skip_patterns:
-            if re.compile(pat).search(matchstr):
-                return False
-        return True
-
-    def _uri2path(self, uri):
-        ''' Convert uri to absolute filepath
-
-        Parameters
-        ----------
-        uri : string
-            URI of python module to return path for
-
-        Returns
-        -------
-        path : None or string
-            Returns None if there is no valid path for this URI
-            Otherwise returns absolute file system path for URI
-
-        Examples
-        --------
-        >>> docwriter = ApiDocWriter('sphinx')
-        >>> import sphinx
-        >>> modpath = sphinx.__path__[0]
-        >>> res = docwriter._uri2path('sphinx.builder')
-        >>> res == os.path.join(modpath, 'builder.py')
-        True
-        >>> res = docwriter._uri2path('sphinx')
-        >>> res == os.path.join(modpath, '__init__.py')
-        True
-        >>> docwriter._uri2path('sphinx.does_not_exist')
-
-        '''
-        if uri == self.package_name:
-            return os.path.join(self.root_path, '__init__.py')
-        path = uri.replace(self.package_name + '.', '')
-        path = path.replace('.', os.path.sep)
-        path = os.path.join(self.root_path, path)
-        # XXX maybe check for extensions as well?
-        if os.path.exists(path + '.py'): # file
-            path += '.py'
-        elif os.path.exists(os.path.join(path, '__init__.py')):
-            path = os.path.join(path, '__init__.py')
-        else:
-            return None
-        return path
-
-    def _path2uri(self, dirpath):
-        ''' Convert directory path to uri '''
-        package_dir = self.package_name.replace('.', os.path.sep)
-        relpath = dirpath.replace(self.root_path, package_dir)
-        if relpath.startswith(os.path.sep):
-            relpath = relpath[1:]
-        return relpath.replace(os.path.sep, '.')
-
-    def discover_modules(self):
-        ''' Return module sequence discovered from ``self.package_name``
-
-
-        Parameters
-        ----------
-        None
-
-        Returns
-        -------
-        mods : sequence
-            Sequence of module names within ``self.package_name``
-
-        Examples
-        --------
-        >>> dw = ApiDocWriter('sphinx')
-        >>> mods = dw.discover_modules()
-        >>> 'sphinx.util' in mods
-        True
-        >>> dw.skip_patterns.append('\.util$')
-        >>> 'sphinx.util' in dw.discover_modules()
-        False
-        >>>
-        '''
-        modules = [self.package_name]
-        # raw directory parsing
-        for dirpath, dirnames, filenames in os.walk(self.root_path,
-                                                    topdown=False):
-            # Check directory names for packages
-            root_uri = self._path2uri(os.path.join(self.root_path,
-                                                   dirpath))
-            filenames = [f for f in filenames if f.endswith('.py')]
-            uris = [u.strip('.py') for u in dirnames + filenames]
-            for uri in uris:
-                package_uri = '.'.join((root_uri, uri))
-                if (self._uri2path(package_uri) and
-                    self._survives_exclude(package_uri)):
-                    try:
-                        mod = __import__(package_uri, fromlist=['cesium'])
-                        mod.__all__
-                        modules.append(package_uri)
-                    except (ImportError, AttributeError):
-                        pass
-        return sorted(modules)
-
-    def write_modules_api(self, modules, outdir):
-        # write the list
-        written_modules = []
-        for m in modules:
-            api_str = self.generate_api_doc(m)
-            if not api_str:
-                continue
-            # write out to file
-            outfile = os.path.join(outdir,
-                                   m + self.rst_extension)
-            fileobj = open(outfile, 'wt')
-            fileobj.write(api_str)
-            fileobj.close()
-            written_modules.append(m)
-        self.written_modules = written_modules
-
-    def write_api_docs(self, outdir):
-        """Generate API reST files.
-
-        Parameters
-        ----------
-        outdir : string
-            Directory name in which to store files
-            We create automatic filenames for each module
-
-        Returns
-        -------
-        None
-
-        Notes
-        -----
-        Sets self.written_modules to list of written modules
-        """
-        if not os.path.exists(outdir):
-            os.mkdir(outdir)
-        # compose list of modules
-        modules = self.discover_modules()
-        self.write_modules_api(modules, outdir)
-
-    def write_index(self, outdir, froot='gen', relative_to=None):
-        """Make a reST API index file from written files
-
-        Parameters
-        ----------
-        path : string
-            Filename to write index to
-        outdir : string
-            Directory to which to write generated index file
-        froot : string, optional
-            root (filename without extension) of filename to write to
-            Defaults to 'gen'.  We add ``self.rst_extension``.
-        relative_to : string
-            path to which written filenames are relative.  This
-            component of the written file path will be removed from
-            outdir, in the generated index.  Default is None, meaning,
-            leave path as it is.
-        """
-        if self.written_modules is None:
-            raise ValueError('No modules written')
-        # Get full filename path
-        path = os.path.join(outdir, froot+self.rst_extension)
-        # Path written into index is relative to rootpath
-        if relative_to is not None:
-            relpath = (outdir + os.path.sep).replace(relative_to + os.path.sep, '')
-        else:
-            relpath = outdir
-        print("outdir: ", relpath)
-        idx = open(path,'wt')
-        w = idx.write
-        w('.. AUTO-GENERATED FILE -- DO NOT EDIT!\n\n')
-
-        title = "API Reference"
-        w(title + "\n")
-        w("=" * len(title) + "\n\n")
-        w('.. toctree::\n\n')
-        for f in self.written_modules:
-            w('   %s\n' % os.path.join(relpath,f))
-        idx.close()
+"""
+Attempt to generate templates for module reference with Sphinx
+
+Notes
+-----
+This parsing is based on import and introspection of modules.
+
+This is a modified version of a script shipped with scikit-image, which was
+itself based on similar scripts from PyMVPA and NiPy.
+"""
+
+# Stdlib imports
+import os
+import re
+
+from types import BuiltinFunctionType, FunctionType
+
+# suppress print statements (warnings for empty files)
+DEBUG = True
+
+
+class ApiDocWriter(object):
+    ''' Class for automatic detection and parsing of API docs
+    to Sphinx-parsable reST format'''
+
+    # only separating first two levels
+    rst_section_levels = ['*', '=', '-', '~', '^']
+
+    def __init__(self,
+                 package_name,
+                 rst_extension='.txt',
+                 skip_patterns=['.*__', '.*tests$'],
+                 ):
+        ''' Initialize package for parsing
+
+        Parameters
+        ----------
+        package_name : string
+            Name of the top-level package.  *package_name* must be the
+            name of an importable package
+        rst_extension : string, optional
+            Extension for reST files, default '.rst'
+        skip_patterns : None or sequence
+            Sequence of strings giving URIs of modules to be excluded
+            Operates on the module name including preceding URI path,
+            back to the first dot after *package_name*.  For example
+            ``sphinx.util.console`` results in the string to search of
+            ``.util.console``
+            If is None, gives default. Default is:
+            ['\.setup$', '\._']
+        '''
+        self.package_name = package_name
+        self.skip_patterns = skip_patterns
+        self.rst_extension = rst_extension
+        root_module = self._import(package_name)
+        self.root_path = root_module.__path__[-1]
+
+    def _import(self, name):
+        ''' Import namespace package '''
+        mod = __import__(name)
+        components = name.split('.')
+        for comp in components[1:]:
+            mod = getattr(mod, comp)
+        return mod
+
+    def _get_object_name(self, line):
+        ''' Get second token in line
+        >>> docwriter = ApiDocWriter('sphinx')
+        >>> docwriter._get_object_name("  def func():  ")
+        'func'
+        >>> docwriter._get_object_name("  class Klass(object):  ")
+        'Klass'
+        >>> docwriter._get_object_name("  class Klass:  ")
+        'Klass'
+        '''
+        name = line.split()[1].split('(')[0].strip()
+        # in case we have classes which are not derived from object
+        # ie. old style classes
+        return name.rstrip(':')
+
+    def _parse_module_with_import(self, uri):
+        """Look for functions and classes in an importable module.
+
+        Parameters
+        ----------
+        uri : str
+            The name of the module to be parsed. This module needs to be
+            importable.
+
+        Returns
+        -------
+        functions : list of str
+            A list of (public) function names in the module.
+        classes : list of str
+            A list of (public) class names in the module.
+        """
+        mod = __import__(uri, fromlist=[uri.split('.')[-1]])
+        # find all public objects in the module.
+        obj_strs = [obj for obj in dir(mod) if not obj.startswith('_')]
+        functions = []
+        classes = []
+        for obj_str in obj_strs:
+            # find the actual object from its string representation
+            if obj_str not in mod.__dict__:
+                continue
+            obj = mod.__dict__[obj_str]
+            if (hasattr(obj, '__module__')
+                and self.package_name not in obj.__module__):
+                continue
+
+            # figure out if obj is a function or class
+            if isinstance(obj, (FunctionType, BuiltinFunctionType)):
+                functions.append(obj_str)
+            else:
+                try:
+                    issubclass(obj, object)
+                    classes.append(obj_str)
+                except TypeError:
+                    # not a function or class
+                    pass
+        return functions, classes
+
+    def generate_api_doc(self, uri):
+        '''Make autodoc documentation template string for a module
+
+        Parameters
+        ----------
+        uri : string
+            python location of module - e.g 'sphinx.builder'
+
+        Returns
+        -------
+        S : string
+            Contents of API doc
+        '''
+        # get the names of all classes and functions
+        functions, classes = self._parse_module_with_import(uri)
+        if not len(functions) and not len(classes) and DEBUG:
+            print('WARNING: Empty -', uri)  # dbg
+            return ''
+
+        # Make a shorter version of the uri that omits the package name for
+        # titles
+        uri_short = re.sub(r'^%s\.' % self.package_name,'',uri)
+
+        ad = '.. AUTO-GENERATED FILE -- DO NOT EDIT!\n\n'
+
+        # Set the chapter title to read 'module' for all modules except for the
+        # main packages
+        if '.' in uri:
+            title = 'Module: :mod:`' + uri_short + '`'
+        else:
+            title = ':mod:`' + uri_short + '`'
+        ad += title + '\n' + self.rst_section_levels[1] * len(title)
+
+        ad += '\n.. automodule:: ' + uri + '\n'
+        ad += '\n.. currentmodule:: ' + uri + '\n'
+        ad += '.. autosummary::\n\n'
+        for f in functions:
+            ad += '   ' + uri + '.' + f + '\n'
+        ad += '\n'
+        for c in classes:
+            ad += '   ' + uri + '.' + c + '\n'
+        ad += '\n'
+
+        for f in functions:
+            # must NOT exclude from index to keep cross-refs working
+            full_f = uri + '.' + f
+            ad += f + '\n'
+            ad += self.rst_section_levels[2] * len(f) + '\n'
+            ad += '\n.. autofunction:: ' + full_f + '\n\n'
+        for c in classes:
+            ad += '\n:class:`' + c + '`\n' \
+                  + self.rst_section_levels[2] * \
+                  (len(c)+9) + '\n\n'
+            ad += '\n.. autoclass:: ' + c + '\n'
+            # must NOT exclude from index to keep cross-refs working
+            ad += '  :members:\n' \
+                  '  :undoc-members:\n' \
+                  '  :show-inheritance:\n' \
+                  '\n' \
+                  '  .. automethod:: __init__\n'
+        return ad
+
+    def _survives_exclude(self, matchstr):
+        ''' Returns True if *matchstr* does not match patterns
+
+        ``self.package_name`` removed from front of string if present
+        '''
+        for pat in self.skip_patterns:
+            if re.compile(pat).search(matchstr):
+                return False
+        return True
+
+    def _uri2path(self, uri):
+        ''' Convert uri to absolute filepath
+
+        Parameters
+        ----------
+        uri : string
+            URI of python module to return path for
+
+        Returns
+        -------
+        path : None or string
+            Returns None if there is no valid path for this URI
+            Otherwise returns absolute file system path for URI
+
+        Examples
+        --------
+        >>> docwriter = ApiDocWriter('sphinx')
+        >>> import sphinx
+        >>> modpath = sphinx.__path__[0]
+        >>> res = docwriter._uri2path('sphinx.builder')
+        >>> res == os.path.join(modpath, 'builder.py')
+        True
+        >>> res = docwriter._uri2path('sphinx')
+        >>> res == os.path.join(modpath, '__init__.py')
+        True
+        >>> docwriter._uri2path('sphinx.does_not_exist')
+
+        '''
+        if uri == self.package_name:
+            return os.path.join(self.root_path, '__init__.py')
+        path = uri.replace(self.package_name + '.', '')
+        path = path.replace('.', os.path.sep)
+        path = os.path.join(self.root_path, path)
+        # XXX maybe check for extensions as well?
+        if os.path.exists(path + '.py'): # file
+            path += '.py'
+        elif os.path.exists(os.path.join(path, '__init__.py')):
+            path = os.path.join(path, '__init__.py')
+        else:
+            return None
+        return path
+
+    def _path2uri(self, dirpath):
+        ''' Convert directory path to uri '''
+        package_dir = self.package_name.replace('.', os.path.sep)
+        relpath = dirpath.replace(self.root_path, package_dir)
+        if relpath.startswith(os.path.sep):
+            relpath = relpath[1:]
+        return relpath.replace(os.path.sep, '.')
+
+    def discover_modules(self):
+        ''' Return module sequence discovered from ``self.package_name``
+
+
+        Parameters
+        ----------
+        None
+
+        Returns
+        -------
+        mods : sequence
+            Sequence of module names within ``self.package_name``
+
+        Examples
+        --------
+        >>> dw = ApiDocWriter('sphinx')
+        >>> mods = dw.discover_modules()
+        >>> 'sphinx.util' in mods
+        True
+        >>> dw.skip_patterns.append('\.util$')
+        >>> 'sphinx.util' in dw.discover_modules()
+        False
+        >>>
+        '''
+        modules = [self.package_name]
+        # raw directory parsing
+        for dirpath, dirnames, filenames in os.walk(self.root_path,
+                                                    topdown=False):
+            # Check directory names for packages
+            root_uri = self._path2uri(os.path.join(self.root_path,
+                                                   dirpath))
+            filenames = [f for f in filenames if f.endswith('.py')]
+            uris = [u.strip('.py') for u in dirnames + filenames]
+            for uri in uris:
+                package_uri = '.'.join((root_uri, uri))
+                if (self._uri2path(package_uri) and
+                    self._survives_exclude(package_uri)):
+                    try:
+                        mod = __import__(package_uri, fromlist=['cesium'])
+                        mod.__all__
+                        modules.append(package_uri)
+                    except (ImportError, AttributeError):
+                        pass
+        return sorted(modules)
+
+    def write_modules_api(self, modules, outdir):
+        # write the list
+        written_modules = []
+        for m in modules:
+            api_str = self.generate_api_doc(m)
+            if not api_str:
+                continue
+            # write out to file
+            outfile = os.path.join(outdir,
+                                   m + self.rst_extension)
+            fileobj = open(outfile, 'wt')
+            fileobj.write(api_str)
+            fileobj.close()
+            written_modules.append(m)
+        self.written_modules = written_modules
+
+    def write_api_docs(self, outdir):
+        """Generate API reST files.
+
+        Parameters
+        ----------
+        outdir : string
+            Directory name in which to store files
+            We create automatic filenames for each module
+
+        Returns
+        -------
+        None
+
+        Notes
+        -----
+        Sets self.written_modules to list of written modules
+        """
+        if not os.path.exists(outdir):
+            os.mkdir(outdir)
+        # compose list of modules
+        modules = self.discover_modules()
+        self.write_modules_api(modules, outdir)
+
+    def write_index(self, outdir, froot='gen', relative_to=None):
+        """Make a reST API index file from written files
+
+        Parameters
+        ----------
+        path : string
+            Filename to write index to
+        outdir : string
+            Directory to which to write generated index file
+        froot : string, optional
+            root (filename without extension) of filename to write to
+            Defaults to 'gen'.  We add ``self.rst_extension``.
+        relative_to : string
+            path to which written filenames are relative.  This
+            component of the written file path will be removed from
+            outdir, in the generated index.  Default is None, meaning,
+            leave path as it is.
+        """
+        if self.written_modules is None:
+            raise ValueError('No modules written')
+        # Get full filename path
+        path = os.path.join(outdir, froot+self.rst_extension)
+        # Path written into index is relative to rootpath
+        if relative_to is not None:
+            relpath = (outdir + os.path.sep).replace(relative_to + os.path.sep, '')
+        else:
+            relpath = outdir
+        print("outdir: ", relpath)
+        idx = open(path,'wt')
+        w = idx.write
+        w('.. AUTO-GENERATED FILE -- DO NOT EDIT!\n\n')
+
+        title = "API Reference"
+        w(title + "\n")
+        w("=" * len(title) + "\n\n")
+        w('.. toctree::\n\n')
+        for f in self.written_modules:
+            w('   %s\n' % os.path.join(relpath,f))
+        idx.close()
```

### Comparing `cesium-0.9.7/doc/conf.py` & `cesium-0.9.9/doc/conf.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,336 +1,336 @@
-#!/usr/bin/env python3
-# -*- coding: utf-8 -*-
-#
-# cesium documentation build configuration file, created by
-# sphinx-quickstart on Thu Jul 23 13:00:45 2015.
-#
-# This file is execfile()d with the current directory set to its
-# containing dir.
-#
-# Note that not all possible configuration values are present in this
-# autogenerated file.
-#
-# All configuration values have a default; values that are commented out
-# serve to show the default.
-
-import sys
-import os
-import shlex
-
-# If extensions (or modules to document with autodoc) are in another directory,
-# add these directories to sys.path here. If the directory is relative to the
-# documentation root, use os.path.abspath to make it absolute, like shown here.
-#sys.path.insert(0, os.path.abspath('.'))
-
-# -- General configuration ------------------------------------------------
-
-# If your documentation needs a minimal Sphinx version, state it here.
-#needs_sphinx = '1.0'
-
-# Add any Sphinx extension module names here, as strings. They can be
-# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
-# ones.
-extensions = [
-    'sphinx.ext.mathjax',
-    'sphinx.ext.autodoc',
-    'sphinx.ext.autosummary',
-#    'sphinx.ext.pngmath',
-    'numpydoc',
-#    'plot2rst',
-#    'sphinx.ext.intersphinx',
-#    'sphinx.ext.linkcode',
-    'sphinx_gallery.gen_gallery'
-]
-
-sphinx_gallery_conf = {
-    # path to your examples scripts
-    'examples_dirs' : '../examples',
-    # path where to save gallery generated examples
-    'gallery_dirs'  : 'auto_examples'}
-
-# Add any paths that contain templates here, relative to this directory.
-templates_path = ['_templates']
-
-# The suffix(es) of source filenames.
-from recommonmark.parser import CommonMarkParser
-
-source_parsers = {
-    '.md': CommonMarkParser,
-}
-
-source_suffix = ['.rst', '.md', '.txt']
-
-# The encoding of source files.
-#source_encoding = 'utf-8-sig'
-
-# The master toctree document.
-master_doc = 'index'
-
-# General information about the project.
-project = 'cesium'
-copyright = '2015, The cesium Team'
-author = 'The cesium Team'
-
-# The version info for the project you're documenting, acts as replacement for
-# |version| and |release|, also used in various other places throughout the
-# built documents.
-#
-
-setup_lines = open('../cesium/__init__.py').readlines()
-version = 'vUndefined'
-for l in setup_lines:
-    if l.startswith('__version__'):
-        version = l.split("'")[1]
-        break
-
-# The full version, including alpha/beta/rc tags.
-release = version
-
-# The language for content autogenerated by Sphinx. Refer to documentation
-# for a list of supported languages.
-#
-# This is also used if you do content translation via gettext catalogs.
-# Usually you set "language" from the command line for these cases.
-language = None
-
-# There are two options for replacing |today|: either, you set today to some
-# non-false value, then it is used:
-#today = ''
-# Else, today_fmt is used as the format for a strftime call.
-#today_fmt = '%B %d, %Y'
-
-# List of patterns, relative to source directory, that match files and
-# directories to ignore when looking for source files.
-exclude_patterns = ['_build']
-
-# The reST default role (used for this markup: `text`) to use for all
-# documents.
-#default_role = None
-
-# If true, '()' will be appended to :func: etc. cross-reference text.
-#add_function_parentheses = True
-
-# If true, the current module name will be prepended to all description
-# unit titles (such as .. function::).
-#add_module_names = True
-
-# If true, sectionauthor and moduleauthor directives will be shown in the
-# output. They are ignored by default.
-#show_authors = False
-
-# The name of the Pygments (syntax highlighting) style to use.
-pygments_style = 'sphinx'
-
-# A list of ignored prefixes for module index sorting.
-#modindex_common_prefix = []
-
-# If true, keep warnings as "system message" paragraphs in the built documents.
-#keep_warnings = False
-
-# If true, `todo` and `todoList` produce output, else they produce nothing.
-todo_include_todos = False
-
-# -- Options for HTML output ----------------------------------------------
-
-# The theme to use for HTML and HTML Help pages.  See the documentation for
-# a list of builtin themes.
-# Per https://github.com/snide/sphinx_rtd_theme: specify theme if not on RTD
-on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
-if not on_rtd:  # only import and set the theme if we're building docs locally
-    import sphinx_rtd_theme
-    html_theme = 'sphinx_rtd_theme'
-
-# Theme options are theme-specific and customize the look and feel of a theme
-# further.  For a list of options available for each theme, see the
-# documentation.
-#html_theme_options = {}
-
-# Add any paths that contain custom themes here, relative to this directory.
-#html_theme_path = []
-
-# The name for this set of Sphinx documents.  If None, it defaults to
-# "<project> v<release> documentation".
-#html_title = None
-
-# A shorter title for the navigation bar.  Default is the same as html_title.
-#html_short_title = None
-
-# The name of an image file (relative to this directory) to place at the top
-# of the sidebar.
-#html_logo = None
-
-# The name of an image file (within the static path) to use as favicon of the
-# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
-# pixels large.
-#html_favicon = None
-
-# Add any paths that contain custom static files (such as style sheets) here,
-# relative to this directory. They are copied after the builtin static files,
-# so a file named "default.css" will overwrite the builtin "default.css".
-html_static_path = ['_static']
-
-# Add any extra paths that contain custom files (such as robots.txt or
-# .htaccess) here, relative to this directory. These files are copied
-# directly to the root of the documentation.
-#html_extra_path = []
-
-# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
-# using the given strftime format.
-#html_last_updated_fmt = '%b %d, %Y'
-
-# If true, SmartyPants will be used to convert quotes and dashes to
-# typographically correct entities.
-#html_use_smartypants = True
-
-# Custom sidebar templates, maps document names to template names.
-#html_sidebars = {}
-
-# Additional templates that should be rendered to pages, maps page names to
-# template names.
-#html_additional_pages = {}
-
-# If false, no module index is generated.
-#html_domain_indices = True
-
-# If false, no index is generated.
-#html_use_index = True
-
-# If true, the index is split into individual pages for each letter.
-#html_split_index = False
-
-# If true, links to the reST sources are added to the pages.
-html_show_sourcelink = False
-
-# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
-#html_show_sphinx = True
-
-# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
-#html_show_copyright = True
-
-# If true, an OpenSearch description file will be output, and all pages will
-# contain a <link> tag referring to it.  The value of this option must be the
-# base URL from which the finished HTML is served.
-#html_use_opensearch = ''
-
-# This is the file name suffix for HTML files (e.g. ".xhtml").
-#html_file_suffix = None
-
-# Language to be used for generating the HTML full-text search index.
-# Sphinx supports the following languages:
-#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'
-#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'
-#html_search_language = 'en'
-
-# A dictionary with options for the search language support, empty by default.
-# Now only 'ja' uses this config value
-#html_search_options = {'type': 'default'}
-
-# The name of a javascript file (relative to the configuration directory) that
-# implements a search results scorer. If empty, the default will be used.
-#html_search_scorer = 'scorer.js'
-
-# Output file base name for HTML help builder.
-htmlhelp_basename = 'cesiumdoc'
-
-# -- Options for LaTeX output ---------------------------------------------
-
-latex_elements = {
-# The paper size ('letterpaper' or 'a4paper').
-#'papersize': 'letterpaper',
-
-# The font size ('10pt', '11pt' or '12pt').
-#'pointsize': '10pt',
-
-# Additional stuff for the LaTeX preamble.
-#'preamble': '',
-
-# Latex figure (float) alignment
-#'figure_align': 'htbp',
-}
-
-# Grouping the document tree into LaTeX files. List of tuples
-# (source start file, target name, title,
-#  author, documentclass [howto, manual, or own class]).
-latex_documents = [
-  (master_doc, 'cesium.tex', 'cesium Documentation',
-   'The cesium Team', 'manual'),
-]
-
-# The name of an image file (relative to this directory) to place at the top of
-# the title page.
-#latex_logo = None
-
-# For "manual" documents, if this is true, then toplevel headings are parts,
-# not chapters.
-#latex_use_parts = False
-
-# If true, show page references after internal links.
-#latex_show_pagerefs = False
-
-# If true, show URL addresses after external links.
-#latex_show_urls = False
-
-# Documents to append as an appendix to all manuals.
-#latex_appendices = []
-
-# If false, no module index is generated.
-#latex_domain_indices = True
-
-
-# -- Options for manual page output ---------------------------------------
-
-# One entry per manual page. List of tuples
-# (source start file, name, description, authors, manual section).
-man_pages = [
-    (master_doc, 'cesium', 'cesium Documentation',
-     [author], 1)
-]
-
-# If true, show URL addresses after external links.
-#man_show_urls = False
-
-
-# -- Options for Texinfo output -------------------------------------------
-
-# Grouping the document tree into Texinfo files. List of tuples
-# (source start file, target name, title, author,
-#  dir menu entry, description, category)
-texinfo_documents = [
-  (master_doc, 'cesium', 'cesium Documentation',
-   author, 'cesium', 'One line description of project.',
-   'Miscellaneous'),
-]
-
-# Documents to append as an appendix to all manuals.
-#texinfo_appendices = []
-
-# If false, no module index is generated.
-#texinfo_domain_indices = True
-
-# How to display URL addresses: 'footnote', 'no', or 'inline'.
-#texinfo_show_urls = 'footnote'
-
-# If true, do not generate a @detailmenu in the "Top" node's menu.
-#texinfo_no_detailmenu = False
-
-
-# -- Build cesium API documentation ----------------------------------------
-sys.path.append(os.path.join(os.path.dirname(__name__), '..'))
-sys.path.append(os.path.join(os.path.dirname(__name__), 'tools'))
-from apigen import ApiDocWriter
-import cesium
-package = 'cesium'
-module = sys.modules[package]
-
-outdir = 'api'
-docwriter = ApiDocWriter(package)
-docwriter.write_api_docs(outdir)
-docwriter.write_index(outdir, 'api', relative_to='api')
-print('%d files written' % len(docwriter.written_modules))
-
-# -- Write feature tables --------------------------------------------------
-from feature_table import write_feature_tables
-write_feature_tables('./feature_table.rst')
-
-def setup(app):
-    app.add_stylesheet("output_cells.css")
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+# cesium documentation build configuration file, created by
+# sphinx-quickstart on Thu Jul 23 13:00:45 2015.
+#
+# This file is execfile()d with the current directory set to its
+# containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import sys
+import os
+import shlex
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+#sys.path.insert(0, os.path.abspath('.'))
+
+# -- General configuration ------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = [
+    'sphinx.ext.mathjax',
+    'sphinx.ext.autodoc',
+    'sphinx.ext.autosummary',
+#    'sphinx.ext.pngmath',
+    'numpydoc',
+#    'plot2rst',
+#    'sphinx.ext.intersphinx',
+#    'sphinx.ext.linkcode',
+    'sphinx_gallery.gen_gallery'
+]
+
+sphinx_gallery_conf = {
+    # path to your examples scripts
+    'examples_dirs' : '../examples',
+    # path where to save gallery generated examples
+    'gallery_dirs'  : 'auto_examples'}
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix(es) of source filenames.
+from recommonmark.parser import CommonMarkParser
+
+source_parsers = {
+    '.md': CommonMarkParser,
+}
+
+source_suffix = ['.rst', '.md', '.txt']
+
+# The encoding of source files.
+#source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = 'cesium'
+copyright = '2015, The cesium Team'
+author = 'The cesium Team'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+
+setup_lines = open('../cesium/__init__.py').readlines()
+version = 'vUndefined'
+for l in setup_lines:
+    if l.startswith('__version__'):
+        version = l.split("'")[1]
+        break
+
+# The full version, including alpha/beta/rc tags.
+release = version
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#
+# This is also used if you do content translation via gettext catalogs.
+# Usually you set "language" from the command line for these cases.
+language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+#today = ''
+# Else, today_fmt is used as the format for a strftime call.
+#today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
+
+# The reST default role (used for this markup: `text`) to use for all
+# documents.
+#default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+#add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+#add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+#show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# A list of ignored prefixes for module index sorting.
+#modindex_common_prefix = []
+
+# If true, keep warnings as "system message" paragraphs in the built documents.
+#keep_warnings = False
+
+# If true, `todo` and `todoList` produce output, else they produce nothing.
+todo_include_todos = False
+
+# -- Options for HTML output ----------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+# Per https://github.com/snide/sphinx_rtd_theme: specify theme if not on RTD
+on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
+if not on_rtd:  # only import and set the theme if we're building docs locally
+    import sphinx_rtd_theme
+    html_theme = 'sphinx_rtd_theme'
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+#html_theme_options = {}
+
+# Add any paths that contain custom themes here, relative to this directory.
+#html_theme_path = []
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<release> documentation".
+#html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+#html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+#html_logo = None
+
+# The name of an image file (within the static path) to use as favicon of the
+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+#html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+# Add any extra paths that contain custom files (such as robots.txt or
+# .htaccess) here, relative to this directory. These files are copied
+# directly to the root of the documentation.
+#html_extra_path = []
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+#html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+#html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+#html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+#html_additional_pages = {}
+
+# If false, no module index is generated.
+#html_domain_indices = True
+
+# If false, no index is generated.
+#html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+#html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+html_show_sourcelink = False
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+#html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Language to be used for generating the HTML full-text search index.
+# Sphinx supports the following languages:
+#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'
+#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr'
+#html_search_language = 'en'
+
+# A dictionary with options for the search language support, empty by default.
+# Now only 'ja' uses this config value
+#html_search_options = {'type': 'default'}
+
+# The name of a javascript file (relative to the configuration directory) that
+# implements a search results scorer. If empty, the default will be used.
+#html_search_scorer = 'scorer.js'
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'cesiumdoc'
+
+# -- Options for LaTeX output ---------------------------------------------
+
+latex_elements = {
+# The paper size ('letterpaper' or 'a4paper').
+#'papersize': 'letterpaper',
+
+# The font size ('10pt', '11pt' or '12pt').
+#'pointsize': '10pt',
+
+# Additional stuff for the LaTeX preamble.
+#'preamble': '',
+
+# Latex figure (float) alignment
+#'figure_align': 'htbp',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title,
+#  author, documentclass [howto, manual, or own class]).
+latex_documents = [
+  (master_doc, 'cesium.tex', 'cesium Documentation',
+   'The cesium Team', 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+#latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+#latex_use_parts = False
+
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+#latex_appendices = []
+
+# If false, no module index is generated.
+#latex_domain_indices = True
+
+
+# -- Options for manual page output ---------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    (master_doc, 'cesium', 'cesium Documentation',
+     [author], 1)
+]
+
+# If true, show URL addresses after external links.
+#man_show_urls = False
+
+
+# -- Options for Texinfo output -------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+  (master_doc, 'cesium', 'cesium Documentation',
+   author, 'cesium', 'One line description of project.',
+   'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+#texinfo_appendices = []
+
+# If false, no module index is generated.
+#texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#texinfo_show_urls = 'footnote'
+
+# If true, do not generate a @detailmenu in the "Top" node's menu.
+#texinfo_no_detailmenu = False
+
+
+# -- Build cesium API documentation ----------------------------------------
+sys.path.append(os.path.join(os.path.dirname(__name__), '..'))
+sys.path.append(os.path.join(os.path.dirname(__name__), 'tools'))
+from apigen import ApiDocWriter
+import cesium
+package = 'cesium'
+module = sys.modules[package]
+
+outdir = 'api'
+docwriter = ApiDocWriter(package)
+docwriter.write_api_docs(outdir)
+docwriter.write_index(outdir, 'api', relative_to='api')
+print('%d files written' % len(docwriter.written_modules))
+
+# -- Write feature tables --------------------------------------------------
+from feature_table import write_feature_tables
+write_feature_tables('./feature_table.rst')
+
+def setup(app):
+    app.add_stylesheet("output_cells.css")
```

### Comparing `cesium-0.9.7/doc/Makefile` & `cesium-0.9.9/doc/Makefile`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,196 +1,196 @@
-# Makefile for Sphinx documentation
-#
-
-# You can set these variables from the command line.
-SPHINXOPTS    =
-SPHINXBUILD   = sphinx-build
-PAPER         =
-BUILDDIR      = _build
-
-# User-friendly check for sphinx-build
-ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)
-$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)
-endif
-
-# Internal variables.
-PAPEROPT_a4     = -D latex_paper_size=a4
-PAPEROPT_letter = -D latex_paper_size=letter
-ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
-# the i18n builder cannot share the environment and doctrees with the others
-I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
-
-.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest coverage gettext
-
-help:
-	@echo "Please use \`make <target>' where <target> is one of"
-	@echo "  html       to make standalone HTML files"
-	@echo "  dirhtml    to make HTML files named index.html in directories"
-	@echo "  singlehtml to make a single large HTML file"
-	@echo "  pickle     to make pickle files"
-	@echo "  json       to make JSON files"
-	@echo "  htmlhelp   to make HTML files and a HTML help project"
-	@echo "  qthelp     to make HTML files and a qthelp project"
-	@echo "  applehelp  to make an Apple Help Book"
-	@echo "  devhelp    to make HTML files and a Devhelp project"
-	@echo "  epub       to make an epub"
-	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
-	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
-	@echo "  latexpdfja to make LaTeX files and run them through platex/dvipdfmx"
-	@echo "  text       to make text files"
-	@echo "  man        to make manual pages"
-	@echo "  texinfo    to make Texinfo files"
-	@echo "  info       to make Texinfo files and run them through makeinfo"
-	@echo "  gettext    to make PO message catalogs"
-	@echo "  changes    to make an overview of all changed/added/deprecated items"
-	@echo "  xml        to make Docutils-native XML files"
-	@echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
-	@echo "  linkcheck  to check all external links for integrity"
-	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
-	@echo "  coverage   to run coverage check of the documentation (if enabled)"
-
-clean:
-	rm -rf $(BUILDDIR)/*
-	rm -rf api/
-	rm -rf examples/*output* examples/*ipynb
-	rm -rf auto_examples
-	rm -rf modules/
-
-html:
-	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
-	@echo
-	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
-
-dirhtml:
-	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
-	@echo
-	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
-
-singlehtml:
-	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
-	@echo
-	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
-
-pickle:
-	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
-	@echo
-	@echo "Build finished; now you can process the pickle files."
-
-json:
-	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
-	@echo
-	@echo "Build finished; now you can process the JSON files."
-
-htmlhelp:
-	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
-	@echo
-	@echo "Build finished; now you can run HTML Help Workshop with the" \
-	      ".hhp project file in $(BUILDDIR)/htmlhelp."
-
-qthelp:
-	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
-	@echo
-	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
-	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
-	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/cesium.qhcp"
-	@echo "To view the help file:"
-	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/cesium.qhc"
-
-applehelp:
-	$(SPHINXBUILD) -b applehelp $(ALLSPHINXOPTS) $(BUILDDIR)/applehelp
-	@echo
-	@echo "Build finished. The help book is in $(BUILDDIR)/applehelp."
-	@echo "N.B. You won't be able to view it unless you put it in" \
-	      "~/Library/Documentation/Help or install it in your application" \
-	      "bundle."
-
-devhelp:
-	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
-	@echo
-	@echo "Build finished."
-	@echo "To view the help file:"
-	@echo "# mkdir -p $$HOME/.local/share/devhelp/cesium"
-	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/cesium"
-	@echo "# devhelp"
-
-epub:
-	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
-	@echo
-	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."
-
-latex:
-	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
-	@echo
-	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
-	@echo "Run \`make' in that directory to run these through (pdf)latex" \
-	      "(use \`make latexpdf' here to do that automatically)."
-
-latexpdf:
-	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
-	@echo "Running LaTeX files through pdflatex..."
-	$(MAKE) -C $(BUILDDIR)/latex all-pdf
-	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
-
-latexpdfja:
-	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
-	@echo "Running LaTeX files through platex and dvipdfmx..."
-	$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
-	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
-
-text:
-	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
-	@echo
-	@echo "Build finished. The text files are in $(BUILDDIR)/text."
-
-man:
-	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
-	@echo
-	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."
-
-texinfo:
-	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
-	@echo
-	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
-	@echo "Run \`make' in that directory to run these through makeinfo" \
-	      "(use \`make info' here to do that automatically)."
-
-info:
-	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
-	@echo "Running Texinfo files through makeinfo..."
-	make -C $(BUILDDIR)/texinfo info
-	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."
-
-gettext:
-	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
-	@echo
-	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."
-
-changes:
-	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
-	@echo
-	@echo "The overview file is in $(BUILDDIR)/changes."
-
-linkcheck:
-	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
-	@echo
-	@echo "Link check complete; look for any errors in the above output " \
-	      "or in $(BUILDDIR)/linkcheck/output.txt."
-
-doctest:
-	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
-	@echo "Testing of doctests in the sources finished, look at the " \
-	      "results in $(BUILDDIR)/doctest/output.txt."
-
-coverage:
-	$(SPHINXBUILD) -b coverage $(ALLSPHINXOPTS) $(BUILDDIR)/coverage
-	@echo "Testing of coverage in the sources finished, look at the " \
-	      "results in $(BUILDDIR)/coverage/python.txt."
-
-xml:
-	$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
-	@echo
-	@echo "Build finished. The XML files are in $(BUILDDIR)/xml."
-
-pseudoxml:
-	$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
-	@echo
-	@echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."
+# Makefile for Sphinx documentation
+#
+
+# You can set these variables from the command line.
+SPHINXOPTS    =
+SPHINXBUILD   = sphinx-build
+PAPER         =
+BUILDDIR      = _build
+
+# User-friendly check for sphinx-build
+ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)
+$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)
+endif
+
+# Internal variables.
+PAPEROPT_a4     = -D latex_paper_size=a4
+PAPEROPT_letter = -D latex_paper_size=letter
+ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+# the i18n builder cannot share the environment and doctrees with the others
+I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+
+.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest coverage gettext
+
+help:
+	@echo "Please use \`make <target>' where <target> is one of"
+	@echo "  html       to make standalone HTML files"
+	@echo "  dirhtml    to make HTML files named index.html in directories"
+	@echo "  singlehtml to make a single large HTML file"
+	@echo "  pickle     to make pickle files"
+	@echo "  json       to make JSON files"
+	@echo "  htmlhelp   to make HTML files and a HTML help project"
+	@echo "  qthelp     to make HTML files and a qthelp project"
+	@echo "  applehelp  to make an Apple Help Book"
+	@echo "  devhelp    to make HTML files and a Devhelp project"
+	@echo "  epub       to make an epub"
+	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
+	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
+	@echo "  latexpdfja to make LaTeX files and run them through platex/dvipdfmx"
+	@echo "  text       to make text files"
+	@echo "  man        to make manual pages"
+	@echo "  texinfo    to make Texinfo files"
+	@echo "  info       to make Texinfo files and run them through makeinfo"
+	@echo "  gettext    to make PO message catalogs"
+	@echo "  changes    to make an overview of all changed/added/deprecated items"
+	@echo "  xml        to make Docutils-native XML files"
+	@echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
+	@echo "  linkcheck  to check all external links for integrity"
+	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
+	@echo "  coverage   to run coverage check of the documentation (if enabled)"
+
+clean:
+	rm -rf $(BUILDDIR)/*
+	rm -rf api/
+	rm -rf examples/*output* examples/*ipynb
+	rm -rf auto_examples
+	rm -rf modules/
+
+html:
+	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
+
+dirhtml:
+	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
+
+singlehtml:
+	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
+	@echo
+	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
+
+pickle:
+	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
+	@echo
+	@echo "Build finished; now you can process the pickle files."
+
+json:
+	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
+	@echo
+	@echo "Build finished; now you can process the JSON files."
+
+htmlhelp:
+	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
+	@echo
+	@echo "Build finished; now you can run HTML Help Workshop with the" \
+	      ".hhp project file in $(BUILDDIR)/htmlhelp."
+
+qthelp:
+	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
+	@echo
+	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
+	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
+	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/cesium.qhcp"
+	@echo "To view the help file:"
+	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/cesium.qhc"
+
+applehelp:
+	$(SPHINXBUILD) -b applehelp $(ALLSPHINXOPTS) $(BUILDDIR)/applehelp
+	@echo
+	@echo "Build finished. The help book is in $(BUILDDIR)/applehelp."
+	@echo "N.B. You won't be able to view it unless you put it in" \
+	      "~/Library/Documentation/Help or install it in your application" \
+	      "bundle."
+
+devhelp:
+	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
+	@echo
+	@echo "Build finished."
+	@echo "To view the help file:"
+	@echo "# mkdir -p $$HOME/.local/share/devhelp/cesium"
+	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/cesium"
+	@echo "# devhelp"
+
+epub:
+	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
+	@echo
+	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."
+
+latex:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo
+	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
+	@echo "Run \`make' in that directory to run these through (pdf)latex" \
+	      "(use \`make latexpdf' here to do that automatically)."
+
+latexpdf:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through pdflatex..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+latexpdfja:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through platex and dvipdfmx..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+text:
+	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
+	@echo
+	@echo "Build finished. The text files are in $(BUILDDIR)/text."
+
+man:
+	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
+	@echo
+	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."
+
+texinfo:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo
+	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
+	@echo "Run \`make' in that directory to run these through makeinfo" \
+	      "(use \`make info' here to do that automatically)."
+
+info:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo "Running Texinfo files through makeinfo..."
+	make -C $(BUILDDIR)/texinfo info
+	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."
+
+gettext:
+	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
+	@echo
+	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."
+
+changes:
+	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
+	@echo
+	@echo "The overview file is in $(BUILDDIR)/changes."
+
+linkcheck:
+	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
+	@echo
+	@echo "Link check complete; look for any errors in the above output " \
+	      "or in $(BUILDDIR)/linkcheck/output.txt."
+
+doctest:
+	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
+	@echo "Testing of doctests in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/doctest/output.txt."
+
+coverage:
+	$(SPHINXBUILD) -b coverage $(ALLSPHINXOPTS) $(BUILDDIR)/coverage
+	@echo "Testing of coverage in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/coverage/python.txt."
+
+xml:
+	$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
+	@echo
+	@echo "Build finished. The XML files are in $(BUILDDIR)/xml."
+
+pseudoxml:
+	$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
+	@echo
+	@echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."
```

### Comparing `cesium-0.9.7/setup.py` & `cesium-0.9.9/setup.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,127 +1,131 @@
-#! /usr/bin/env python
-
-descr = """Machine Learning Time Series Platform
-
-https://github.com/cesium-ml/cesium
-
-"""
-
-DISTNAME            = 'cesium'
-DESCRIPTION         = 'Machine Learning Time-Series Platform'
-LONG_DESCRIPTION    = descr
-MAINTAINER          = 'cesium Team'
-MAINTAINER_EMAIL    = 'stefanv@berkeley.edu'
-URL                 = 'http://cesium-ml.org'
-LICENSE             = 'Modified BSD'
-DOWNLOAD_URL        = 'https://github.com/cesium-ml/cesium'
-PYTHON_VERSION      = (3, 4)
-
-import os
-import sys
-
-import setuptools
-from distutils.command.build_py import build_py
-
-
-def configuration(parent_package='', top_path=None):
-    if os.path.exists('MANIFEST'):
-         os.remove('MANIFEST')
-
-    from numpy.distutils.misc_util import Configuration
-    config = Configuration(None, parent_package, top_path)
-
-    config.set_options(
-            ignore_setup_xxx_py=True,
-            assume_default_configuration=True,
-            delegate_options_to_subpackages=True,
-            quiet=True)
-
-    config.add_subpackage('cesium')
-
-    return config
-
-
-with open('cesium/version.py') as fid:
-    for line in fid:
-        if line.startswith('version'):
-            VERSION = line.split('=')[-1].strip(' \'"\n')
-            break
-
-with open('requirements.txt') as fid:
-    INSTALL_REQUIRES = [l.split('#')[0].strip() for l in fid.readlines() if l
-                        and not l.startswith('git')]
-    INSTALL_REQUIRES = [pkg.replace('-', '_') for pkg in INSTALL_REQUIRES]
-
-
-# requirements for those browsing PyPI
-REQUIRES = [r.replace('>=', ' (>= ') + ')' if '=' in r else r
-            for r in INSTALL_REQUIRES]
-REQUIRES = [r.replace('==', ' (== ') for r in REQUIRES]
-
-
-if __name__ == "__main__":
-    try:
-        from numpy.distutils.core import setup
-        extra = {'configuration': configuration}
-        # do not risk updating numpy
-        INSTALL_REQUIRES = [r for r in INSTALL_REQUIRES if 'numpy' not in r]
-    except ImportError:
-        if len(sys.argv) >= 2 and ('--help' in sys.argv[1:] or
-                                   sys.argv[1] in ('--help-commands',
-                                                   'egg_info',
-                                                   '--version',
-                                                   'clean')):
-            # For these actions, NumPy is not required.
-            #
-            # They are required to succeed without Numpy for example when
-            # pip is used to install cesium when Numpy is not yet
-            # present in the system.
-            try:
-                from setuptools import setup
-            except ImportError:
-                from distutils.core import setup
-        else:
-            print('To install cesium from source, you will need numpy.\n' +
-                  'Install numpy with pip:\n' +
-                  '  pip install numpy\n'
-                  'Or using conda:\n'
-                  '  conda install numpy\n'
-                  'or use your operating system package manager.')
-            sys.exit(1)
-
-    setup(
-        name=DISTNAME,
-        description=DESCRIPTION,
-        long_description=LONG_DESCRIPTION,
-        maintainer=MAINTAINER,
-        maintainer_email=MAINTAINER_EMAIL,
-        url=URL,
-        license=LICENSE,
-        download_url=DOWNLOAD_URL,
-        version=VERSION,
-
-        classifiers=[
-            'Development Status :: 4 - Beta',
-            'Environment :: Console',
-            'Intended Audience :: Developers',
-            'Intended Audience :: Science/Research',
-            'License :: OSI Approved :: BSD License',
-            'Programming Language :: C',
-            'Programming Language :: Python :: 2',
-            'Programming Language :: Python :: 3',
-            'Topic :: Scientific/Engineering',
-            'Operating System :: Microsoft :: Windows',
-            'Operating System :: POSIX',
-            'Operating System :: Unix',
-            'Operating System :: MacOS',
-        ],
-
-        install_requires=INSTALL_REQUIRES,
-        setup_requires=['cython>=0.25'],
-        requires=REQUIRES,
-        configuration=configuration,
-        packages=setuptools.find_packages(exclude=['doc']),
-        include_package_data=True,
-        zip_safe=False,
-        cmdclass={'build_py': build_py},
-    )
+#! /usr/bin/env python
+
+descr = """Machine Learning Time Series Platform
+
+https://github.com/cesium-ml/cesium
+
+"""
+
+DISTNAME            = 'cesium'
+DESCRIPTION         = 'Machine Learning Time-Series Platform'
+LONG_DESCRIPTION    = descr
+MAINTAINER          = 'cesium Team'
+MAINTAINER_EMAIL    = 'stefanv@berkeley.edu'
+URL                 = 'http://cesium-ml.org'
+LICENSE             = 'Modified BSD'
+DOWNLOAD_URL        = 'https://github.com/cesium-ml/cesium'
+PYTHON_VERSION      = (3, 4)
+
+import os
+import sys
+
+import setuptools
+from distutils.command.build_py import build_py
+
+
+#os.environ["CC"] = "gcc"
+#os.environ["CXX"] = "gcc"
+
+
+def configuration(parent_package='', top_path=None):
+    if os.path.exists('MANIFEST'):
+         os.remove('MANIFEST')
+
+    from numpy.distutils.misc_util import Configuration
+    config = Configuration(None, parent_package, top_path)
+
+    config.set_options(
+            ignore_setup_xxx_py=True,
+            assume_default_configuration=True,
+            delegate_options_to_subpackages=True,
+            quiet=True)
+
+    config.add_subpackage('cesium')
+
+    return config
+
+
+with open('cesium/version.py') as fid:
+    for line in fid:
+        if line.startswith('version'):
+            VERSION = line.split('=')[-1].strip(' \'"\n')
+            break
+
+with open('requirements.txt') as fid:
+    INSTALL_REQUIRES = [l.split('#')[0].strip() for l in fid.readlines() if l
+                        and not l.startswith('git')]
+    INSTALL_REQUIRES = [pkg.replace('-', '_') for pkg in INSTALL_REQUIRES]
+
+
+# requirements for those browsing PyPI
+REQUIRES = [r.replace('>=', ' (>= ') + ')' if '=' in r else r
+            for r in INSTALL_REQUIRES]
+REQUIRES = [r.replace('==', ' (== ') for r in REQUIRES]
+
+
+if __name__ == "__main__":
+    try:
+        from numpy.distutils.core import setup
+        extra = {'configuration': configuration}
+        # do not risk updating numpy
+        INSTALL_REQUIRES = [r for r in INSTALL_REQUIRES if 'numpy' not in r]
+    except ImportError:
+        if len(sys.argv) >= 2 and ('--help' in sys.argv[1:] or
+                                   sys.argv[1] in ('--help-commands',
+                                                   'egg_info',
+                                                   '--version',
+                                                   'clean')):
+            # For these actions, NumPy is not required.
+            #
+            # They are required to succeed without Numpy for example when
+            # pip is used to install cesium when Numpy is not yet
+            # present in the system.
+            try:
+                from setuptools import setup
+            except ImportError:
+                from distutils.core import setup
+        else:
+            print('To install cesium from source, you will need numpy.\n' +
+                  'Install numpy with pip:\n' +
+                  '  pip install numpy\n'
+                  'Or using conda:\n'
+                  '  conda install numpy\n'
+                  'or use your operating system package manager.')
+            sys.exit(1)
+
+    setup(
+        name=DISTNAME,
+        description=DESCRIPTION,
+        long_description=LONG_DESCRIPTION,
+        maintainer=MAINTAINER,
+        maintainer_email=MAINTAINER_EMAIL,
+        url=URL,
+        license=LICENSE,
+        download_url=DOWNLOAD_URL,
+        version=VERSION,
+
+        classifiers=[
+            'Development Status :: 4 - Beta',
+            'Environment :: Console',
+            'Intended Audience :: Developers',
+            'Intended Audience :: Science/Research',
+            'License :: OSI Approved :: BSD License',
+            'Programming Language :: C',
+            'Programming Language :: Python :: 2',
+            'Programming Language :: Python :: 3',
+            'Topic :: Scientific/Engineering',
+            'Operating System :: Microsoft :: Windows',
+            'Operating System :: POSIX',
+            'Operating System :: Unix',
+            'Operating System :: MacOS',
+        ],
+
+        install_requires=INSTALL_REQUIRES,
+        setup_requires=['cython>=0.25'],
+        requires=REQUIRES,
+        configuration=configuration,
+        packages=setuptools.find_packages(exclude=['doc']),
+        include_package_data=True,
+        zip_safe=False,
+        cmdclass={'build_py': build_py},
+    )
```

### Comparing `cesium-0.9.7/LICENSE.txt` & `cesium-0.9.9/LICENSE.txt`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-Unless otherwise specified by LICENSE.txt files in individual
-directories, all code is
-
-Copyright (C) 2016, the cesium team
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in
-    the documentation and/or other materials provided with the
-    distribution.
- 3. Neither the name of cesium nor the names of its contributors may be
-    used to endorse or promote products derived from this software without
-    specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
+Unless otherwise specified by LICENSE.txt files in individual
+directories, all code is
+
+Copyright (C) 2016, the cesium team
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in
+    the documentation and/or other materials provided with the
+    distribution.
+ 3. Neither the name of cesium nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `cesium-0.9.7/RELEASE.txt` & `cesium-0.9.9/RELEASE.txt`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-How to make a new release of ``cesium``
-=======================================
-
-- Update the version number in ``cesium/version.py`` and commit
-
-- Add the version number as a tag in git::
-
-   git tag -m "Description of release" v0.X.Y
-
-- Push the new meta-data to github::
-
-   git push --tags origin master
-
-- Publish on PyPi::
-
-   python setup.py sdist upload
-
-- Update the version in `wheel_builder/.travis.yml` to build new wheels
-
-- Download wheels from wheels.scipy.org, e.g.:
-
-CESIUM=0.X.Y
-wget -r --no-parent -A "cesium-$CESIUM*whl" http://wheels.scipy.org
-for WHEEL in `ls wheels.scipy.org`; do
-  twine upload wheels.scipy.org/$WHEEL
-done
+How to make a new release of ``cesium``
+=======================================
+
+- Update the version number in ``cesium/version.py`` and commit
+
+- Add the version number as a tag in git::
+
+   git tag -m "Description of release" v0.X.Y
+
+- Push the new meta-data to github::
+
+   git push --tags origin master
+
+- Publish on PyPi::
+
+   python setup.py sdist upload
+
+- Update the version in `wheel_builder/.travis.yml` to build new wheels
+
+- Download wheels from wheels.scipy.org, e.g.:
+
+CESIUM=0.X.Y
+wget -r --no-parent -A "cesium-$CESIUM*whl" http://wheels.scipy.org
+for WHEEL in `ls wheels.scipy.org`; do
+  twine upload wheels.scipy.org/$WHEEL
+done
```

### Comparing `cesium-0.9.7/cesium.egg-info/PKG-INFO` & `cesium-0.9.9/cesium.egg-info/PKG-INFO`

 * *Files 12% similar despite different names*

```diff
@@ -1,37 +1,36 @@
-Metadata-Version: 1.1
-Name: cesium
-Version: 0.9.7
-Summary: Machine Learning Time-Series Platform
-Home-page: http://cesium-ml.org
-Author: cesium Team
-Author-email: stefanv@berkeley.edu
-License: Modified BSD
-Download-URL: https://github.com/cesium-ml/cesium
-Description-Content-Type: UNKNOWN
-Description: Machine Learning Time Series Platform
-        
-        https://github.com/cesium-ml/cesium
-        
-        
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: Environment :: Console
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: BSD License
-Classifier: Programming Language :: C
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 3
-Classifier: Topic :: Scientific/Engineering
-Classifier: Operating System :: Microsoft :: Windows
-Classifier: Operating System :: POSIX
-Classifier: Operating System :: Unix
-Classifier: Operating System :: MacOS
-Requires: numpy (>= 1.12.1)
-Requires: scipy (>= 0.16.0)
-Requires: scikit_learn (>= 0.18.1)
-Requires: pandas (>= 0.17.0)
-Requires: dask (>= 0.15.0)
-Requires: toolz
-Requires: gatspy (>= 0.3.0)
-Requires: cloudpickle
+Metadata-Version: 1.2
+Name: cesium
+Version: 0.9.9
+Summary: Machine Learning Time-Series Platform
+Home-page: http://cesium-ml.org
+Maintainer: cesium Team
+Maintainer-email: stefanv@berkeley.edu
+License: Modified BSD
+Download-URL: https://github.com/cesium-ml/cesium
+Description: Machine Learning Time Series Platform
+        
+        https://github.com/cesium-ml/cesium
+        
+        
+Platform: UNKNOWN
+Classifier: Development Status :: 4 - Beta
+Classifier: Environment :: Console
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: BSD License
+Classifier: Programming Language :: C
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 3
+Classifier: Topic :: Scientific/Engineering
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: POSIX
+Classifier: Operating System :: Unix
+Classifier: Operating System :: MacOS
+Requires: numpy (>= 1.14.3)
+Requires: scipy (>= 0.16.0)
+Requires: scikit_learn (>= 0.18.1)
+Requires: pandas (>= 0.17.0)
+Requires: dask (>= 1.0.0)
+Requires: toolz
+Requires: gatspy (>= 0.3.0)
+Requires: cloudpickle
```

### Comparing `cesium-0.9.7/cesium.egg-info/SOURCES.txt` & `cesium-0.9.9/cesium.egg-info/SOURCES.txt`

 * *Files identical despite different names*

