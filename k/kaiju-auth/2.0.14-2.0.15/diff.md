# Comparing `tmp/kaiju_auth-2.0.14-py3-none-any.whl.zip` & `tmp/kaiju_auth-2.0.15-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,21 +1,21 @@
-Zip file size: 23479 bytes, number of entries: 19
--rw-r--r--  2.0 unx       84 b- defN 23-Apr-18 15:23 kaiju_auth/__init__.py
--rw-r--r--  2.0 unx       60 b- defN 23-Apr-18 15:23 kaiju_auth/etc.py
--rw-r--r--  2.0 unx     3765 b- defN 23-Apr-18 15:23 kaiju_auth/fixtures.py
--rw-r--r--  2.0 unx     5848 b- defN 23-Apr-18 15:23 kaiju_auth/http.py
--rw-r--r--  2.0 unx     7646 b- defN 23-Apr-18 15:23 kaiju_auth/login.py
--rw-r--r--  2.0 unx      320 b- defN 23-Apr-18 15:23 kaiju_auth/services.py
--rw-r--r--  2.0 unx     1811 b- defN 23-Apr-18 15:23 kaiju_auth/sessions.py
--rw-r--r--  2.0 unx     2892 b- defN 23-Apr-18 15:23 kaiju_auth/tables.py
--rw-r--r--  2.0 unx    11541 b- defN 23-Apr-18 15:23 kaiju_auth/tokens.py
--rw-r--r--  2.0 unx    27759 b- defN 23-Apr-18 15:23 kaiju_auth/users.py
--rw-r--r--  2.0 unx       55 b- defN 23-Apr-18 15:23 kaiju_auth/permissions_gui/__init__.py
--rw-r--r--  2.0 unx     3051 b- defN 23-Apr-18 15:23 kaiju_auth/permissions_gui/models.py
--rw-r--r--  2.0 unx    17380 b- defN 23-Apr-18 15:23 kaiju_auth/permissions_gui/service.py
--rw-r--r--  2.0 unx     1151 b- defN 23-Apr-18 15:23 kaiju_auth/permissions_gui/validators.py
--rw-rw-rw-  2.0 unx      610 b- defN 23-Apr-18 15:23 kaiju_auth-2.0.14.dist-info/LICENSE
--rw-r--r--  2.0 unx     2900 b- defN 23-Apr-18 15:23 kaiju_auth-2.0.14.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-18 15:23 kaiju_auth-2.0.14.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 23-Apr-18 15:23 kaiju_auth-2.0.14.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1551 b- defN 23-Apr-18 15:23 kaiju_auth-2.0.14.dist-info/RECORD
-19 files, 88527 bytes uncompressed, 20951 bytes compressed:  76.3%
+Zip file size: 23547 bytes, number of entries: 19
+-rw-r--r--  2.0 unx       84 b- defN 23-Apr-21 15:00 kaiju_auth/__init__.py
+-rw-r--r--  2.0 unx       60 b- defN 23-Apr-21 15:00 kaiju_auth/etc.py
+-rw-r--r--  2.0 unx     3765 b- defN 23-Apr-21 15:00 kaiju_auth/fixtures.py
+-rw-r--r--  2.0 unx     5848 b- defN 23-Apr-21 15:00 kaiju_auth/http.py
+-rw-r--r--  2.0 unx     7646 b- defN 23-Apr-21 15:00 kaiju_auth/login.py
+-rw-r--r--  2.0 unx      320 b- defN 23-Apr-21 15:00 kaiju_auth/services.py
+-rw-r--r--  2.0 unx     1811 b- defN 23-Apr-21 15:00 kaiju_auth/sessions.py
+-rw-r--r--  2.0 unx     2892 b- defN 23-Apr-21 15:00 kaiju_auth/tables.py
+-rw-r--r--  2.0 unx    11541 b- defN 23-Apr-21 15:00 kaiju_auth/tokens.py
+-rw-r--r--  2.0 unx    27759 b- defN 23-Apr-21 15:00 kaiju_auth/users.py
+-rw-r--r--  2.0 unx       55 b- defN 23-Apr-21 15:00 kaiju_auth/permissions_gui/__init__.py
+-rw-r--r--  2.0 unx     3228 b- defN 23-Apr-21 15:00 kaiju_auth/permissions_gui/models.py
+-rw-r--r--  2.0 unx    18327 b- defN 23-Apr-21 15:00 kaiju_auth/permissions_gui/service.py
+-rw-r--r--  2.0 unx     1212 b- defN 23-Apr-21 15:00 kaiju_auth/permissions_gui/validators.py
+-rw-rw-rw-  2.0 unx      610 b- defN 23-Apr-21 15:01 kaiju_auth-2.0.15.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2893 b- defN 23-Apr-21 15:01 kaiju_auth-2.0.15.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-21 15:01 kaiju_auth-2.0.15.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 23-Apr-21 15:01 kaiju_auth-2.0.15.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1551 b- defN 23-Apr-21 15:01 kaiju_auth-2.0.15.dist-info/RECORD
+19 files, 89705 bytes uncompressed, 21019 bytes compressed:  76.6%
```

## zipnote {}

```diff
@@ -36,23 +36,23 @@
 
 Filename: kaiju_auth/permissions_gui/service.py
 Comment: 
 
 Filename: kaiju_auth/permissions_gui/validators.py
 Comment: 
 
-Filename: kaiju_auth-2.0.14.dist-info/LICENSE
+Filename: kaiju_auth-2.0.15.dist-info/LICENSE
 Comment: 
 
-Filename: kaiju_auth-2.0.14.dist-info/METADATA
+Filename: kaiju_auth-2.0.15.dist-info/METADATA
 Comment: 
 
-Filename: kaiju_auth-2.0.14.dist-info/WHEEL
+Filename: kaiju_auth-2.0.15.dist-info/WHEEL
 Comment: 
 
-Filename: kaiju_auth-2.0.14.dist-info/top_level.txt
+Filename: kaiju_auth-2.0.15.dist-info/top_level.txt
 Comment: 
 
-Filename: kaiju_auth-2.0.14.dist-info/RECORD
+Filename: kaiju_auth-2.0.15.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## kaiju_auth/__init__.py

```diff
@@ -1,4 +1,4 @@
 from .services import *
 
-__version__ = '2.0.14'
+__version__ = '2.0.15'
 __author__ = 'antonnidhoggr@me.com'
```

## kaiju_auth/permissions_gui/models.py

```diff
@@ -1,102 +1,102 @@
-import abc
-
-from kaiju_model.fields import StringField, BooleanField, PasswordField, MultiselectField
-from kaiju_model.model import BaseModel
-
-from kaiju_auth.permissions_gui.validators import *
-
-all = (
-    'GroupEditModel',
-    'GroupsViewModel',
-    'UsersViewModel',
-    'UserEditModel',
-    'UserChangePasswordViewModel',
-    'UserChangePasswordModel',
-    'UserCreateModel',
-    'UserChangePasswordAdminViewModel',
-    'AdminChangePasswordModel'
-)
-
-
-class UsersViewModel(BaseModel, abc.ABC):
-    id = StringField()
-    username = StringField()
-    full_name = StringField()
-    is_active = BooleanField()
-    is_blocked = BooleanField()
-
-
-class UserCreateModel(BaseModel, abc.ABC):
-    username = StringField(required=True)
-    full_name = StringField(required=True)
-    email = StringField(required=True)
-    password = PasswordField(new_password=True, required=True)
-    password_confirm = PasswordField(new_password=True, required=True,
-                                     field_validator=match_password_validator)
-
-
-class UserEditModel(BaseModel, abc.ABC):
-    id = StringField(is_system=True)
-    username = StringField(read_only=True)
-    full_name = StringField(required=False)
-    email = StringField(required=False)
-
-
-class UserChangePasswordViewModel(BaseModel, abc.ABC):
-    old_password = PasswordField()
-    password = PasswordField(new_password=True)
-    password_confirm = PasswordField(new_password=False)
-
-class UserChangePasswordAdminViewModel(BaseModel, abc.ABC):
-    password = PasswordField(new_password=True)
-    password_confirm = PasswordField(new_password=False)
-
-
-class UserChangePasswordModel(BaseModel, abc.ABC):
-    old_password = PasswordField(required=True)
-    password = PasswordField(new_password=True, required=True)
-    password_confirm = PasswordField(
-        new_password=True,
-        required=True,
-        field_validator=match_password_validator
-    )
-
-class AdminChangePasswordModel(BaseModel, abc.ABC):
-    password = PasswordField(new_password=True, required=True)
-    password_confirm = PasswordField(
-        new_password=True,
-        required=True,
-        field_validator=match_password_validator
-    )
-
-
-class UserGroupsModel(BaseModel, abc.ABC):
-    groups = MultiselectField(required=True,
-                              options_handler="groups_gui.load")
-
-
-class UserGroupsUpdateModel(BaseModel, abc.ABC):
-    groups = MultiselectField(required=True,
-                              field_validator=group_exists,
-                              options_handler="groups_gui.load")
-
-
-class UserStatusUpdateModel(BaseModel, abc.ABC):
-    is_blocked = BooleanField()
-    is_active = BooleanField()
-
-
-class GroupsViewModel(BaseModel, abc.ABC):
-    id = StringField()
-    description = StringField()
-    tag = StringField()
-
-
-class GroupEditModel(BaseModel, abc.ABC):
-    id = StringField(field_validator=group_exists, read_only=True)
-    description = StringField()
-
-
-class GroupCreateModel(BaseModel, abc.ABC):
-    id = StringField(field_validator=group_not_exists)
-    description = StringField()
+# import abc
+#
+# from kaiju_model.fields import StringField, BooleanField, PasswordField, MultiselectField
+# from kaiju_model.model import BaseModel
+#
+# from kaiju_auth.permissions_gui.validators import *
+#
+# all = (
+#     'GroupEditModel',
+#     'GroupsViewModel',
+#     'UsersViewModel',
+#     'UserEditModel',
+#     'UserChangePasswordViewModel',
+#     'UserChangePasswordModel',
+#     'UserCreateModel',
+#     'UserChangePasswordAdminViewModel',
+#     'AdminChangePasswordModel'
+# )
+#
+#
+# class UsersViewModel(BaseModel, abc.ABC):
+#     id = StringField()
+#     username = StringField()
+#     full_name = StringField()
+#     is_active = BooleanField()
+#     is_blocked = BooleanField()
+#
+#
+# class UserCreateModel(BaseModel, abc.ABC):
+#     username = StringField(required=True)
+#     full_name = StringField(required=True)
+#     email = StringField(required=True)
+#     password = PasswordField(new_password=True, required=True)
+#     password_confirm = PasswordField(new_password=True, required=True,
+#                                      field_validator=match_password_validator)
+#
+#
+# class UserEditModel(BaseModel, abc.ABC):
+#     id = StringField(is_system=True)
+#     username = StringField(read_only=True)
+#     full_name = StringField(required=False)
+#     email = StringField(required=False)
+#
+#
+# class UserChangePasswordViewModel(BaseModel, abc.ABC):
+#     old_password = PasswordField()
+#     password = PasswordField(new_password=True)
+#     password_confirm = PasswordField(new_password=False)
+#
+# class UserChangePasswordAdminViewModel(BaseModel, abc.ABC):
+#     password = PasswordField(new_password=True)
+#     password_confirm = PasswordField(new_password=False)
+#
+#
+# class UserChangePasswordModel(BaseModel, abc.ABC):
+#     old_password = PasswordField(required=True)
+#     password = PasswordField(new_password=True, required=True)
+#     password_confirm = PasswordField(
+#         new_password=True,
+#         required=True,
+#         field_validator=match_password_validator
+#     )
+#
+# class AdminChangePasswordModel(BaseModel, abc.ABC):
+#     password = PasswordField(new_password=True, required=True)
+#     password_confirm = PasswordField(
+#         new_password=True,
+#         required=True,
+#         field_validator=match_password_validator
+#     )
+#
+#
+# class UserGroupsModel(BaseModel, abc.ABC):
+#     groups = MultiselectField(required=True,
+#                               options_handler="groups_gui.load")
+#
+#
+# class UserGroupsUpdateModel(BaseModel, abc.ABC):
+#     groups = MultiselectField(required=True,
+#                               field_validator=group_exists,
+#                               options_handler="groups_gui.load")
+#
+#
+# class UserStatusUpdateModel(BaseModel, abc.ABC):
+#     is_blocked = BooleanField()
+#     is_active = BooleanField()
+#
+#
+# class GroupsViewModel(BaseModel, abc.ABC):
+#     id = StringField()
+#     description = StringField()
+#     tag = StringField()
+#
+#
+# class GroupEditModel(BaseModel, abc.ABC):
+#     id = StringField(field_validator=group_exists, read_only=True)
+#     description = StringField()
+#
+#
+# class GroupCreateModel(BaseModel, abc.ABC):
+#     id = StringField(field_validator=group_not_exists)
+#     description = StringField()
```

## kaiju_auth/permissions_gui/service.py

```diff
@@ -1,526 +1,526 @@
-"""
-Methods for groups, users and permission gui
-"""
-
-from typing import Union
-from uuid import UUID
-
-import sqlalchemy as sa
-from kaiju_db.services import SQLService, DatabaseService
-from kaiju_model.grid.constructor import GridConstructor
-from kaiju_model.model import ModelValidationException
-from kaiju_tools.exceptions import NotFound, ValidationError, NotAuthorized, PermissionDenied
-from kaiju_tools.rpc.abc import AbstractRPCCompatible
-from kaiju_tools.services import Contextable
-
-from kaiju_auth.models import groups, users
-from kaiju_auth.permissions_gui.models import (
-    GroupsViewModel, GroupEditModel,
-    GroupCreateModel, UserCreateModel,
-    UsersViewModel, UserEditModel,
-    UserChangePasswordModel, UserChangePasswordViewModel,
-    UserGroupsModel, UserGroupsUpdateModel, UserStatusUpdateModel, UserChangePasswordAdminViewModel,
-    AdminChangePasswordModel
-)
-from kaiju_auth.services import *
-
-__all__ = ('UserGUIService', 'GroupGUIService')
-
-
-class UserGUIService(SQLService, Contextable, AbstractRPCCompatible):
-    fields = ["username", "full_name", "is_blocked", "is_active"]
-    service_name = "users_gui"
-    table = users
-    db_service_class = DatabaseService
-    user_service_class = UserService
-    group_service_class = GroupService
-
-    def __init__(self, *args, user_service: Union[str, UserService] = None,
-                 group_service: Union[str, GroupService] = None, **kwargs):
-        super().__init__(*args, **kwargs)
-        self._user_service: UserService = user_service
-        self._group_service: GroupService = group_service
-        self.user_groups_table = None
-
-    async def init(self):
-        self._user_service = self.discover_service(self._user_service, cls=self.user_service_class)
-        self.user_groups_table = self._user_service.user_groups_table
-        self._group_service = self.discover_service(self._group_service, cls=self.group_service_class)
-
-    @property
-    def routes(self) -> dict:
-        return {
-            "grid": self.grid,
-            "load": self.load,
-            "get": self.get_user,
-            "create_model": self.get_create_model,
-            "create_user": self.create_user,
-            "password_model": self.get_password_model,
-            "groups_model": self.get_user_groups_model,
-            "update_groups": self.update_user_groups,
-            "change_password": self.change_user_password,
-            "update_status": self.set_user_status,
-            "update_info": self.update_user_info,
-            "status_model": self.get_user_status_model,
-            "modify_group_users": self.update_group_users
-        }
-
-    @property
-    def permissions(self):
-        return {
-            self.DEFAULT_PERMISSION: self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION,
-            "load": self.PermissionKeys.GLOBAL_USER_PERMISSION,
-            "password_model": self.PermissionKeys.GLOBAL_USER_PERMISSION,
-            "change_password": self.PermissionKeys.GLOBAL_USER_PERMISSION,
-            "update_info": self.PermissionKeys.GLOBAL_USER_PERMISSION,
-            "get": self.PermissionKeys.GLOBAL_USER_PERMISSION
-        }
-
-    async def _get_user(self, session, id):
-        conditions = {}
-
-        if type(id) is UUID:
-            conditions["id"] = str(id)
-        else:
-            conditions["username"] = id
-
-        data = await self.list(
-            conditions=conditions
-        )
-        if not data["count"]:
-            raise NotFound
-
-        current_user_id = session["user_id"]
-        permissions = session.get("permissions", set())
-
-        user = data["data"][0]
-
-        if current_user_id != user["id"]:
-            if self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION not in permissions:
-                raise PermissionDenied(code="message.403")
-
-        return user
-
-    async def get_user(self, session, id=None):
-
-        user = await self._get_user(session, id)
-
-        async with UserEditModel(self.app, init=False, **user) as obj:
-            result = obj.fields
-            return result
-
-    async def get_password_model(self, session, **__):
-        if self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION in session["permissions"]:
-            model = UserChangePasswordAdminViewModel
-        else:
-            model = UserChangePasswordViewModel
-        async with model(self.app, init=False) as obj:
-            result = obj.fields
-            return result
-
-    async def get_user_groups_model(self, session, id, **__):
-        user = await self._get_user(session, id)
-        data = await self._user_service.get_user_groups(user["id"])
-
-        async with UserGroupsModel(self.app, groups=data["groups"], init=False) as obj:
-            result = obj.fields
-            return result
-
-    async def get_create_model(self, **__):
-        async with UserCreateModel(self.app, init=False) as obj:
-            result = obj.fields
-            return result
-
-    async def change_user_password(self, session, id, old_password=None, password=None, password_confirm=None):
-        user = await self._get_user(session, id)
-        username = user["username"]
-
-        if self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION in session["permissions"]:
-            model = AdminChangePasswordModel
-        else:
-            model = UserChangePasswordModel
-
-        async with model(self.app, old_password=old_password,
-                         password=password,
-                         password_confirm=password_confirm):
-            if old_password == password:
-                raise ValidationError(
-                    'Old password matches the new one.',
-                    code=self.ErrorCodes.USER_IDENTICAL_PASSWORDS_SUPPLIED)
-
-            if self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION not in session["permissions"]:
-                try:
-                    user = await self._user_service.auth(username=username, password=old_password)
-                    new_password = self._user_service.validate_password(password)
-                except NotAuthorized:
-                    raise ModelValidationException(fields={"old_password": [{"code": 'auth.user.wrong_password'}]})
-                except ValidationError as error:
-                    raise ModelValidationException(fields={error.data["key"]: [error.data]})
-
-            try:
-                new_password = self._user_service.validate_password(password)
-            except ValidationError as error:
-                raise ModelValidationException(fields={error.data["key"]: [error.data]})
-
-            await self._user_service.set_password(user["id"], user['username'], new_password)
-            return True
-
-    async def update_user_info(self, session, id, **kwargs):
-        user = await self._get_user(session, id)
-
-        if not kwargs:
-            return {
-                "updated": False
-            }
-
-        async with UserEditModel(self.app, **kwargs) as _:
-            if "email" in kwargs:
-                self._user_service.validate_email(kwargs["email"])
-
-            try:
-                await self._user_service.update(
-                    id=user["id"],
-                    data=kwargs
-                )
-            except ValidationError as error:
-                raise ModelValidationException(fields={error.data["key"]: [error.data]})
-
-            return {
-                "updated": True
-            }
-
-    async def load(self, id=None, page=None, per_page=None, query=None, **_):
-        if page is None:
-            page = 1
-
-        if per_page is None:
-            per_page = 24
-
-        result = await self.grid(id=id, page=page, per_page=per_page, query=query)
-        data = []
-
-        for i in result["data"]:
-            _id = list(i.values())[0]["id"]
-            data.append({
-                "id": _id,
-                "label": i.get("full_name", {}).get("value", f"[{_id}]") or f"[{_id}]",
-            })
-
-        return {
-            "count": result["count"],
-            "pagination": result["pagination"],
-            "data": data
-        }
-
-    async def _get_group_users(self, id):
-        sql = sa.select([self.user_groups_table.c.user_id]).where(
-            self.user_groups_table.c.group_id == str(id)
-        )
-
-        users = await self._db.fetch(sql)
-        return [str(i["user_id"]) for i in users]
-
-    async def grid(self, page=1, per_page=24, group=None, query=None, **_):
-        conditions = {}
-
-        offset = (page - 1) * per_page
-
-        if group:
-            ids = await self._get_group_users(str(group))
-            if ids:
-                conditions["id"] = ids
-
-        if query:
-            conditions = [
-                {
-                    "username": {"~": query},
-                    **conditions
-                },
-                {
-                    "full_name": {"~": query},
-                    **conditions
-                }
-            ]
-
-        data = await self.list(
-            conditions=conditions if conditions else None,
-            offset=offset, limit=per_page)
-
-        count = data["count"]
-        pages = data["pages"]
-
-        models = []
-
-        for i in data["data"]:
-            models.append(UsersViewModel(self.app, **i))
-
-        async with GridConstructor(self.app, models=models, fields=self.fields) as gc:
-            return {
-                "data": list(gc),
-                "fields": self.fields,
-                "pagination": {
-                    "page": page,
-                    "pages": pages,
-                },
-                "count": count
-            }
-
-    async def create_user(self, username=None, email=None, full_name=None,
-                          password=None, password_confirm=None):
-
-        async with UserCreateModel(email=email, full_name=full_name, password=password,
-                                   username=username, password_confirm=password_confirm) as _:
-            try:
-
-                data = await self._user_service.register(
-                    username=username,
-                    email=email,
-                    full_name=full_name,
-                    password=password
-                )
-            except ValidationError as error:
-                raise ModelValidationException(fields={error.data["key"]: [error.data]})
-
-            return {
-                "id": data["id"]
-            }
-
-    async def update_user_groups(self, session, id, groups):
-
-        if not groups:
-            raise ValidationError(code="user_groups.no_groups")
-
-        user = await self._get_user(session, id)
-
-        async with UserGroupsUpdateModel(app=self.app, groups=groups) as _:
-            try:
-                await self._user_service.set_user_groups(
-                    id=user["id"],
-                    groups={group: True for group in groups}
-                )
-            except ValidationError as error:
-                raise ModelValidationException(fields={error.data["key"]: [error.data]})
-
-            return {
-                "updated": True
-            }
-
-    async def get_user_status_model(self, session, id, **__):
-        user = await self._get_user(session, id)
-
-        async with UserStatusUpdateModel(self.app, init=False, **user) as obj:
-            result = obj.fields
-            return result
-
-    async def set_user_status(self, session, id, **kwargs):
-        data_to_update = {}
-        user = await self._get_user(session, id)
-
-        if "is_active" in kwargs:
-            data_to_update["is_active"] = bool(kwargs["is_active"])
-
-        if "is_blocked" in kwargs:
-            data_to_update["is_blocked"] = bool(kwargs["is_blocked"])
-
-        await self.update(
-            id=user["id"],
-            data=data_to_update
-        )
-
-        return {
-            "updated": True
-        }
-
-    async def update_group_users(self, id, user_id):
-        await self._group_service.get(id)
-
-        if type(user_id) is str:
-            user_id = [user_id]
-
-        for _user_id in user_id:
-            await self.app.services.users.modify_user_groups(id=str(_user_id), groups={id: True})
-
-        return {
-            "updated": True
-        }
-
-
-class GroupGUIService(SQLService, Contextable, AbstractRPCCompatible):
-    service_name = 'groups_gui'
-    table = groups
-    db_service_class = DatabaseService
-    group_service_class = GroupService
-    fields = ["id", "description"]
-
-    def __init__(self, *args, group_service: Union[str, GroupService] = None, **kwargs):
-        super().__init__(*args, **kwargs)
-        self._group_service: GroupService = group_service
-
-    async def init(self):
-        self._group_service = self.discover_service(self._group_service, cls=self.group_service_class)
-
-    @property
-    def routes(self):
-        return {
-            "create": self.create,
-            "create_model": self.get_create_model,
-            "grid": self.grid,
-            "load": self.load,
-            "get": self.get_group,
-            "update_info": self.update_info,
-            "update_permissions": self.update_permissions,
-            "load_permissions": self.load_permissions
-        }
-
-    @property
-    def permissions(self):
-        return {
-            self.DEFAULT_PERMISSION: self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION
-        }
-
-    async def get_create_model(self, **__):
-        async with GroupCreateModel(self.app, init=False) as obj:
-            result = obj.fields
-            return result
-
-    async def create(self, id, description=None):
-
-        async with GroupCreateModel(self.app, id=id, description=description) as _:
-            await self._group_service.create(
-                data={
-                    'id': id,
-                    'description': description
-                },
-                columns=None
-            )
-
-            return {
-                "id": id
-            }
-
-    async def load(self, id=None, page=None, per_page=None, query=None, **_):
-        if page is None:
-            page = 1
-
-        if per_page is None:
-            per_page = 24
-
-        result = await self.grid(id=id, page=page, per_page=per_page, query=query)
-        data = []
-
-        for i in result["data"]:
-            _id = i["id"]["value"]
-            data.append({
-                "id": _id,
-                "label": i.get("description", {}).get("value", f"[{_id}]") or f"[{_id}]",
-            })
-
-        return {
-            "pagination": result["pagination"],
-            "data": data
-        }
-
-    async def grid(self, id=None, page=1, query=None, per_page=24, **_):
-        offset = (page - 1) * per_page
-
-        conditions = {}
-
-        if id and type(id) is list:
-            conditions["id"] = [str(id_) for id_ in id]
-        elif id:
-            conditions["id"] = str(id)
-
-        if query:
-            conditions = [
-                {
-                    "id": {"~": query},
-                    **conditions
-                },
-                {
-                    "description": {"~": query},
-                    **conditions
-                }
-            ]
-
-        data = await self.list(
-            conditions=conditions,
-            offset=offset, limit=per_page)
-
-        count = data["count"]
-        pages = data["pages"]
-
-        models = []
-
-        for i in data["data"]:
-            group = dict(i)
-            models.append(GroupsViewModel(self.app, **group))
-
-        async with GridConstructor(self.app, models=models, fields=self.fields) as gc:
-            return {
-                "data": list(gc),
-                "fields": self.fields,
-                "pagination": {
-                    "page": page,
-                    "pages": pages,
-                },
-                "count": count
-            }
-
-    async def get_group(self, id):
-        group = await self._group_service.get(id)
-        async with GroupEditModel(self.app, init=False, id=id, description=group["description"]) as obj:
-            result = obj.fields
-            return result
-
-    async def load_permissions(self, id=None, query=None, **_):
-        await self.get_group(id)
-
-        tags = await self._group_service._permission_service.get_all_permissions(group_by_tag=True, query=query)
-        group_permissions = await self._group_service.get_permissions(id)
-
-        data = []
-        for tag in tags:
-            permissions = [{
-                "id": permission["id"],
-                "label": permission["description"] or f"[{permission['id']}]",
-                "value": permission["id"] in group_permissions
-            } for permission in tag["permissions"]]
-
-            data.append({
-                "tag": tag["tag"],
-                "permissions": permissions,
-            })
-
-        return {
-            "data": data,
-            "pagination": {
-                "page": 1,
-                "pages": 1
-            }
-        }
-
-    async def update_info(self, id, **kwargs):
-        if not kwargs:
-            return {
-                "updated": False
-            }
-
-        async with GroupEditModel(self.app, **kwargs) as _:
-            if 'description' in kwargs:
-                await self._group_service.update(
-                    id=id,
-                    data={
-                        'description': kwargs["description"]
-                    }
-                )
-
-            return {
-                "updated": True
-            }
-
-    async def update_permissions(self, id, permissions):
-        await self._group_service.get(id)
-        await self._group_service.modify_permissions(id, permissions=permissions)
-        return {
-            "updated": True
-        }
+# """
+# Methods for groups, users and permission gui
+# """
+#
+# from typing import Union
+# from uuid import UUID
+#
+# import sqlalchemy as sa
+# from kaiju_db.services import SQLService, DatabaseService
+# from kaiju_model.grid.constructor import GridConstructor
+# from kaiju_model.model import ModelValidationException
+# from kaiju_tools.exceptions import NotFound, ValidationError, NotAuthorized, PermissionDenied
+# from kaiju_tools.rpc.abc import AbstractRPCCompatible
+# from kaiju_tools.services import Contextable
+#
+# from kaiju_auth.models import groups, users
+# from kaiju_auth.permissions_gui.models import (
+#     GroupsViewModel, GroupEditModel,
+#     GroupCreateModel, UserCreateModel,
+#     UsersViewModel, UserEditModel,
+#     UserChangePasswordModel, UserChangePasswordViewModel,
+#     UserGroupsModel, UserGroupsUpdateModel, UserStatusUpdateModel, UserChangePasswordAdminViewModel,
+#     AdminChangePasswordModel
+# )
+# from kaiju_auth.services import *
+#
+# __all__ = ('UserGUIService', 'GroupGUIService')
+#
+#
+# class UserGUIService(SQLService, Contextable, AbstractRPCCompatible):
+#     fields = ["username", "full_name", "is_blocked", "is_active"]
+#     service_name = "users_gui"
+#     table = users
+#     db_service_class = DatabaseService
+#     user_service_class = UserService
+#     group_service_class = GroupService
+#
+#     def __init__(self, *args, user_service: Union[str, UserService] = None,
+#                  group_service: Union[str, GroupService] = None, **kwargs):
+#         super().__init__(*args, **kwargs)
+#         self._user_service: UserService = user_service
+#         self._group_service: GroupService = group_service
+#         self.user_groups_table = None
+#
+#     async def init(self):
+#         self._user_service = self.discover_service(self._user_service, cls=self.user_service_class)
+#         self.user_groups_table = self._user_service.user_groups_table
+#         self._group_service = self.discover_service(self._group_service, cls=self.group_service_class)
+#
+#     @property
+#     def routes(self) -> dict:
+#         return {
+#             "grid": self.grid,
+#             "load": self.load,
+#             "get": self.get_user,
+#             "create_model": self.get_create_model,
+#             "create_user": self.create_user,
+#             "password_model": self.get_password_model,
+#             "groups_model": self.get_user_groups_model,
+#             "update_groups": self.update_user_groups,
+#             "change_password": self.change_user_password,
+#             "update_status": self.set_user_status,
+#             "update_info": self.update_user_info,
+#             "status_model": self.get_user_status_model,
+#             "modify_group_users": self.update_group_users
+#         }
+#
+#     @property
+#     def permissions(self):
+#         return {
+#             self.DEFAULT_PERMISSION: self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION,
+#             "load": self.PermissionKeys.GLOBAL_USER_PERMISSION,
+#             "password_model": self.PermissionKeys.GLOBAL_USER_PERMISSION,
+#             "change_password": self.PermissionKeys.GLOBAL_USER_PERMISSION,
+#             "update_info": self.PermissionKeys.GLOBAL_USER_PERMISSION,
+#             "get": self.PermissionKeys.GLOBAL_USER_PERMISSION
+#         }
+#
+#     async def _get_user(self, session, id):
+#         conditions = {}
+#
+#         if type(id) is UUID:
+#             conditions["id"] = str(id)
+#         else:
+#             conditions["username"] = id
+#
+#         data = await self.list(
+#             conditions=conditions
+#         )
+#         if not data["count"]:
+#             raise NotFound
+#
+#         current_user_id = session["user_id"]
+#         permissions = session.get("permissions", set())
+#
+#         user = data["data"][0]
+#
+#         if current_user_id != user["id"]:
+#             if self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION not in permissions:
+#                 raise PermissionDenied(code="message.403")
+#
+#         return user
+#
+#     async def get_user(self, session, id=None):
+#
+#         user = await self._get_user(session, id)
+#
+#         async with UserEditModel(self.app, init=False, **user) as obj:
+#             result = obj.fields
+#             return result
+#
+#     async def get_password_model(self, session, **__):
+#         if self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION in session["permissions"]:
+#             model = UserChangePasswordAdminViewModel
+#         else:
+#             model = UserChangePasswordViewModel
+#         async with model(self.app, init=False) as obj:
+#             result = obj.fields
+#             return result
+#
+#     async def get_user_groups_model(self, session, id, **__):
+#         user = await self._get_user(session, id)
+#         data = await self._user_service.get_user_groups(user["id"])
+#
+#         async with UserGroupsModel(self.app, groups=data["groups"], init=False) as obj:
+#             result = obj.fields
+#             return result
+#
+#     async def get_create_model(self, **__):
+#         async with UserCreateModel(self.app, init=False) as obj:
+#             result = obj.fields
+#             return result
+#
+#     async def change_user_password(self, session, id, old_password=None, password=None, password_confirm=None):
+#         user = await self._get_user(session, id)
+#         username = user["username"]
+#
+#         if self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION in session["permissions"]:
+#             model = AdminChangePasswordModel
+#         else:
+#             model = UserChangePasswordModel
+#
+#         async with model(self.app, old_password=old_password,
+#                          password=password,
+#                          password_confirm=password_confirm):
+#             if old_password == password:
+#                 raise ValidationError(
+#                     'Old password matches the new one.',
+#                     code=self.ErrorCodes.USER_IDENTICAL_PASSWORDS_SUPPLIED)
+#
+#             if self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION not in session["permissions"]:
+#                 try:
+#                     user = await self._user_service.auth(username=username, password=old_password)
+#                     new_password = self._user_service.validate_password(password)
+#                 except NotAuthorized:
+#                     raise ModelValidationException(fields={"old_password": [{"code": 'auth.user.wrong_password'}]})
+#                 except ValidationError as error:
+#                     raise ModelValidationException(fields={error.data["key"]: [error.data]})
+#
+#             try:
+#                 new_password = self._user_service.validate_password(password)
+#             except ValidationError as error:
+#                 raise ModelValidationException(fields={error.data["key"]: [error.data]})
+#
+#             await self._user_service.set_password(user["id"], user['username'], new_password)
+#             return True
+#
+#     async def update_user_info(self, session, id, **kwargs):
+#         user = await self._get_user(session, id)
+#
+#         if not kwargs:
+#             return {
+#                 "updated": False
+#             }
+#
+#         async with UserEditModel(self.app, **kwargs) as _:
+#             if "email" in kwargs:
+#                 self._user_service.validate_email(kwargs["email"])
+#
+#             try:
+#                 await self._user_service.update(
+#                     id=user["id"],
+#                     data=kwargs
+#                 )
+#             except ValidationError as error:
+#                 raise ModelValidationException(fields={error.data["key"]: [error.data]})
+#
+#             return {
+#                 "updated": True
+#             }
+#
+#     async def load(self, id=None, page=None, per_page=None, query=None, **_):
+#         if page is None:
+#             page = 1
+#
+#         if per_page is None:
+#             per_page = 24
+#
+#         result = await self.grid(id=id, page=page, per_page=per_page, query=query)
+#         data = []
+#
+#         for i in result["data"]:
+#             _id = list(i.values())[0]["id"]
+#             data.append({
+#                 "id": _id,
+#                 "label": i.get("full_name", {}).get("value", f"[{_id}]") or f"[{_id}]",
+#             })
+#
+#         return {
+#             "count": result["count"],
+#             "pagination": result["pagination"],
+#             "data": data
+#         }
+#
+#     async def _get_group_users(self, id):
+#         sql = sa.select([self.user_groups_table.c.user_id]).where(
+#             self.user_groups_table.c.group_id == str(id)
+#         )
+#
+#         users = await self._db.fetch(sql)
+#         return [str(i["user_id"]) for i in users]
+#
+#     async def grid(self, page=1, per_page=24, group=None, query=None, **_):
+#         conditions = {}
+#
+#         offset = (page - 1) * per_page
+#
+#         if group:
+#             ids = await self._get_group_users(str(group))
+#             if ids:
+#                 conditions["id"] = ids
+#
+#         if query:
+#             conditions = [
+#                 {
+#                     "username": {"~": query},
+#                     **conditions
+#                 },
+#                 {
+#                     "full_name": {"~": query},
+#                     **conditions
+#                 }
+#             ]
+#
+#         data = await self.list(
+#             conditions=conditions if conditions else None,
+#             offset=offset, limit=per_page)
+#
+#         count = data["count"]
+#         pages = data["pages"]
+#
+#         models = []
+#
+#         for i in data["data"]:
+#             models.append(UsersViewModel(self.app, **i))
+#
+#         async with GridConstructor(self.app, models=models, fields=self.fields) as gc:
+#             return {
+#                 "data": list(gc),
+#                 "fields": self.fields,
+#                 "pagination": {
+#                     "page": page,
+#                     "pages": pages,
+#                 },
+#                 "count": count
+#             }
+#
+#     async def create_user(self, username=None, email=None, full_name=None,
+#                           password=None, password_confirm=None):
+#
+#         async with UserCreateModel(email=email, full_name=full_name, password=password,
+#                                    username=username, password_confirm=password_confirm) as _:
+#             try:
+#
+#                 data = await self._user_service.register(
+#                     username=username,
+#                     email=email,
+#                     full_name=full_name,
+#                     password=password
+#                 )
+#             except ValidationError as error:
+#                 raise ModelValidationException(fields={error.data["key"]: [error.data]})
+#
+#             return {
+#                 "id": data["id"]
+#             }
+#
+#     async def update_user_groups(self, session, id, groups):
+#
+#         if not groups:
+#             raise ValidationError(code="user_groups.no_groups")
+#
+#         user = await self._get_user(session, id)
+#
+#         async with UserGroupsUpdateModel(app=self.app, groups=groups) as _:
+#             try:
+#                 await self._user_service.set_user_groups(
+#                     id=user["id"],
+#                     groups={group: True for group in groups}
+#                 )
+#             except ValidationError as error:
+#                 raise ModelValidationException(fields={error.data["key"]: [error.data]})
+#
+#             return {
+#                 "updated": True
+#             }
+#
+#     async def get_user_status_model(self, session, id, **__):
+#         user = await self._get_user(session, id)
+#
+#         async with UserStatusUpdateModel(self.app, init=False, **user) as obj:
+#             result = obj.fields
+#             return result
+#
+#     async def set_user_status(self, session, id, **kwargs):
+#         data_to_update = {}
+#         user = await self._get_user(session, id)
+#
+#         if "is_active" in kwargs:
+#             data_to_update["is_active"] = bool(kwargs["is_active"])
+#
+#         if "is_blocked" in kwargs:
+#             data_to_update["is_blocked"] = bool(kwargs["is_blocked"])
+#
+#         await self.update(
+#             id=user["id"],
+#             data=data_to_update
+#         )
+#
+#         return {
+#             "updated": True
+#         }
+#
+#     async def update_group_users(self, id, user_id):
+#         await self._group_service.get(id)
+#
+#         if type(user_id) is str:
+#             user_id = [user_id]
+#
+#         for _user_id in user_id:
+#             await self.app.services.users.modify_user_groups(id=str(_user_id), groups={id: True})
+#
+#         return {
+#             "updated": True
+#         }
+#
+#
+# class GroupGUIService(SQLService, Contextable, AbstractRPCCompatible):
+#     service_name = 'groups_gui'
+#     table = groups
+#     db_service_class = DatabaseService
+#     group_service_class = GroupService
+#     fields = ["id", "description"]
+#
+#     def __init__(self, *args, group_service: Union[str, GroupService] = None, **kwargs):
+#         super().__init__(*args, **kwargs)
+#         self._group_service: GroupService = group_service
+#
+#     async def init(self):
+#         self._group_service = self.discover_service(self._group_service, cls=self.group_service_class)
+#
+#     @property
+#     def routes(self):
+#         return {
+#             "create": self.create,
+#             "create_model": self.get_create_model,
+#             "grid": self.grid,
+#             "load": self.load,
+#             "get": self.get_group,
+#             "update_info": self.update_info,
+#             "update_permissions": self.update_permissions,
+#             "load_permissions": self.load_permissions
+#         }
+#
+#     @property
+#     def permissions(self):
+#         return {
+#             self.DEFAULT_PERMISSION: self.PermissionKeys.GLOBAL_SYSTEM_PERMISSION
+#         }
+#
+#     async def get_create_model(self, **__):
+#         async with GroupCreateModel(self.app, init=False) as obj:
+#             result = obj.fields
+#             return result
+#
+#     async def create(self, id, description=None):
+#
+#         async with GroupCreateModel(self.app, id=id, description=description) as _:
+#             await self._group_service.create(
+#                 data={
+#                     'id': id,
+#                     'description': description
+#                 },
+#                 columns=None
+#             )
+#
+#             return {
+#                 "id": id
+#             }
+#
+#     async def load(self, id=None, page=None, per_page=None, query=None, **_):
+#         if page is None:
+#             page = 1
+#
+#         if per_page is None:
+#             per_page = 24
+#
+#         result = await self.grid(id=id, page=page, per_page=per_page, query=query)
+#         data = []
+#
+#         for i in result["data"]:
+#             _id = i["id"]["value"]
+#             data.append({
+#                 "id": _id,
+#                 "label": i.get("description", {}).get("value", f"[{_id}]") or f"[{_id}]",
+#             })
+#
+#         return {
+#             "pagination": result["pagination"],
+#             "data": data
+#         }
+#
+#     async def grid(self, id=None, page=1, query=None, per_page=24, **_):
+#         offset = (page - 1) * per_page
+#
+#         conditions = {}
+#
+#         if id and type(id) is list:
+#             conditions["id"] = [str(id_) for id_ in id]
+#         elif id:
+#             conditions["id"] = str(id)
+#
+#         if query:
+#             conditions = [
+#                 {
+#                     "id": {"~": query},
+#                     **conditions
+#                 },
+#                 {
+#                     "description": {"~": query},
+#                     **conditions
+#                 }
+#             ]
+#
+#         data = await self.list(
+#             conditions=conditions,
+#             offset=offset, limit=per_page)
+#
+#         count = data["count"]
+#         pages = data["pages"]
+#
+#         models = []
+#
+#         for i in data["data"]:
+#             group = dict(i)
+#             models.append(GroupsViewModel(self.app, **group))
+#
+#         async with GridConstructor(self.app, models=models, fields=self.fields) as gc:
+#             return {
+#                 "data": list(gc),
+#                 "fields": self.fields,
+#                 "pagination": {
+#                     "page": page,
+#                     "pages": pages,
+#                 },
+#                 "count": count
+#             }
+#
+#     async def get_group(self, id):
+#         group = await self._group_service.get(id)
+#         async with GroupEditModel(self.app, init=False, id=id, description=group["description"]) as obj:
+#             result = obj.fields
+#             return result
+#
+#     async def load_permissions(self, id=None, query=None, **_):
+#         await self.get_group(id)
+#
+#         tags = await self._group_service._permission_service.get_all_permissions(group_by_tag=True, query=query)
+#         group_permissions = await self._group_service.get_permissions(id)
+#
+#         data = []
+#         for tag in tags:
+#             permissions = [{
+#                 "id": permission["id"],
+#                 "label": permission["description"] or f"[{permission['id']}]",
+#                 "value": permission["id"] in group_permissions
+#             } for permission in tag["permissions"]]
+#
+#             data.append({
+#                 "tag": tag["tag"],
+#                 "permissions": permissions,
+#             })
+#
+#         return {
+#             "data": data,
+#             "pagination": {
+#                 "page": 1,
+#                 "pages": 1
+#             }
+#         }
+#
+#     async def update_info(self, id, **kwargs):
+#         if not kwargs:
+#             return {
+#                 "updated": False
+#             }
+#
+#         async with GroupEditModel(self.app, **kwargs) as _:
+#             if 'description' in kwargs:
+#                 await self._group_service.update(
+#                     id=id,
+#                     data={
+#                         'description': kwargs["description"]
+#                     }
+#                 )
+#
+#             return {
+#                 "updated": True
+#             }
+#
+#     async def update_permissions(self, id, permissions):
+#         await self._group_service.get(id)
+#         await self._group_service.modify_permissions(id, permissions=permissions)
+#         return {
+#             "updated": True
+#         }
```

## kaiju_auth/permissions_gui/validators.py

```diff
@@ -1,35 +1,35 @@
-from kaiju_model.model import ValidationError
-
-
-async def match_password_validator(app, key: str, value, ref, **__):
-    if ref["password_confirm"] != ref["password"]:
-        raise ValidationError(f"passwords don't match",
-                              data=dict(key=key, value=value, code='auth.user.mismatch_password'))
-
-
-async def group_exists(app, key: str, value, ref, **__):
-    if type(value) is str:
-        value = [value]
-
-    data = await app.services.groups_gui._group_service.list(
-        conditions={
-            "id": [str(v) for v in value]
-        })
-
-    if not data["count"]:
-        raise ValidationError(f"Not found",
-                              data=dict(key=key, value=value, code='ValidationError.not_exist'))
-
-
-async def group_not_exists(app, key: str, value, ref, **__):
-    if type(value) is str:
-        value = [value]
-
-    data = await app.services.groups_gui._group_service.list(
-        conditions={
-            "id": [str(v) for v in value]
-        })
-
-    if data["count"]:
-        raise ValidationError(f"Is exists",
-                              data=dict(key=key, value=value, code='ValidationError.is_exist'))
+# from kaiju_model.model import ValidationError
+#
+#
+# async def match_password_validator(app, key: str, value, ref, **__):
+#     if ref["password_confirm"] != ref["password"]:
+#         raise ValidationError(f"passwords don't match",
+#                               data=dict(key=key, value=value, code='auth.user.mismatch_password'))
+#
+#
+# async def group_exists(app, key: str, value, ref, **__):
+#     if type(value) is str:
+#         value = [value]
+#
+#     data = await app.services.groups_gui._group_service.list(
+#         conditions={
+#             "id": [str(v) for v in value]
+#         })
+#
+#     if not data["count"]:
+#         raise ValidationError(f"Not found",
+#                               data=dict(key=key, value=value, code='ValidationError.not_exist'))
+#
+#
+# async def group_not_exists(app, key: str, value, ref, **__):
+#     if type(value) is str:
+#         value = [value]
+#
+#     data = await app.services.groups_gui._group_service.list(
+#         conditions={
+#             "id": [str(v) for v in value]
+#         })
+#
+#     if data["count"]:
+#         raise ValidationError(f"Is exists",
+#                               data=dict(key=key, value=value, code='ValidationError.is_exist'))
```

## Comparing `kaiju_auth-2.0.14.dist-info/LICENSE` & `kaiju_auth-2.0.15.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `kaiju_auth-2.0.14.dist-info/RECORD` & `kaiju_auth-2.0.15.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-kaiju_auth/__init__.py,sha256=1GFbc4R28rvIXNaczIha8H_w2A82FArK8XiHCOlKWkA,84
+kaiju_auth/__init__.py,sha256=fV7PYUXG9u3Suv52iCKK0sdbAJ4Ce8_8NdwnaxBmk4k,84
 kaiju_auth/etc.py,sha256=8tXWzg4xXs8L0vth8Ymd77Q8fdzXgaxxSOKT15QP8w0,60
 kaiju_auth/fixtures.py,sha256=TMjpAIkY1sKNXLYEDvJnDdjvZ3njVed9Jt5BdLcEkB4,3765
 kaiju_auth/http.py,sha256=TwlOoRR_XoBTLftDJh-k10UQtnathsNueuDY_-IDOIE,5848
 kaiju_auth/login.py,sha256=586kkKBF0wgozmoDK-a-xFmB1T6hiH3Xx2gviZ92Z4Y,7646
 kaiju_auth/services.py,sha256=RP60nokV5seeBJ4y5PdwfIvenv3luwm1qx-azxZUldA,320
 kaiju_auth/sessions.py,sha256=mU7REiotvYgGy_9V26Np5hx50kDedEYNIs5GfNa4K7A,1811
 kaiju_auth/tables.py,sha256=mmvxRS-VJLvEjVFSnpBuCJra-lCow8RovLy0tYrKee0,2892
 kaiju_auth/tokens.py,sha256=eSj5sE-lFZDFzjF1DGwhMHHF6VhlDxeSSjroNEsutC8,11541
 kaiju_auth/users.py,sha256=wWKN3KOZ8dlrVPEcAuUHhwjY9RxTy00h-A6najBgbKg,27759
 kaiju_auth/permissions_gui/__init__.py,sha256=8Bxbwkjqk5QjDlZyXQ7R8dWLajhggp8of-yeZPz_pN0,55
-kaiju_auth/permissions_gui/models.py,sha256=gaUtybeEmDwbFjRTm8fnlq2MqG4ZIoSFK-aiICIp7i8,3051
-kaiju_auth/permissions_gui/service.py,sha256=iRGcpW-JERQF_8ehec6yqy12SSmq0Fr9Uk0LcNeiChY,17380
-kaiju_auth/permissions_gui/validators.py,sha256=bywyt8DXP3nnEU9d9JGxLOXdI5xl2qlbzz4SU3MoaTo,1151
-kaiju_auth-2.0.14.dist-info/LICENSE,sha256=XIlN2qA8UqpBDA-PteoYP4hTU0qBW0G9PRB__khO2zc,610
-kaiju_auth-2.0.14.dist-info/METADATA,sha256=ixybGQlH-4B5r_FLHUej1jnMF7V8UVsaTQs6YSsfxmk,2900
-kaiju_auth-2.0.14.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-kaiju_auth-2.0.14.dist-info/top_level.txt,sha256=5F9g7EZLuzcI4ioeLmgI2Pp_r2yuzykkUc5L7lcUl2I,11
-kaiju_auth-2.0.14.dist-info/RECORD,,
+kaiju_auth/permissions_gui/models.py,sha256=JJFA7O1W-TaiJjVG1XgRKlhm92c0RRi4KJzFqKCXcWQ,3228
+kaiju_auth/permissions_gui/service.py,sha256=-zq5O6XhkF5wV7cRHHZBvpbdNZwOGyrzdkzlxWk2GOY,18327
+kaiju_auth/permissions_gui/validators.py,sha256=sytK30UHT8fg_SI5DaQRlsp1dEuyAholiOgF7fICp1I,1212
+kaiju_auth-2.0.15.dist-info/LICENSE,sha256=XIlN2qA8UqpBDA-PteoYP4hTU0qBW0G9PRB__khO2zc,610
+kaiju_auth-2.0.15.dist-info/METADATA,sha256=elPtwGu_VOE9c3obv2iJZINa3XP_XuqH4uc5kqlxTi0,2893
+kaiju_auth-2.0.15.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+kaiju_auth-2.0.15.dist-info/top_level.txt,sha256=5F9g7EZLuzcI4ioeLmgI2Pp_r2yuzykkUc5L7lcUl2I,11
+kaiju_auth-2.0.15.dist-info/RECORD,,
```

