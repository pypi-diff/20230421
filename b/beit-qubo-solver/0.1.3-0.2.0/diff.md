# Comparing `tmp/beit_qubo_solver-0.1.3-py3-none-any.whl.zip` & `tmp/beit_qubo_solver-0.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 8531 bytes, number of entries: 17
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-11 16:11 beit/__init__.py
--rw-r--r--  2.0 unx      557 b- defN 23-Mar-03 20:27 beit/runfiles.py
--rw-r--r--  2.0 unx      119 b- defN 23-Mar-11 16:11 beit/qubo_solver/__init__.py
--rw-r--r--  2.0 unx      103 b- defN 23-Mar-11 16:11 beit/qubo_solver/architecture.py
--rw-r--r--  2.0 unx     2666 b- defN 23-Mar-11 16:11 beit/qubo_solver/beit_solver.py
--rw-r--r--  2.0 unx     1578 b- defN 23-Mar-11 16:11 beit/qubo_solver/endpoint.py
--rw-r--r--  2.0 unx      702 b- defN 23-Mar-11 16:11 beit/qubo_solver/qubo_instance.py
--rw-r--r--  2.0 unx     4096 b- defN 23-Mar-11 16:11 beit/qubo_solver/solver_connection.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-11 16:11 beit/qubo_solver/schemas/__init__.py
--rwxr-xr-x  2.0 unx      500 b- defN 23-Mar-11 16:11 beit/qubo_solver/schemas/result.json
--rwxr-xr-x  2.0 unx      967 b- defN 23-Mar-11 16:11 beit/qubo_solver/schemas/result_response.json
--rwxr-xr-x  2.0 unx     1290 b- defN 23-Mar-11 16:11 beit/qubo_solver/schemas/solve.json
--rwxr-xr-x  2.0 unx      629 b- defN 23-Mar-11 16:11 beit/qubo_solver/schemas/solve_response.json
--rw-r--r--  2.0 unx      406 b- defN 23-Mar-11 16:11 beit_qubo_solver-0.1.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-11 16:11 beit_qubo_solver-0.1.3.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 23-Mar-11 16:11 beit_qubo_solver-0.1.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1477 b- defN 23-Mar-11 16:11 beit_qubo_solver-0.1.3.dist-info/RECORD
-17 files, 15187 bytes uncompressed, 6055 bytes compressed:  60.1%
+Zip file size: 9599 bytes, number of entries: 17
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-21 13:57 beit/__init__.py
+-rw-r--r--  2.0 unx      557 b- defN 23-Apr-07 14:58 beit/runfiles.py
+-rw-r--r--  2.0 unx      145 b- defN 23-Apr-21 13:57 beit/qubo_solver/__init__.py
+-rw-r--r--  2.0 unx      103 b- defN 23-Apr-21 13:57 beit/qubo_solver/architecture.py
+-rw-r--r--  2.0 unx     4971 b- defN 23-Apr-21 13:57 beit/qubo_solver/beit_solver.py
+-rw-r--r--  2.0 unx     1578 b- defN 23-Apr-21 13:57 beit/qubo_solver/endpoint.py
+-rw-r--r--  2.0 unx      707 b- defN 23-Apr-21 13:57 beit/qubo_solver/qubo_instance.py
+-rw-r--r--  2.0 unx     4848 b- defN 23-Apr-21 13:57 beit/qubo_solver/solver_connection.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Apr-21 13:57 beit/qubo_solver/schemas/__init__.py
+-rwxr-xr-x  2.0 unx      500 b- defN 23-Apr-21 13:57 beit/qubo_solver/schemas/result.json
+-rwxr-xr-x  2.0 unx      967 b- defN 23-Apr-21 13:57 beit/qubo_solver/schemas/result_response.json
+-rwxr-xr-x  2.0 unx     2550 b- defN 23-Apr-21 13:57 beit/qubo_solver/schemas/solve.json
+-rwxr-xr-x  2.0 unx      629 b- defN 23-Apr-21 13:57 beit/qubo_solver/schemas/solve_response.json
+-rw-r--r--  2.0 unx      406 b- defN 23-Apr-21 13:57 beit_qubo_solver-0.2.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-21 13:57 beit_qubo_solver-0.2.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-Apr-21 13:57 beit_qubo_solver-0.2.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1477 b- defN 23-Apr-21 13:57 beit_qubo_solver-0.2.0.dist-info/RECORD
+17 files, 19535 bytes uncompressed, 7123 bytes compressed:  63.5%
```

## zipnote {}

```diff
@@ -33,20 +33,20 @@
 
 Filename: beit/qubo_solver/schemas/solve.json
 Comment: 
 
 Filename: beit/qubo_solver/schemas/solve_response.json
 Comment: 
 
-Filename: beit_qubo_solver-0.1.3.dist-info/METADATA
+Filename: beit_qubo_solver-0.2.0.dist-info/METADATA
 Comment: 
 
-Filename: beit_qubo_solver-0.1.3.dist-info/WHEEL
+Filename: beit_qubo_solver-0.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: beit_qubo_solver-0.1.3.dist-info/top_level.txt
+Filename: beit_qubo_solver-0.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: beit_qubo_solver-0.1.3.dist-info/RECORD
+Filename: beit_qubo_solver-0.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## beit/qubo_solver/__init__.py

```diff
@@ -1,2 +1,2 @@
 from beit.qubo_solver.solver_connection import AWSSolverConnection
-from beit.qubo_solver.beit_solver import BEITSolver
+from beit.qubo_solver.beit_solver import BEITUnconstrainedSampler, BEITSolver
```

## beit/qubo_solver/beit_solver.py

```diff
@@ -1,29 +1,48 @@
 from itertools import chain
 from time import sleep
-from typing import Any, Dict, Hashable, List, Tuple
+from typing import Any, Dict, Hashable, List, Optional, Tuple
 
 import dimod
 from dimod.exceptions import BinaryQuadraticModelStructureError
 
 from beit.qubo_solver.architecture import make_chimera_architecture
 from beit.qubo_solver.qubo_instance import QuboInstance
 from beit.qubo_solver.solver_connection import JobStatus, SolverConnection
 
 
-class BEITSolver(dimod.Sampler, dimod.Structured):
+class BEITSamplerBase(dimod.Sampler):
+
+    _BACKEND: Optional[str] = None
+
+    def __init__(self, solver_connection: SolverConnection):
+        self._connection = solver_connection
+        super().__init__()
+
+    def _sample_qubo(self, qubo_instance: QuboInstance, **parameters):
+        parameters = self.remove_unknown_kwargs(**parameters)
+        job = self._connection.create_job(qubo_instance, backend=self._BACKEND, **parameters)
+        while job.request_result() == JobStatus.PENDING:
+            sleep(0.5)  # Arbitrary number
+        assert job.status == JobStatus.DONE  # Otherwise it should've throw earlier.
+        assert job.result is not None
+        states = [result.state for result in job.result]
+        energies = [result.energy for result in job.result]
+        return states, energies
+
+
+class BEITSolver(BEITSamplerBase, dimod.Structured):
     """
     This is an exact solver for QUBO. It works only with
     chimera architecture (max size being (8, 16, 4))
     """
 
     _TARGET_ARCHITECTURE = make_chimera_architecture()
 
-    def __init__(self, solver_connection: SolverConnection):
-        self._connection = solver_connection
+    _BACKEND = "chimera-solver-bellerophon"
 
     @property
     def edgelist(self) -> List[Tuple[Hashable, Hashable]]:
         return list(self._TARGET_ARCHITECTURE.edges)
 
     @property
     def nodelist(self) -> List[Hashable]:
@@ -54,15 +73,49 @@
         if wrong_edges:
             raise BinaryQuadraticModelStructureError(
                 f"The following edges are not present in the edgelist: {' '.join(map(str, wrong_edges))}"
             )
 
     def sample_qubo(self, qubo_instance: QuboInstance, **parameters):
         self._check_instance_valid(qubo_instance)
-        job = self._connection.create_job(qubo_instance)
-        while job.request_result() == JobStatus.PENDING:
-            sleep(0.5) # Arbitrary number
-        assert job.status == JobStatus.DONE # Otherwise it should've throw earlier.
-        assert job.result is not None
-        states = [result.state for result in job.result]
-        energies = [result.energy for result in job.result]
+        states, energies = self._sample_qubo(qubo_instance, **parameters)
+        return dimod.SampleSet.from_samples(states, dimod.Vartype.BINARY, energies)
+
+
+class BEITUnconstrainedSampler(BEITSamplerBase):
+
+    _BACKEND = "any-sampler-hephaestus"
+
+    @property
+    def parameters(self) -> Dict[str, Any]:
+        return {
+            "timeout": [],
+            "sample_count": ["Number of samples returned, returned value can differ from requested."],
+        }
+
+    @property
+    def properties(self) -> Dict[str, Any]:
+        return {
+            "max_timeout": 60 * 12,  # 12 minutes
+            "max_combined_sample_size": [10 ** 6, "Number of variables times number of samples can not exceed this number."],
+            "weights_range": [10 ** 6, "Maximum absolute value for any single weight (biases and couplers)"],
+            "max_num_weights": [5000, "Maximum number of weights in a problem (biases and couplers)"],
+        }
+
+    def _prepare_mapping(self, qubo_instance) -> Tuple[QuboInstance, List[Hashable]]:
+        #  Set is constructed to remove duplicates
+        reverse_mapping = list(set(chain.from_iterable(qubo_instance.keys())))
+        mapping = {x: i for i, x in enumerate(reverse_mapping)}
+        qubo_instance = {(mapping[x], mapping[y]): v for (x, y), v in qubo_instance.items()}
+        return qubo_instance, reverse_mapping
+
+    @staticmethod
+    def _unmap(solutions: List[Tuple[int, ...]], reverse_mapping: List[Hashable]) -> List[Dict[Hashable, int]]:
+        return [
+            {reverse_mapping[i]: v for i, v in enumerate(solution)} for solution in solutions
+        ]
+
+    def sample_qubo(self, qubo_instance: QuboInstance, sample_count: int = 1, **parameters):
+        qubo_instance, reverse_mapping = self._prepare_mapping(qubo_instance)
+        states, energies = self._sample_qubo(qubo_instance, sample_count=sample_count, **parameters)
+        states = self._unmap(states, reverse_mapping)
         return dimod.SampleSet.from_samples(states, dimod.Vartype.BINARY, energies)
```

## beit/qubo_solver/qubo_instance.py

```diff
@@ -3,15 +3,15 @@
 
 import numpy as np
 
 QuboInstance = Mapping[Tuple[Hashable, Hashable], Union[float, np.floating, np.integer]]
 
 @dataclass
 class QuboSolution:
-    state: Tuple[int]
+    state: Tuple[int, ...]
     energy: Optional[float]
     boltzmann_probability: Optional[float]
 
     @classmethod
     def from_json(cls, js: dict) -> 'QuboSolution':
         solution_mapping = cast(Tuple[int], tuple(js['state']))
         energy = float(js['energy']) if 'energy' in js else None
```

## beit/qubo_solver/solver_connection.py

```diff
@@ -8,15 +8,15 @@
 from beit.runfiles import runfiles
 from requests.status_codes import codes
 
 from beit.qubo_solver.endpoint import APIEndpoint, APIError
 from beit.qubo_solver.qubo_instance import QuboInstance, QuboSolution
 
 
-API_PREFIX = "https://qubo-solver.pro.beit.tech/v1"
+DEFAULT_API_PREFIX = "https://qubo-solver.pro.beit.tech/v1"
 RUNFILES = runfiles.Create()
 
 def _schema(path_to_schema: str):
     with open(RUNFILES.Rlocation(path_to_schema)) as schema_file:
         return json.load(schema_file)
 
 class JobError(Exception):
@@ -52,15 +52,15 @@
 
 class SolverConnection(abc.ABC):
     """
         Responsible for creating jobs.
     """
 
     @abc.abstractmethod
-    def create_job(self, qubo_instance) -> Job:
+    def create_job(self, qubo_instance, **kwargs) -> Job:
         pass
 
 
 def _remember_failure(method):
     @wraps(method)
     def _inner(self, *args, **kwargs):
         try:
@@ -72,41 +72,35 @@
         return result
     return _inner
 
 
 class AWSJob(Job):
     """Job running on BEIT Qubo Solver"""
 
-    SOLUTION_ENDPOINT = APIEndpoint(
-        url=API_PREFIX + "/solution",
-        method="POST",
-        request_schema=_schema("qubo_solver/schemas/result.json"),
-        response_schema=_schema("qubo_solver/schemas/result_response.json"),
-    )
-
-    def __init__(self, job_id: str, customer_key: str):
+    def __init__(self, job_id: str, customer_key: str, endpoint: APIEndpoint):
         self._job_id = job_id
         self._customer_key = customer_key
         self._status = JobStatus.PENDING
         self._result: Optional[Tuple[QuboSolution]] = None
+        self._solution_endpoint = endpoint
     
     @property
     def result(self) -> Optional[Tuple[QuboSolution]]:
         return deepcopy(self._result)
 
     @property    
     def status(self) -> JobStatus:
         return self._status
 
     @_remember_failure
     def request_result(self) -> JobStatus:
         """Tries to retrieve result of the running job"""
         if self._status != JobStatus.PENDING:
             return self._status
-        body, response = self.SOLUTION_ENDPOINT.execute(
+        body, response = self._solution_endpoint.execute(
             {"job_id": self._job_id},
             headers={"x-api-key": self._customer_key}
         )
         if response.status_code != codes.ok:
             raise JobError(f"Something went wrong, API returned code {response.status_code}" + 
                 (f" reason given {body['error']}" if 'error' in body else "")
             )
@@ -114,30 +108,47 @@
             return JobStatus.PENDING
         self._result = cast(Tuple[QuboSolution], tuple(QuboSolution.from_json(sample) for sample in body['samples']))
         return JobStatus.DONE
 
 
 class AWSSolverConnection(SolverConnection):
 
-    SOLVE_ENDPOINT = APIEndpoint(
-        url=API_PREFIX + "/solve",
-        method="POST",
-        request_schema=_schema("qubo_solver/schemas/solve.json"),
-        response_schema=_schema("qubo_solver/schemas/solve_response.json"),
-    )
-
-    def __init__(self, customer_key: str):
+    def __init__(self, customer_key: str, api_prefix: str = DEFAULT_API_PREFIX):
         self._customer_key = customer_key
+        self._solve_endpoint = APIEndpoint(
+            url=api_prefix + "/solve",
+            method="POST",
+            request_schema=_schema("qubo_solver/schemas/solve.json"),
+            response_schema=_schema("qubo_solver/schemas/solve_response.json"),
+        )
+        self._solution_endpoint = APIEndpoint(
+            url=api_prefix + "/solution",
+            method="POST",
+            request_schema=_schema("qubo_solver/schemas/result.json"),
+            response_schema=_schema("qubo_solver/schemas/result_response.json"),
+        )
 
-    
-    def create_job(self, qubo_instance: QuboInstance) -> AWSJob:
+    @staticmethod
+    def _create_request_body(qubo_instance, backend, **kwargs):
+        request_body = {
+            "instance": [{"edge": list(edge), "weight": weight} for edge, weight in qubo_instance.items()],
+            "execution": {"backend": backend},
+        }
+        if "timeout" in kwargs:
+            request_body["execution"]["timeout"] = kwargs["timeout"]
+        if "sample_count" in kwargs:
+            request_body["distribution"] = {"sample_count": kwargs["sample_count"]}
+        return request_body
+
+    def create_job(self, qubo_instance: QuboInstance, backend: str = "chimera-solver-bellerophon", **kwargs) -> AWSJob:
         """Creates a job"""
-        body, response = self.SOLVE_ENDPOINT.execute(
-            {"instance": [{"edge": list(edge), "weight": weight} for edge, weight in qubo_instance.items()]},
+
+        body, response = self._solve_endpoint.execute(
+            self._create_request_body(qubo_instance, backend=backend, **kwargs),
             headers={"x-api-key": self._customer_key}
         )
         if response.status_code == codes.created:
-            return AWSJob(body['task_key'], self._customer_key)
+            return AWSJob(body['task_key'], self._customer_key, self._solution_endpoint)
         raise JobError(
             f"Posting job failed with code {response.status_code}" +
             (f' with message: "{body["error"]}"' if 'error' in body else "")
         )
```

## beit/qubo_solver/schemas/solve.json

### Pretty-printed

 * *Similarity: 0.9428571428571428%*

 * *Differences: {"'properties'": "{'mapping': OrderedDict([('description', 'Variable names in QUBO instance.'), "*

 * *                 "('type', 'array'), ('uniqueItems', True), ('items', OrderedDict([('type', "*

 * *                 "'string')]))]), 'distribution': OrderedDict([('description', 'Choice of "*

 * *                 "distribution and its parameters.'), ('type', 'object'), ('properties', "*

 * *                 "OrderedDict([('boltzmann', OrderedDict([('description', 'Filling this field "*

 * *                 "indicates the Boltzmann […]*

```diff
@@ -1,27 +1,50 @@
 {
     "$schema": "http://json-schema.org/draft-04/schema",
     "description": "Solve the given QUBO instance",
     "id": "https://qubo-solver.dev.beit.tech/solve.schema.json",
     "properties": {
-        "boltzmann": {
-            "description": "Various parameters for additional computations.",
+        "distribution": {
+            "description": "Choice of distribution and its parameters.",
             "properties": {
+                "boltzmann": {
+                    "description": "Filling this field indicates the Boltzmann distribution is requested.",
+                    "properties": {
+                        "temperature": {
+                            "type": "number"
+                        }
+                    },
+                    "required": [
+                        "temperature"
+                    ],
+                    "type": "object"
+                },
                 "sample_count": {
+                    "description": "Requested number of samples. Solver will do its best to return the requested number.",
                     "exclusiveMinimum": true,
                     "minimum": 0,
                     "type": "integer"
+                }
+            },
+            "type": "object"
+        },
+        "execution": {
+            "description": "Parameters regarding execution.",
+            "properties": {
+                "backend": {
+                    "description": "Backend on which computation will run",
+                    "type": "string"
                 },
-                "temperature": {
+                "timeout": {
+                    "description": "Maximum execution time in seconds",
+                    "exclusiveMinimum": true,
+                    "minimum": 0,
                     "type": "number"
                 }
             },
-            "required": [
-                "temperature"
-            ],
             "type": "object"
         },
         "instance": {
             "description": "QUBO instance.",
             "items": {
                 "description": "Weighted edge of a QUBO instance. May be a loop (self edge).",
                 "properties": {
@@ -40,14 +63,22 @@
                 "required": [
                     "edge",
                     "weight"
                 ],
                 "type": "object"
             },
             "type": "array"
+        },
+        "mapping": {
+            "description": "Variable names in QUBO instance.",
+            "items": {
+                "type": "string"
+            },
+            "type": "array",
+            "uniqueItems": true
         }
     },
     "required": [
         "instance"
     ],
     "title": "Solve",
     "type": "object"
```

