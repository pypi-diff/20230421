# Comparing `tmp/neon_mq_connector-0.6.1a2-py3-none-any.whl.zip` & `tmp/neon_mq_connector-0.6.1a3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,16 +1,17 @@
-Zip file size: 23108 bytes, number of entries: 14
--rw-r--r--  2.0 unx     1867 b- defN 23-Apr-21 01:14 neon_mq_connector/__init__.py
--rw-r--r--  2.0 unx     3452 b- defN 23-Apr-21 01:14 neon_mq_connector/config.py
--rw-r--r--  2.0 unx    31649 b- defN 23-Apr-21 01:14 neon_mq_connector/connector.py
--rw-r--r--  2.0 unx     1930 b- defN 23-Apr-21 01:14 neon_mq_connector/utils/__init__.py
--rw-r--r--  2.0 unx     6156 b- defN 23-Apr-21 01:14 neon_mq_connector/utils/client_utils.py
--rw-r--r--  2.0 unx     7112 b- defN 23-Apr-21 01:14 neon_mq_connector/utils/connection_utils.py
--rw-r--r--  2.0 unx     1383 b- defN 23-Apr-21 01:14 neon_mq_connector/utils/rabbit_utils.py
--rw-r--r--  2.0 unx     2131 b- defN 23-Apr-21 01:14 neon_mq_connector/utils/thread_utils.py
--rw-r--r--  2.0 unx     1635 b- defN 23-Apr-21 01:14 neon_mq_connector-0.6.1a2.dist-info/LICENSE.md
--rw-r--r--  2.0 unx     3220 b- defN 23-Apr-21 01:14 neon_mq_connector-0.6.1a2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-21 01:14 neon_mq_connector-0.6.1a2.dist-info/WHEEL
--rw-r--r--  2.0 unx       18 b- defN 23-Apr-21 01:14 neon_mq_connector-0.6.1a2.dist-info/top_level.txt
--rw-r--r--  2.0 unx        1 b- defN 23-Apr-21 01:14 neon_mq_connector-0.6.1a2.dist-info/zip-safe
--rw-rw-r--  2.0 unx     1285 b- defN 23-Apr-21 01:14 neon_mq_connector-0.6.1a2.dist-info/RECORD
-14 files, 61931 bytes uncompressed, 20928 bytes compressed:  66.2%
+Zip file size: 26043 bytes, number of entries: 15
+-rw-r--r--  2.0 unx     1884 b- defN 23-Apr-21 02:38 neon_mq_connector/__init__.py
+-rw-r--r--  2.0 unx     3558 b- defN 23-Apr-21 02:38 neon_mq_connector/config.py
+-rw-r--r--  2.0 unx    32234 b- defN 23-Apr-21 02:38 neon_mq_connector/connector.py
+-rw-r--r--  2.0 unx     2011 b- defN 23-Apr-21 02:38 neon_mq_connector/utils/__init__.py
+-rw-r--r--  2.0 unx     6204 b- defN 23-Apr-21 02:38 neon_mq_connector/utils/client_utils.py
+-rw-r--r--  2.0 unx     7636 b- defN 23-Apr-21 02:38 neon_mq_connector/utils/connection_utils.py
+-rw-r--r--  2.0 unx     3215 b- defN 23-Apr-21 02:38 neon_mq_connector/utils/network_utils.py
+-rw-r--r--  2.0 unx     3304 b- defN 23-Apr-21 02:38 neon_mq_connector/utils/rabbit_utils.py
+-rw-r--r--  2.0 unx     2131 b- defN 23-Apr-21 02:38 neon_mq_connector/utils/thread_utils.py
+-rw-r--r--  2.0 unx     1635 b- defN 23-Apr-21 02:38 neon_mq_connector-0.6.1a3.dist-info/LICENSE.md
+-rw-r--r--  2.0 unx     3251 b- defN 23-Apr-21 02:38 neon_mq_connector-0.6.1a3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-21 02:38 neon_mq_connector-0.6.1a3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       18 b- defN 23-Apr-21 02:38 neon_mq_connector-0.6.1a3.dist-info/top_level.txt
+-rw-r--r--  2.0 unx        1 b- defN 23-Apr-21 02:38 neon_mq_connector-0.6.1a3.dist-info/zip-safe
+-rw-rw-r--  2.0 unx     1382 b- defN 23-Apr-21 02:38 neon_mq_connector-0.6.1a3.dist-info/RECORD
+15 files, 68556 bytes uncompressed, 23707 bytes compressed:  65.4%
```

## zipnote {}

```diff
@@ -12,32 +12,35 @@
 
 Filename: neon_mq_connector/utils/client_utils.py
 Comment: 
 
 Filename: neon_mq_connector/utils/connection_utils.py
 Comment: 
 
+Filename: neon_mq_connector/utils/network_utils.py
+Comment: 
+
 Filename: neon_mq_connector/utils/rabbit_utils.py
 Comment: 
 
 Filename: neon_mq_connector/utils/thread_utils.py
 Comment: 
 
-Filename: neon_mq_connector-0.6.1a2.dist-info/LICENSE.md
+Filename: neon_mq_connector-0.6.1a3.dist-info/LICENSE.md
 Comment: 
 
-Filename: neon_mq_connector-0.6.1a2.dist-info/METADATA
+Filename: neon_mq_connector-0.6.1a3.dist-info/METADATA
 Comment: 
 
-Filename: neon_mq_connector-0.6.1a2.dist-info/WHEEL
+Filename: neon_mq_connector-0.6.1a3.dist-info/WHEEL
 Comment: 
 
-Filename: neon_mq_connector-0.6.1a2.dist-info/top_level.txt
+Filename: neon_mq_connector-0.6.1a3.dist-info/top_level.txt
 Comment: 
 
-Filename: neon_mq_connector-0.6.1a2.dist-info/zip-safe
+Filename: neon_mq_connector-0.6.1a3.dist-info/zip-safe
 Comment: 
 
-Filename: neon_mq_connector-0.6.1a2.dist-info/RECORD
+Filename: neon_mq_connector-0.6.1a3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## neon_mq_connector/__init__.py

```diff
@@ -22,8 +22,8 @@
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-from .connector import MQConnector
+from neon_mq_connector.connector import MQConnector
```

## neon_mq_connector/config.py

```diff
@@ -25,26 +25,29 @@
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import os
 import json
 from typing import Optional
+# TODO: Implement ovos-config
 
 
 def load_neon_mq_config():
     """
     Locates and loads global MQ configuration. Priority is as follows:
     NEON_MQ_CONFIG_PATH environment variable
     {NEON_CONFIG_PATH}/mq_config.json
     ~/.local/share/neon/credentials.json
     """
     valid_config_paths = (
         os.path.expanduser(os.environ.get('NEON_MQ_CONFIG_PATH', "")),
-        os.path.join(os.path.expanduser(os.environ.get("NEON_CONFIG_PATH", "~/.config/neon")), "mq_config.json"),
+        os.path.join(os.path.expanduser(os.environ.get("NEON_CONFIG_PATH",
+                                                       "~/.config/neon")),
+                     "mq_config.json"),
         os.path.expanduser("~/.local/share/neon/credentials.json")
     )
     config = None
     for conf in valid_config_paths:
         if conf and os.path.isfile(conf):
             config = Configuration().from_file(conf).config_data
             break
```

## neon_mq_connector/connector.py

```diff
@@ -30,22 +30,22 @@
 import copy
 import time
 import uuid
 import pika
 import pika.exceptions
 import threading
 
-from abc import ABC, abstractmethod
+from abc import ABC
 from typing import Optional, Dict, Any
 from pika.exchange_type import ExchangeType
-from neon_utils.logger import LOG
-from neon_utils.socket_utils import dict_to_b64
+from ovos_utils.log import LOG
 
-from .config import load_neon_mq_config
-from .utils import RepeatingTimer, retry, wait_for_mq_startup
+from neon_mq_connector.config import load_neon_mq_config
+from neon_mq_connector.utils import RepeatingTimer, retry, wait_for_mq_startup
+from neon_mq_connector.utils.network_utils import dict_to_b64
 
 
 class ConsumerThread(threading.Thread):
 
     # retry to handle connection failures in case MQ server is still starting
     @retry(use_self=True)
     def __init__(self, connection_params: pika.ConnectionParameters,
@@ -125,15 +125,17 @@
         except Exception as x:
             LOG.error(x)
         finally:
             super(ConsumerThread, self).join()
 
 
 class MQConnector(ABC):
-    """ Abstract class implementing interface for attaching services to MQ server """
+    """
+    Abstract class implementing interface for attaching services to MQ server
+    """
 
     __run_retries__ = 5
     __max_consumer_restarts__ = -1
     __consumer_join_timeout__ = 10
 
     @staticmethod
     def init_config(config: dict) -> dict:
@@ -160,16 +162,17 @@
                 "<self.property_key (default='properties')>": {
                     <key of the configurable property>:<value of the configurable property>
                 }
             }
 
             :param service_name: name of current service
        """
-        self.config = config
-        # Override self.property_key BEFORE base __init__ to initialise properties under customized config location
+        self._config = config
+        # Override self.property_key BEFORE base __init__ to initialise
+        # properties under customized config location
         if not hasattr(self, 'property_key'):
             self.property_key = 'properties'
         self._service_id = None
         self.service_name = service_name
         self.consumers = dict()
         self.consumer_properties = dict()
         self._vhost = None
@@ -189,54 +192,66 @@
     def service_config(self) -> dict:
         """ Returns current service config """
         return self.config['users'][self.service_name]
 
     @property
     def __basic_configurable_properties(self) -> Dict[str, Any]:
         """
-            Mapping of basic configurable properties to their default values.
-            WARNING: This method should be left untouched to prevent unexpected behaviour;
-            To override values of the basic properties specify it in self.service_configurable_properties()
+        Mapping of basic configurable properties to their default values.
+        WARNING: This method should be left untouched to prevent unexpected
+        behaviour. To override values of the basic properties specify it in
+        self.service_configurable_properties()
         """
         return {
                 'sync_period': 10,  # in seconds
                 'observe_period': 20,  # in seconds
                 'vhost_prefix': '',  # Could be used for scalability purposes
                 'default_testing_prefix': 'test',
-                'testing_envs': (f'{self.service_name.upper()}_TESTING', 'MQ_TESTING',),  # order matters
-                'testing_prefix_envs': (f'{self.service_name.upper()}_TESTING_PREFIX', 'MQ_TESTING_PREFIX',)  # order matters
+                'testing_envs': (f'{self.service_name.upper()}_TESTING',
+                                 'MQ_TESTING',),  # order matters
+                'testing_prefix_envs': (f'{self.service_name.upper()}'
+                                        f'_TESTING_PREFIX',
+                                        'MQ_TESTING_PREFIX',)  # order matters
                 }
 
     @property
     def service_configurable_properties(self) -> Dict[str, Any]:
         """
-            Mapping of service-related configurable properties to their default values.
-
-            Override to provide service-specific configurable properties AND to update the default values of basic properties
+        Mapping of service-related configurable properties to default values.
+        Override to provide service-specific configurable properties AND to
+        update the default values of basic properties
         """
         return {}
 
     @property
     def __configurable_properties(self):
         """
-            Joins basic configurable properties with appended once
-            WARNING: This method should NOT be modified by children to prevent unexpected behaviour
+        Joins basic configurable properties with appended once
+        WARNING: This method should NOT be modified by children to prevent
+        unexpected behaviour
         """
-        return {**self.__basic_configurable_properties, **self.service_configurable_properties}
+        return {**self.__basic_configurable_properties,
+                **self.service_configurable_properties}
 
     def __init_configurable_properties(self):
-        """ Initialize properties based on the config and configurable properties
-            WARNING: This method should NOT be modified by children to prevent unexpected behaviour
+        """
+        Initialize properties based on the config and configurable properties
+        WARNING: This method should NOT be modified by children to prevent
+        unexpected behaviour
         """
         for _property, default_value in self.__configurable_properties.items():
-            setattr(self, _property, self.service_config.get(self.property_key, {}).get(_property, default_value))
+            setattr(self, _property,
+                    self.service_config.get(self.property_key,
+                                            {}).get(_property, default_value))
 
     @property
     def service_id(self):
-        """ID of the service should be considered to be unique"""
+        """
+        ID of the service should be considered to be unique
+        """
         if not self._service_id:
             self._service_id = self.create_unique_id()
         return self._service_id
 
     @property
     def mq_credentials(self):
         """
@@ -246,34 +261,40 @@
             raise Exception('Configuration is not set')
         return pika.PlainCredentials(
             self.service_config.get('user', 'guest'),
             self.service_config.get('password', 'guest'))
 
     @property
     def testing_mode(self) -> bool:
-        """Indicates if given instance is instantiated in testing mode"""
+        """
+        Indicates if given instance is instantiated in testing mode
+        """
         return any(os.environ.get(env_var, '0') == '1'
                    for env_var in self.testing_envs)
 
     @property
     def testing_prefix(self) -> str:
-        """Returns testing mode prefix for the item"""
+        """
+        Returns testing mode prefix for the item
+        """
         for env_var in self.testing_prefix_envs:
             prefix = os.environ.get(env_var)
             if prefix:
                 return prefix
         return self.default_testing_prefix
 
     @property
     def vhost(self):
         if not self._vhost:
             self._vhost = '/'
-        if self.vhost_prefix and self.vhost_prefix not in self._vhost.split('_')[0]:
+        if self.vhost_prefix and self.vhost_prefix not in \
+                self._vhost.split('_')[0]:
             self._vhost = f'/{self.vhost_prefix}_{self._vhost[1:]}'
-        if self.testing_mode and self.testing_prefix not in self._vhost.split('_')[0]:
+        if self.testing_mode and self.testing_prefix not in \
+                self._vhost.split('_')[0]:
             self._vhost = f'/{self.testing_prefix}_{self._vhost[1:]}'
         if self._vhost.endswith('_'):
             self._vhost = self._vhost[:-1]
         return self._vhost
 
     @vhost.setter
     def vhost(self, val: str):
@@ -362,45 +383,52 @@
         :param exchange: name of the exchange (optional)
         :param expiration: mq message expiration time in millis
             (defaults to 1 second)
 
         :raises ValueError: invalid request data provided
         :returns message_id: id of the sent message
         """
-        return cls.emit_mq_message(connection=connection, request_data=request_data, exchange=exchange,
-                                   queue='', exchange_type='fanout', expiration=expiration)
+        return cls.emit_mq_message(connection=connection,
+                                   request_data=request_data, exchange=exchange,
+                                   queue='', exchange_type='fanout',
+                                   expiration=expiration)
 
     def send_message(self,
                      request_data: dict,
                      vhost: str = '',
                      connection_props: dict = None,
                      exchange: Optional[str] = '',
                      queue: Optional[str] = '',
                      exchange_type: ExchangeType = ExchangeType.direct,
                      expiration: int = 1000) -> str:
         """
-            Wrapper method for creation the MQ connection and immediate propagation of requested message with that
+        Wrapper method for creation the MQ connection and immediate propagation
+        of requested message with that
 
-            :param request_data: dictionary containing requesting data
-            :param vhost: MQ Virtual Host (if not specified - uses its object native)
-            :param exchange: MQ Exchange name (optional)
-            :param queue: MQ Queue name (optional for ExchangeType.fanout)
-            :param connection_props: supportive connection properties while connection creation (optional)
-            :param exchange_type: type of exchange to use (defaults to ExchangeType.direct)
-            :param expiration: posted data expiration (in millis)
+        :param request_data: dictionary containing requesting data
+        :param vhost: MQ Virtual Host (if not specified, uses its object native)
+        :param exchange: MQ Exchange name (optional)
+        :param queue: MQ Queue name (optional for ExchangeType.fanout)
+        :param connection_props: supportive connection properties while
+            connection creation (optional)
+        :param exchange_type: type of exchange to use
+            (defaults to ExchangeType.direct)
+        :param expiration: posted data expiration (in millis)
 
-            :returns message_id: id of the propagated message
+        :returns message_id: id of the propagated message
         """
         if not vhost:
             vhost = self.vhost
         if not connection_props:
             connection_props = {}
         LOG.debug(f'Opening connection on vhost={vhost}')
-        with self.create_mq_connection(vhost=vhost, **connection_props) as mq_conn:
-            if exchange_type in (ExchangeType.fanout, ExchangeType.fanout.value,):
+        with self.create_mq_connection(vhost=vhost,
+                                       **connection_props) as mq_conn:
+            if exchange_type in (ExchangeType.fanout,
+                                 ExchangeType.fanout.value,):
                 LOG.debug('Sending fanout request to MQ')
                 msg_id = self.publish_message(connection=mq_conn,
                                               request_data=request_data,
                                               exchange=exchange,
                                               expiration=expiration)
             else:
                 LOG.debug(f'Sending {exchange_type} request to MQ')
@@ -420,21 +448,25 @@
             Note: Additional parameters can be defined via kwargs.
 
             :param vhost: address for desired virtual host
             :raises Exception if self.config is not set
         """
         if not self.config:
             raise Exception('Configuration is not set')
-        return pika.BlockingConnection(parameters=self.get_connection_params(vhost, **kwargs))
+        return pika.BlockingConnection(
+            parameters=self.get_connection_params(vhost, **kwargs))
 
     def register_consumer(self, name: str, vhost: str, queue: str,
-                          callback: callable, on_error: Optional[callable] = None,
+                          callback: callable,
+                          on_error: Optional[callable] = None,
                           auto_ack: bool = True, queue_reset: bool = False,
-                          exchange: str = None, exchange_type: str = None, exchange_reset: bool = False,
-                          queue_exclusive: bool = False, skip_on_existing: bool = False,
+                          exchange: str = None, exchange_type: str = None,
+                          exchange_reset: bool = False,
+                          queue_exclusive: bool = False,
+                          skip_on_existing: bool = False,
                           restart_attempts: int = __max_consumer_restarts__):
         """
         Registers a consumer for the specified queue.
         The callback function will handle items in the queue.
         Any raised exceptions will be passed as arguments to on_error.
         :param name: Human readable name of the consumer
         :param vhost: vhost to register on
@@ -446,39 +478,43 @@
             https://www.rabbitmq.com/tutorials/amqp-concepts.html
         :param callback: Method to passed queued messages to
         :param on_error: Optional method to handle any exceptions
             raised in message handling
         :param auto_ack: Boolean to enable ack of messages upon receipt
         :param queue_exclusive: if Queue needs to be exclusive
         :param skip_on_existing: to skip if consumer already exists
-        :param restart_attempts: max instance restart attempts (if < 0 - will restart infinitely times)
+        :param restart_attempts: max instance restart attempts
+            (if < 0 - will restart infinitely times)
         """
         error_handler = on_error or self.default_error_handler
         consumer = self.consumers.get(name, None)
         if consumer:
             # Gracefully terminating
             if skip_on_existing:
                 LOG.info(f'Consumer under index "{name}" already declared')
                 return
             self.stop_consumers(names=(name,))
         self.consumer_properties.setdefault(name, {})
-        self.consumer_properties[name]['properties'] = dict(connection_params=self.get_connection_params(vhost),
-                                                            queue=queue,
-                                                            queue_reset=queue_reset, callback_func=callback,
-                                                            exchange=exchange, exchange_reset=exchange_reset,
-                                                            exchange_type=exchange_type, error_func=error_handler,
-                                                            auto_ack=auto_ack, name=name, queue_exclusive=queue_exclusive,)
-        self.consumer_properties[name]['restart_attempts'] = int(restart_attempts)
+        self.consumer_properties[name]['properties'] = \
+            dict(connection_params=self.get_connection_params(vhost),
+                 queue=queue, queue_reset=queue_reset, callback_func=callback,
+                 exchange=exchange, exchange_reset=exchange_reset,
+                 exchange_type=exchange_type, error_func=error_handler,
+                 auto_ack=auto_ack, name=name, queue_exclusive=queue_exclusive,)
+        self.consumer_properties[name]['restart_attempts'] = \
+            int(restart_attempts)
         self.consumer_properties[name]['started'] = False
-        self.consumers[name] = ConsumerThread(**self.consumer_properties[name]['properties'])
+        self.consumers[name] = \
+            ConsumerThread(**self.consumer_properties[name]['properties'])
 
     def restart_consumer(self, name: str):
         self.stop_consumers(names=(name,))
         consumer_data = self.consumer_properties.get(name, {})
-        restart_attempts = consumer_data.get('restart_attempts', self.__max_consumer_restarts__)
+        restart_attempts = consumer_data.get('restart_attempts',
+                                             self.__max_consumer_restarts__)
         if not consumer_data.get('properties'):
             err_msg = 'creation properties not found'
         elif 0 < restart_attempts < consumer_data.get('num_restarted', 0):
             err_msg = 'num restarts exceeded'
         else:
             self.consumers[name] = ConsumerThread(**consumer_data['properties'])
             self.run_consumers(names=(name,))
@@ -492,28 +528,29 @@
                             callback: callable,
                             on_error: Optional[callable] = None,
                             exchange: str = None, exchange_reset: bool = False,
                             auto_ack: bool = True,
                             skip_on_existing: bool = False,
                             restart_attempts: int = __max_consumer_restarts__):
         """
-            Registers fanout exchange subscriber, wraps register_consumer()
-            Any raised exceptions will be passed as arguments to on_error.
-            :param name: Human readable name of the consumer
-            :param vhost: vhost to register on
-            :param exchange: MQ Exchange to bind to
-            :param exchange_reset: to delete exchange if exists
-                (defaults to False)
-            :param callback: Method to passed queued messages to
-            :param on_error: Optional method to handle any exceptions raised
-                in message handling
-            :param auto_ack: Boolean to enable ack of messages upon receipt
-            :param skip_on_existing: to skip if consumer already exists
-                (defaults to False)
-            :param restart_attempts: max instance restart attempts (if < 0 - will restart infinitely times)
+        Registers fanout exchange subscriber, wraps register_consumer()
+        Any raised exceptions will be passed as arguments to on_error.
+        :param name: Human readable name of the consumer
+        :param vhost: vhost to register on
+        :param exchange: MQ Exchange to bind to
+        :param exchange_reset: to delete exchange if exists
+            (defaults to False)
+        :param callback: Method to passed queued messages to
+        :param on_error: Optional method to handle any exceptions raised
+            in message handling
+        :param auto_ack: Boolean to enable ack of messages upon receipt
+        :param skip_on_existing: to skip if consumer already exists
+            (defaults to False)
+        :param restart_attempts: max instance restart attempts
+            (if < 0 - will restart infinitely times)
         """
         # for fanout exchange queue does not matter unless its non-conflicting
         # and is binded
         subscriber_queue = f'subscriber_{exchange}_{uuid.uuid4().hex[:6]}'
         LOG.info(f'Subscriber queue registered: {subscriber_queue} '
                  f'[subscriber_name={name},exchange={exchange},vhost={vhost}]')
         return self.register_consumer(name=name, vhost=vhost,
@@ -537,71 +574,78 @@
 
         :param names: names of consumers to consider
         :param daemon: to kill consumer threads once main thread is over
         """
         if not names or len(names) == 0:
             names = list(self.consumers)
         for name in names:
-            if isinstance(self.consumers.get(name), ConsumerThread) and not self.consumers[name].is_alive():
+            if isinstance(self.consumers.get(name), ConsumerThread) and not \
+                    self.consumers[name].is_alive():
                 self.consumers[name].daemon = daemon
                 self.consumers[name].start()
                 self.consumer_properties[name]['started'] = True
 
     def stop_consumers(self, names: tuple = ()):
         """
             Stops consumer threads based on the name if present
             (stops all of the declared consumers by default)
         """
         if not names or len(names) == 0:
             names = list(self.consumers)
         for name in names:
             try:
                 if name in list(self.consumers):
-                    self.consumers[name].join(timeout=self.__consumer_join_timeout__)
+                    self.consumers[name].join(
+                        timeout=self.__consumer_join_timeout__)
                     if self.consumers[name] and self.consumers[name].is_alive():
-                        err_msg = f'{name} is alive although was set to join for {self.__consumer_join_timeout__}!'
+                        err_msg = f'{name} is alive although was set to join ' \
+                                  f'for {self.__consumer_join_timeout__}!'
                         LOG.error(err_msg)
                         raise Exception(err_msg)
                     self.consumers[name] = None
                     self.consumer_properties[name]['started'] = False
             except Exception as e:
                 raise ChildProcessError(e)
 
-    @retry(callback_on_exceeded='stop_sync_thread', use_self=True, num_retries=__run_retries__)
+    @retry(callback_on_exceeded='stop_sync_thread', use_self=True,
+           num_retries=__run_retries__)
     def sync(self, vhost: str = None, exchange: str = None, queue: str = None,
              request_data: dict = None):
         """
-            Periodical notification message to be sent into MQ,
-            used to notify other network listeners about this service health status
+        Periodic notification message to be sent into MQ,
+        used to notify other network listeners about this service health status
 
-            :param vhost: mq virtual host (defaults to self.vhost)
-            :param exchange: mq exchange (defaults to base one)
-            :param queue: message queue prefix (defaults to self.service_name)
-            :param request_data: data to publish in sync
+        :param vhost: mq virtual host (defaults to self.vhost)
+        :param exchange: mq exchange (defaults to base one)
+        :param queue: message queue prefix (defaults to self.service_name)
+        :param request_data: data to publish in sync
         """
         vhost = vhost or self.vhost
         queue = f'{queue or self.service_name}_sync'
         exchange = exchange or ''
         request_data = request_data or {'service_id': self.service_id,
                                         'time': int(time.time())}
 
         with self.create_mq_connection(vhost=vhost) as mq_connection:
             LOG.debug(f'Emitting sync message to (vhost="{vhost}",'
                       f' exchange="{exchange}", queue="{queue}")')
             self.publish_message(mq_connection, exchange=exchange,
                                  request_data=request_data)
 
-    @retry(callback_on_exceeded='stop', use_self=True, num_retries=__run_retries__)
-    def run(self, run_consumers: bool = True, run_sync: bool = True, run_observer: bool = True, **kwargs):
-        """
-            Generic method called on running the instance
-
-            :param run_consumers: to run this instance consumers (defaults to True)
-            :param run_sync: to run synchronization thread (defaults to True)
-            :param run_observer: to run consumers state observation (defaults to True)
+    @retry(callback_on_exceeded='stop', use_self=True,
+           num_retries=__run_retries__)
+    def run(self, run_consumers: bool = True, run_sync: bool = True,
+            run_observer: bool = True, **kwargs):
+        """
+        Generic method called on running the instance
+
+        :param run_consumers: to run this instance consumers (defaults to True)
+        :param run_sync: to run synchronization thread (defaults to True)
+        :param run_observer: to run consumers state observation
+            (defaults to True)
         """
         host = self.config.get('server', 'localhost')
         port = int(self.config.get('port', '5672'))
         wait_for_mq_startup(host, port)
         kwargs.setdefault('consumer_names', ())
         kwargs.setdefault('daemonize_consumers', False)
         self.pre_run(**kwargs)
@@ -613,42 +657,48 @@
         if run_observer:
             self.observer_thread.start()
         self.post_run(**kwargs)
 
     @property
     def sync_thread(self):
         """Creates new synchronization thread if none is present"""
-        if not (isinstance(self._sync_thread, RepeatingTimer) and self._sync_thread.is_alive()):
+        if not (isinstance(self._sync_thread, RepeatingTimer) and
+                self._sync_thread.is_alive()):
             self._sync_thread = RepeatingTimer(self.sync_period, self.sync)
             self._sync_thread.daemon = True
         return self._sync_thread
 
     def stop_sync_thread(self):
         """Stops synchronization thread and dereferences it"""
         if self._sync_thread:
             self._sync_thread.cancel()
             self._sync_thread = None
 
     def observe_consumers(self):
-        """ Iteratively observes each consumer, and if it was launched but is not alive - restarts it """
+        """
+        Iteratively observes each consumer, and if it was launched but is not
+        alive - restarts it
+        """
         LOG.debug('Observers state observation')
         consumers_dict = copy.copy(self.consumers)
         for consumer_name, consumer_instance in consumers_dict.items():
             if self.consumer_properties[consumer_name]['started'] and \
                     not (isinstance(consumer_instance, ConsumerThread)
                          and consumer_instance.is_alive()
                          and consumer_instance.is_consuming):
                 LOG.info(f'Consumer "{consumer_name}" is dead, restarting')
                 self.restart_consumer(name=consumer_name)
 
     @property
     def observer_thread(self):
         """Creates new observer thread if none is present"""
-        if not (isinstance(self._observer_thread, RepeatingTimer) and self._observer_thread.is_alive()):
-            self._observer_thread = RepeatingTimer(self.observe_period, self.observe_consumers)
+        if not (isinstance(self._observer_thread, RepeatingTimer) and
+                self._observer_thread.is_alive()):
+            self._observer_thread = RepeatingTimer(self.observe_period,
+                                                   self.observe_consumers)
             self._observer_thread.daemon = True
         return self._observer_thread
 
     def stop_observer_thread(self):
         """Stops observer thread and dereferences it"""
         if self._observer_thread:
             self._observer_thread.cancel()
```

## neon_mq_connector/utils/__init__.py

```diff
@@ -22,9 +22,11 @@
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-from .thread_utils import RepeatingTimer
-from .connection_utils import retry, wait_for_mq_startup
+from neon_mq_connector.utils.thread_utils import RepeatingTimer
+from neon_mq_connector.utils.connection_utils import retry, wait_for_mq_startup
+
+# TODO: Deprecate wrapped imports
```

## neon_mq_connector/utils/client_utils.py

```diff
@@ -30,18 +30,19 @@
 import uuid
 
 from threading import Event
 from pika.channel import Channel
 from pika.exceptions import ProbableAccessDeniedError, StreamLostError
 from neon_mq_connector.connector import MQConnector
 from ovos_config.config import Configuration
+from ovos_utils.log import LOG
 
-from neon_utils.logger import LOG
-from neon_utils.socket_utils import b64_to_dict
+from neon_mq_connector.utils.network_utils import b64_to_dict
 
+# TODO: Leave below to configuration
 logging.getLogger("pika").setLevel(logging.CRITICAL)
 
 _default_mq_config = {
     "server": "api.neon.ai",
     "port": 5672,
     "users": {
         "mq_handler": {
```

## neon_mq_connector/utils/connection_utils.py

```diff
@@ -24,17 +24,17 @@
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import time
 from typing import Union, Callable
+from ovos_utils.log import LOG
 
-from neon_utils import LOG
-from neon_utils.net_utils import check_port_is_open
+from neon_mq_connector.utils.network_utils import check_port_is_open
 
 
 def get_timeout(backoff_factor: float, number_of_retries: int) -> float:
     """
         Gets timeout based on backoff_factor
 
         :param backoff_factor: value of backoff factor
@@ -48,30 +48,37 @@
             >>> __backoff_factor, __number_of_retries = 0.1, 2
             >>> timeout = get_timeout(__backoff_factor, __number_of_retries)
             >>> assert timeout == 0.2
     """
     return backoff_factor * (2 ** (number_of_retries - 1))
 
 
-def retry(callback_on_exceeded: Union[str, Callable] = None, callback_on_attempt_failure: Union[str, Callable] = None,
-          num_retries: int = 3, backoff_factor: float = 5, use_self: bool = False,
-          callback_on_attempt_failure_args: list = None, callback_on_exceeded_args: list = None):
+def retry(callback_on_exceeded: Union[str, Callable] = None,
+          callback_on_attempt_failure: Union[str, Callable] = None,
+          num_retries: int = 3, backoff_factor: float = 5,
+          use_self: bool = False,
+          callback_on_attempt_failure_args: list = None,
+          callback_on_exceeded_args: list = None):
     """
         Decorator for generic retrying function execution
 
-        :param use_self: to call a function from current class instance (defaults to False)
+        :param use_self: to call a function from current class instance
+            (defaults to False)
         :param num_retries: num of retries for function execution
-        :param callback_on_exceeded: function to call when all attempts fail (is s
+        :param callback_on_exceeded: function to call when all attempts fail
         :param callback_on_exceeded_args: args for :param callback_on_exceeded
-        :param callback_on_attempt_failure: function to call when single attempt fails
-        :param callback_on_attempt_failure_args: args for :param callback_on_attempt_failure
-        :param backoff_factor: value of backoff factor for setting delay between function execution retry,
-                               refer to "get_timeout()" for details
+        :param callback_on_attempt_failure: function to call when a single
+            attempt fails
+        :param callback_on_attempt_failure_args: args for
+            callback_on_attempt_failure
+        :param backoff_factor: value of backoff factor for setting delay between
+            function execution retry, refer to "get_timeout()" for details
     """
-    # TODO: given function shows non-thread-safe behaviour for Consumer Thread, need to fix this before using
+    # TODO: given function shows non-thread-safe behaviour for Consumer Thread,
+    #       need to fix this before using
     if not callback_on_attempt_failure_args:
         callback_on_attempt_failure_args = []
     if not callback_on_exceeded_args:
         callback_on_exceeded_args = []
 
     def decorator(function):
         def wrapper(self, *args, **kwargs):
@@ -93,37 +100,51 @@
                     for i in range(len(callback_on_attempt_failure_args)):
                         if callback_on_attempt_failure_args[i] == 'e':
                             callback_on_attempt_failure_args[i] = e
                         elif callback_on_attempt_failure_args[i] == 'self':
                             callback_on_attempt_failure_args[i] = self
                     try:
                         if callback_on_attempt_failure:
-                            if with_self and isinstance(callback_on_attempt_failure, str):
-                                getattr(self, callback_on_attempt_failure)(*callback_on_attempt_failure_args)
-                            elif isinstance(callback_on_attempt_failure, Callable):
-                                callback_on_attempt_failure(*callback_on_attempt_failure_args)
+                            if with_self and \
+                                    isinstance(callback_on_attempt_failure,
+                                               str):
+                                getattr(self, callback_on_attempt_failure)(
+                                    *callback_on_attempt_failure_args)
+
+                            elif isinstance(callback_on_attempt_failure,
+                                            Callable):
+                                callback_on_attempt_failure(
+                                    *callback_on_attempt_failure_args)
                     except Exception as ex:
-                        LOG.error(f'Failed to execute callback_on_attempt_failure function {callback_on_attempt_failure.__name__}({callback_on_attempt_failure_args}) - {ex}')
-                    sleep_timeout = get_timeout(backoff_factor=backoff_factor, number_of_retries=num_attempts)
-                    LOG.error(f'{error_body}: {e}. Timeout for {sleep_timeout} secs')
+                        LOG.error(f'Failed to execute '
+                                  f'callback_on_attempt_failure function '
+                                  f'{callback_on_attempt_failure.__name__}('
+                                  f'{callback_on_attempt_failure_args}) - {ex}')
+                    sleep_timeout = get_timeout(backoff_factor=backoff_factor,
+                                                number_of_retries=num_attempts)
+                    LOG.error(f'{error_body}: {e}. '
+                              f'Timeout for {sleep_timeout} secs')
                     num_attempts += 1
                     time.sleep(sleep_timeout)
-            LOG.error(f'Failed to execute function {error_body} after {num_retries} attempts')
+            LOG.error(f'Failed to execute function {error_body} after '
+                      f'{num_retries} attempts')
             if callback_on_exceeded:
                 if with_self and isinstance(callback_on_exceeded, str):
-                    return getattr(self, callback_on_exceeded)(*callback_on_exceeded_args)
+                    return getattr(self, callback_on_exceeded)(
+                        *callback_on_exceeded_args)
                 elif isinstance(callback_on_exceeded, Callable):
                     return callback_on_exceeded(*callback_on_exceeded_args)
         return wrapper
     return decorator
 
 
 def wait_for_mq_startup(addr: str, port: int, timeout: int = 60) -> bool:
     """
-    Wait up to `timeout` seconds for the MQ connection at `addr`:`port` to come online.
+    Wait up to `timeout` seconds for the MQ connection at `addr`:`port`
+    to come online.
     :param addr: URL or IP address to monitor
     :param port: MQ port to query
     :param timeout: Max seconds to wait for connection to come online
     """
     stop_time = time.time() + timeout
     while not check_port_is_open(addr, port):
         LOG.debug("Waiting for MQ server to come online")
```

## neon_mq_connector/utils/rabbit_utils.py

```diff
@@ -1,11 +1,39 @@
+# NEON AI (TM) SOFTWARE, Software Development Kit & Application Framework
+# All trademark and other rights reserved by their respective owners
+# Copyright 2008-2022 Neongecko.com Inc.
+# Contributors: Daniel McKnight, Guy Daniels, Elon Gasper, Richard Leeds,
+# Regina Bloomstine, Casimiro Ferreira, Andrii Pernatii, Kirill Hrymailo
+# BSD-3 License
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+# 1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution.
+# 3. Neither the name of the copyright holder nor the names of its
+#    contributors may be used to endorse or promote products derived from this
+#    software without specific prior written permission.
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+# OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
 from functools import wraps
+from ovos_utils.log import LOG
 
-from neon_utils.socket_utils import b64_to_dict
-from neon_utils.logger import LOG
+from neon_mq_connector.utils.network_utils import b64_to_dict
 
 
 def create_mq_callback(include_callback_props: tuple = ('body',)):
     """ Creates MQ callback method by filtering relevant MQ attributes """
 
     if not include_callback_props:
         include_callback_props = ()
@@ -22,20 +50,22 @@
                 if mq_props[idx] in include_callback_props:
                     value = f_args[idx]
                     if idx == 3:
                         if value and isinstance(value, bytes):
                             dict_data = b64_to_dict(value)
                             callback_kwargs['body'] = dict_data
                         else:
-                            raise TypeError(f'Invalid body received, expected: bytes string; got: {type(value)}')
+                            raise TypeError(f'Invalid body received, expected: '
+                                            f'bytes string; got: {type(value)}')
                     else:
                         callback_kwargs[mq_props[idx]] = value
             try:
                 res = f(self, **callback_kwargs)
             except Exception as ex:
-                LOG.error(f'Execution of {f.__name__} failed due to exception={ex}')
+                LOG.error(f'Execution of {f.__name__} failed due to '
+                          f'exception={ex}')
                 res = None
             return res
 
         return wrapped
 
     return wrapper
```

## Comparing `neon_mq_connector-0.6.1a2.dist-info/LICENSE.md` & `neon_mq_connector-0.6.1a3.dist-info/LICENSE.md`

 * *Files identical despite different names*

## Comparing `neon_mq_connector-0.6.1a2.dist-info/METADATA` & `neon_mq_connector-0.6.1a3.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 Metadata-Version: 2.1
 Name: neon-mq-connector
-Version: 0.6.1a2
+Version: 0.6.1a3
 Summary: MQ Connector for Neon Modules
 Home-page: https://github.com/NeonGeckoCom/neon_mq_connector
 Author: NeonGecko
 Author-email: developers@neon.ai
 License: BSD-3-Clause
 Platform: UNKNOWN
 Classifier: Intended Audience :: Developers
 Classifier: Programming Language :: Python :: 3.6
 Description-Content-Type: text/markdown
 Requires-Dist: pika (==1.2.0)
-Requires-Dist: neon-utils[network] (~=1.0)
+Requires-Dist: ovos-config (~=0.0.8)
+Requires-Dist: ovos-utils (~=0.0.32)
 
 # Neon MQ Connector
 The Neon MQ Connector is an MQ interface for microservices.
 
 ## Configuration
 A global configuration for the MQ Connector may be specified at `~/.config/neon/mq_config.json`. This configuration file 
 may contain the following keys:
```

## Comparing `neon_mq_connector-0.6.1a2.dist-info/RECORD` & `neon_mq_connector-0.6.1a3.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,14 +1,15 @@
-neon_mq_connector/__init__.py,sha256=EidNvPMFIU2J9Nax7W1TStweoePbU9_sHJJ5gMJ9JVc,1867
-neon_mq_connector/config.py,sha256=Rf_n7QYWTZjusJ6TeBSqNNCT2dV02J40oHo9KfA17eI,3452
-neon_mq_connector/connector.py,sha256=MuYBTWp_Cv9sax8hQEjDv3Ytop0FmTYjRFH_UCZC_CA,31649
-neon_mq_connector/utils/__init__.py,sha256=IzmAfUKo8sSnHXFzGVvxVai79zzjCtTWY8SkY51ViEg,1930
-neon_mq_connector/utils/client_utils.py,sha256=6EcqSUI1_9SO1rf7TC_AaQIoNFWdZimTwEGhi9lusOs,6156
-neon_mq_connector/utils/connection_utils.py,sha256=FBf02zOCCMsR53USJ7ss_BXNUf9KSF0j4hAXRImu0-0,7112
-neon_mq_connector/utils/rabbit_utils.py,sha256=61kiCMXSkBg4aNORK2zVl8OW_01xN4iv8wSo-SJvC3g,1383
+neon_mq_connector/__init__.py,sha256=WC23UcWdwM76Ii_a3AKfTkDxGFR8CbvfMy0XfJreRHs,1884
+neon_mq_connector/config.py,sha256=rHW9_IJaNiyecrdYak5Ejqw9hTict7TmNyHBwPhhexA,3558
+neon_mq_connector/connector.py,sha256=_0weqnkkYA0RLIMgAKg4E9H5gZRFQfgeg1_j45yl7To,32234
+neon_mq_connector/utils/__init__.py,sha256=qZ9lxm8PMtMf_kEiFaKPDwGhlQEa0kv_DJheWy4MnmU,2011
+neon_mq_connector/utils/client_utils.py,sha256=NGF3ZzUPLMfoHfeL90iYg0q-coIIkkpOAc9MD8ACMHw,6204
+neon_mq_connector/utils/connection_utils.py,sha256=p77q4CsyOee-wXUi5j32AaRdd9FAq4h-va10yOL9Ta8,7636
+neon_mq_connector/utils/network_utils.py,sha256=luK6hV-4URhxEcg3sLAXrliyRok9LAzfts7s1GL4W14,3215
+neon_mq_connector/utils/rabbit_utils.py,sha256=rDzbAHRd7-KF66hPlPuZ4kifxtnO48RTQt9omSYq3wI,3304
 neon_mq_connector/utils/thread_utils.py,sha256=LnF4H7bhU9jFkMbS2WDVbrc_qpaNaC2ZCHxOracdrfA,2131
-neon_mq_connector-0.6.1a2.dist-info/LICENSE.md,sha256=KxXbLh0XZkaLbNrj5ksC1Hl04EeiMbY-I0pGhKTPBRc,1635
-neon_mq_connector-0.6.1a2.dist-info/METADATA,sha256=P7VOf8xxTyxAv7x84WRJRJO00eXJIwtTcgu6dOjX7v4,3220
-neon_mq_connector-0.6.1a2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-neon_mq_connector-0.6.1a2.dist-info/top_level.txt,sha256=7GVRwlmJO6V-WXJ_pATe174KQVc2l8xx_2KVDbehPxE,18
-neon_mq_connector-0.6.1a2.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
-neon_mq_connector-0.6.1a2.dist-info/RECORD,,
+neon_mq_connector-0.6.1a3.dist-info/LICENSE.md,sha256=KxXbLh0XZkaLbNrj5ksC1Hl04EeiMbY-I0pGhKTPBRc,1635
+neon_mq_connector-0.6.1a3.dist-info/METADATA,sha256=GHH1yU2n7ZEwuFFUikADHlvGLyOR9Wjp34HQizMU4Y8,3251
+neon_mq_connector-0.6.1a3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+neon_mq_connector-0.6.1a3.dist-info/top_level.txt,sha256=7GVRwlmJO6V-WXJ_pATe174KQVc2l8xx_2KVDbehPxE,18
+neon_mq_connector-0.6.1a3.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
+neon_mq_connector-0.6.1a3.dist-info/RECORD,,
```

